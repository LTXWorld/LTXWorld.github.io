+++
date = '2025-04-11T09:44:17+08:00'
title = 'Golang进阶之切片核心'
categories = ["核心技术"]
tags = ["Golang","源码","Slice切片"]
+++ 
## 引子

在做力扣的题目时，特别是遇到递归问题，需要传入参数，遇到切片的时候经常遇到需要克隆切片的情况，而遇到普通的int类型的时候却不需要。显而易见，这是一个值传递还是引用传递的问题，所以今天我来总结一下Golang中切片的底层是什么，为什么在递归中需要克隆它。

## 切片

```bash
var res [3]int
var res []int
```

这里第一个指定长度的是数组，而第二个没有指定的是切片；前者是值类型，后者是引用类型**可以使用append操作**。
简单一句话，为了摆脱数组固定长度带来的束缚，我们使用更为灵活的切片slice。

![array](/img/golangPic/array.png)

### 切片底层

首先总结一句话：**切片 a 本身是一个结构体，a 代表底层数组地址（结构体里的 Data 字段），&a 才是结构体变量 a 本身在内存中的地址。**

```go
type slice struct {
    array unsafe.Pointer // 指向底层数组的指针
    len   int            // 切片的长度
    cap   int            // 切片的容量
}
```

其扩容机制如下：

- 当对切片进行 append 操作时，如果切片的长度小于其容量，Go 会直接在原底层数组的空间内添加元素，并更新切片的长度。
- 如果切片的长度等于或超过其容量，Go 会创建一个新的底层数组（通常是原来容量的 2 倍），将原数组的内容复制到新的数组中，并返回新的切片结构体。切片中的指针、长度和容量都会更新为新的数组和容量。

需要注意的是，为什么说切片是引用类型：切片本身是一个结构体（值类型），但它内部的指针指向底层数组。**因为它内部包含了指针，所以切片被认为是引用类型。**

其在堆栈上的表现如下：栈中保存结构体，堆中保存底层数组。

```go
a := []int{10, 20, 30}
```

```text
栈区：
+----------------------+       ← &a = 0xc00000e030
| 切片结构体 a         |
| Data: 0xc0000140a0   |  →→→→ 指向堆上的底层数组
| Len:  3              |
| Cap:  3              |
+----------------------+

堆区：
+----------------------+
| 10 | 20 | 30         | ← a.Data = &a[0] = 0xc0000140a0
+----------------------+
```

### append的注意点

append的扩容机制如上所述，但是需要注意的是

1. **nil切片在append时会被当作len=0, cap=0的切片处理**，所以如果对nil切片进行append其会自动为你分配一个新的底层数组，即指向底层数组的指针会发生改变。

```go
func main() {
    var res []int
    fmt.Printf("res结构体的地址是 %p, res指向底层数组的地址是 %p", &res, res)
    res = append(res, 1)
    fmt.Printf("res结构体的地址 %p, res指向底层数组的地址是 %p", &res, res)
}
```

2. **append每次会返回一个新的切片结构体，但是指向底层数组的指针如果不扩容就不变**。

### 常见问题

明白了切片的底层原理之后我们再来看看常见的问题，以下面的递归代码举例,本示例代码出自于力扣78子集问题，一道经典的回溯问题。

```go
func subsets(nums []int) [][]int {
    var res [][]int
    var path []int
    var dfs func(int)
    dfs = func(index int) {
        // 对于每个元素都会选或者不选，这会形成一颗决策二叉树，走到叶子节点收集结果即可。
        if index == len(nums) {
            res = append(res, slices.Clone(path))
            return 
        }
        // 不选
        dfs(index + 1)
        // 选
        path = append(path, nums[index])
        dfs(index + 1)
        // 最后进行回溯
        path = path[:len(path)-1]
    }
    dfs(0)
    return res
}
```

需要注意的点在于这句`res = append(res, slices.Clone(path))`，可以发现每次我们收集结果的时候都进行了克隆——克隆的作用在于创建一个新的切片，复制path当前的内容。

为什么要克隆？如果改成`res = append(res, path)`会怎么样？

由于path切片在代码中作为全局变量，被传入闭包函数中会被全局共享，即每一层递归都拿着这个path**指针**，如果不克隆，每次收集的时候都收集到的是一个**指针**，而后面的递归过程中可以看到，path指针会发生不断地变化，而这样的变化由于是指针的缘故会影响到之前我们收集的，导致收集结果受到影响。（我们默认不发生扩容）

所以我们需要对其进行克隆，每次都保存一份**当前那一刻的path的快照**。

题外话，如果我们不使用闭包函数的写法，这段代码会是这样的。

```go
func subsets(nums []int) [][]int {
    var res [][]int
    dfs(nums, 0, []int{}, &res)
    return res
}

func dfs(nums []int, index int, path []int, res *[][]int) {
    if index == len(nums) {
        clone := slices.Clone(path)
        *res = append(*res, clone)
        return
    }

    // 不选当前元素
    dfs(nums, index+1, path, res)

    // 选当前元素
    path = append(path, nums[index])
    dfs(nums, index+1, path, res)
    // 不需要回溯（因为 path 是函数参数，append 会生成新切片）
}
```

因为函数是值传递，每次传进来的path切片结构体不同，但是其底层指向的切片指针相同，这就导致我们必须要进行Clone操作，让res中添加的path都是“独一份”——独在不同的底层指针，这样你后面的修改不会影响到我克隆后的结果。

疑问1:*既然每层的path切片不同，但是其底层数组相同，那为什么不需要回溯？*

这句话本质上是错误的，因为我们的path刚开始是空的，所以一旦发生append就一定会发生扩容(这一点在上面的append注意点中提到过)，而扩容后底层数组就会不一样——这就导致在递归的时候有些层的底层数组是一样的，有些层不一样，所以不需要回溯，因为如果上一层为空，这层加入值，底层数组就会变，而回到上一层递归的时候我们就自动又回到那个为空的状态了。所以我们必须关注**nil切片在append时会被当作len=0, cap=0的切片处理**的情况。

而你可能还会问，这里为什么 `res *[][]int` 呢？因为函数的值传递，每次传入的res如果不加这个`*`就会导致每次传的都是一个副本，一个拷贝，即函数里面的res和你外面传过来的res不是一个切片结构体，那么在返回的时候自然无法获得正确结果——需要加上`*`进行

对比两种写法可以发现，闭包中使用的path是**全局变量**，需要回溯，需要克隆；而单独列出的写法中的path对于每层递归都是一个**新的切片**（append操作造成）每层之间不会互相影响，故不需要回溯。

一句话总结：**切片是结构体，传参传结构；结构中有指针，共享底层**

### Slices包

1. Clone(slice)强制拷贝所有元素到新的底层数组，**不共享内存**
2. Equal(a, b)
3. Compare(a, b)
4. Index(slice, val)
5. Delete(slice, i, j)删除下标范围[i,j)的元素，将前后两部分进行拼接
6. Sort(slice)对支持$<$运算符的进行升序排序，底层调用了`sort.Slice`

### 与Java简单比较

Java中通常使用`ArrayList<T>`，其底层也有一个数组，提供了add,remove,get,set等方法。

```java
public class ArrayList<E> {
    private Object[] elementData; // 底层数组
    private int size;             // 当前元素数量

    public boolean add(E e) {
        ensureCapacityInternal(size + 1);
        elementData[size++] = e;
    }
}
```

也会发生扩容，使用`Arrays.copyOf`重新分配新数组。

与切片不同的是，ArrayList是一个类，是一个引用类型，故传入参数是引用传递，不是Go中的值传递，所以对于上面那个`*res`,Java是不需要的，直接修改的原对象。

## 总结

切片，本身是个结构体，包含着指向**底层数组的指针，长度，容量这三个属性**；在函数值传递的过程中，在函数内部操作的是切片的副本，与原来的切片结构体不同，但是只要不发生扩容，底层的数组指针是相同的，如果想要相同切片，需要传入其地址；`append`操作总会产生一个新的切片结构体在栈中（因为其长度总会发生变化），与上面相同，**只要不发生扩容**，底层数组指针就是相同的。

**这里是LTX，感谢您阅读这篇博客，人生海海，和自己对话，像只蝴蝶纵横四海。**