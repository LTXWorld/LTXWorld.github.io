<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Golang on LTX's Blog</title><link>https://LTXWorld.github.io/tags/golang/</link><description>Recent content in Golang on LTX's Blog</description><image><title>LTX's Blog</title><url>https://LTXWorld.github.io/images/papermod-cover.png</url><link>https://LTXWorld.github.io/images/papermod-cover.png</link></image><generator>Hugo -- 0.145.0</generator><language>zh</language><copyright>©2025 LTX&amp;rsquo;s Blog</copyright><lastBuildDate>Wed, 16 Jul 2025 14:44:11 +0800</lastBuildDate><atom:link href="https://LTXWorld.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>GolangEP06:关于map-下</title><link>https://LTXWorld.github.io/posts/045golangep06%E5%85%B3%E4%BA%8Emap-%E4%B8%8B/</link><pubDate>Wed, 16 Jul 2025 14:44:11 +0800</pubDate><guid>https://LTXWorld.github.io/posts/045golangep06%E5%85%B3%E4%BA%8Emap-%E4%B8%8B/</guid><description>&lt;h2 id="引子">引子&lt;/h2>
&lt;p>上一篇文章中留下了两个问题没有解决&lt;/p>
&lt;ul>
&lt;li>map 如何扩容&lt;/li>
&lt;li>为什么原生的 map 线程不安全&lt;/li>
&lt;/ul>
&lt;p>其实这两个问题是有联系的，所以这篇文章来解决这两个问题。&lt;/p>
&lt;h2 id="map-的扩容机制">map 的扩容机制&lt;/h2>
&lt;p>本节还是需要用到上一篇文章中的底层 hmap 结构&lt;/p></description></item><item><title>GolangEP06:关于map-上</title><link>https://LTXWorld.github.io/posts/044golangep06%E5%85%B3%E4%BA%8Emap/</link><pubDate>Wed, 16 Jul 2025 09:52:36 +0800</pubDate><guid>https://LTXWorld.github.io/posts/044golangep06%E5%85%B3%E4%BA%8Emap/</guid><description>&lt;h2 id="引子">引子&lt;/h2>
&lt;p>在做两数之和时，操作 map 遇到了问题，可以看我下面的代码。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">twoSum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">nums&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">target&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">sMap&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">x&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">nums&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">sMap&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">i&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">ans&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">y&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">nums&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 如果另一个值在 map 中存在的话即下标大于等于 0;且要保证不能使用两次相同的元素&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">p&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">sMap&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">target&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="nx">y&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">p&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">p&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ans&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ans&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ans&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ans&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">p&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">ans&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>像极了一个 golang 新手的操作，特别是在判断 key 是否存在于哈希表中时，用值（下标）是否大于 0 来判断。（当然前面的哈希表的定义也有问题）&lt;/p></description></item><item><title>Golang版本更新工具</title><link>https://LTXWorld.github.io/posts/042golang%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0/</link><pubDate>Fri, 11 Jul 2025 11:40:27 +0800</pubDate><guid>https://LTXWorld.github.io/posts/042golang%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0/</guid><description>&lt;h2 id="引子">引子&lt;/h2>
&lt;p>在使用 Go 语言开发过程中，我发现经常会遇到想使用的项目的 Go 版本与当前本机的 Go 版本不一致的情况，通常是本地的版本较低。&lt;/p>
&lt;p>所以每次都需要去手动更新版本，而手动更新的过程是比较繁琐的，需要下载新版本并替换旧版本（听起来也没什么是吧）但是 Go 版本的更新还算是比较频繁的，特别是各种小版本。&lt;/p></description></item><item><title>GolangEP05_Go中的并发</title><link>https://LTXWorld.github.io/posts/031golangep05_%E5%B9%B6%E5%8F%9103%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%A8%E8%AE%BA%E5%B9%B6%E5%8F%91/</link><pubDate>Sat, 03 May 2025 21:04:26 +0800</pubDate><guid>https://LTXWorld.github.io/posts/031golangep05_%E5%B9%B6%E5%8F%9103%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%A8%E8%AE%BA%E5%B9%B6%E5%8F%91/</guid><description>&lt;h2 id="引子">引子&lt;/h2>
&lt;p>之前的两篇文章关于&lt;a href="https://www.bfsmlt.top/posts/005golangep01_%E5%B9%B6%E5%8F%9101_context/">context&lt;/a>和&lt;a href="https://www.bfsmlt.top/posts/007golangep02_%E5%B9%B6%E5%8F%9102chan/">channel&lt;/a>，我们都从源码的角度去讨论了其各自的底层原理以及使用方法。&lt;/p>
&lt;p>但是我并没有从宏观的角度上来阐述为什么我们需要并发？为什么要设计这两种结构来处理并发，本着做到&amp;quot;what-how-why&amp;quot;的态度，我们今天来深入讨论一下 Go 中的并发。&lt;/p></description></item><item><title>GolangEP04_string底层原理及注意事项</title><link>https://LTXWorld.github.io/posts/025golangep04_string%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link><pubDate>Fri, 25 Apr 2025 13:49:43 +0800</pubDate><guid>https://LTXWorld.github.io/posts/025golangep04_string%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid><description>&lt;h2 id="引子">引子&lt;/h2>
&lt;p>字符串操作在任何语言中的地位都十分重要，在上篇关于 Golang 中特殊的切片讲完之后，这一次我准备进入 Golang 中字符串的底层世界，包括引用总结自&amp;lt;100 Go Mistakes and How to Avoid Them (Teiva Harsanyi)&amp;gt; 书籍的注意事项。&lt;/p></description></item><item><title>GolangEP03_slice底层原理及注意事项</title><link>https://LTXWorld.github.io/posts/019golangep03_slice%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link><pubDate>Fri, 11 Apr 2025 09:44:17 +0800</pubDate><guid>https://LTXWorld.github.io/posts/019golangep03_slice%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid><description>&lt;h2 id="引子">引子&lt;/h2>
&lt;p>在做力扣的题目时，特别是遇到递归问题，需要传入参数，遇到切片的时候经常遇到需要克隆切片的情况，而遇到普通的int类型的时候却不需要。&lt;/p>
&lt;p>显而易见，这是一个值传递还是引用传递的问题，所以今天我来总结一下 Golang 中切片的底层原理，为什么在递归中需要克隆它。&lt;/p></description></item><item><title>GolangEP02_并发中的Channel</title><link>https://LTXWorld.github.io/posts/007golangep02_%E5%B9%B6%E5%8F%9102chan/</link><pubDate>Thu, 05 Dec 2024 15:40:56 +0800</pubDate><guid>https://LTXWorld.github.io/posts/007golangep02_%E5%B9%B6%E5%8F%9102chan/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>让我们看看关于 chan 有哪些常见的操作。&lt;/p>
&lt;h3 id="创建channel">创建channel&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">ch1&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">ch2&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>底层实际上调用的是&lt;a href="https://LTXWorld.github.io/posts/007golangep02_%E5%B9%B6%E5%8F%9102chan/#makechan%e5%87%bd%e6%95%b0">makechan&lt;/a>方法&lt;/p>
&lt;h3 id="发送数据到channel">发送数据到channel&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">ch&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>底层实际调用的是&lt;a href="https://LTXWorld.github.io/posts/007golangep02_%E5%B9%B6%E5%8F%9102chan/#chansend%e5%87%bd%e6%95%b0">chansend1&lt;/a>,而chansend1最终也是调用&lt;a href="https://LTXWorld.github.io/posts/007golangep02_%E5%B9%B6%E5%8F%9102chan/#chansend%e5%87%bd%e6%95%b0">chansend&lt;/a>,将block参数设置为true——当前发送操作是&lt;strong>阻塞的&lt;/strong>&lt;/p>
&lt;h3 id="从channel中读取数据">从channel中读取数据&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">i&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nx">ch&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ok&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nx">ch&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>底层实际调用的是&lt;a href="https://LTXWorld.github.io/posts/007golangep02_%E5%B9%B6%E5%8F%9102chan/#chanrecv%e5%87%bd%e6%95%b0">chanrecv1&lt;/a>和chanrecv2，最终都去调用了chanrecv。&lt;/p>
&lt;h2 id="源码">源码&lt;/h2>
&lt;p>接下来我们进入源码中一探究竟。&lt;/p>
&lt;h3 id="hchan结构体">hchan结构体&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">hchan&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">qcount&lt;/span> &lt;span class="kt">uint&lt;/span> &lt;span class="c1">// total data in the queue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">dataqsiz&lt;/span> &lt;span class="kt">uint&lt;/span> &lt;span class="c1">// size of the circular queue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">buf&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pointer&lt;/span> &lt;span class="c1">// points to an array of dataqsiz elements&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">elemsize&lt;/span> &lt;span class="kt">uint16&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">synctest&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="c1">// true if created in a synctest bubble&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">closed&lt;/span> &lt;span class="kt">uint32&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">timer&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">timer&lt;/span> &lt;span class="c1">// timer feeding this chan&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">elemtype&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">_type&lt;/span> &lt;span class="c1">// element type&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">sendx&lt;/span> &lt;span class="kt">uint&lt;/span> &lt;span class="c1">// send index&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">recvx&lt;/span> &lt;span class="kt">uint&lt;/span> &lt;span class="c1">// receive index&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">recvq&lt;/span> &lt;span class="nx">waitq&lt;/span> &lt;span class="c1">// list of recv waiters&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">sendq&lt;/span> &lt;span class="nx">waitq&lt;/span> &lt;span class="c1">// list of send waiters&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// lock protects all fields in hchan, as well as several&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// fields in sudogs blocked on this channel.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Do not change another G&amp;#39;s status while holding this lock&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// (in particular, do not ready a G), as this can deadlock&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// with stack shrinking.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">lock&lt;/span> &lt;span class="nx">mutex&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>qcount:通道中存储的数据元素总数&lt;/li>
&lt;li>dataqsiz:环形队列大小&lt;/li>
&lt;li>buf:执行环形队列的内存缓冲区，存放实际数据——环形缓存区域，本质上是一个带有头尾指针的固定长度的数组&lt;/li>
&lt;li>sendx,recvx:发收操作的队列位置&lt;/li>
&lt;li>recvq,sendq:等待队列&lt;/li>
&lt;/ul>
&lt;p>可以发现，hchan 使用&lt;strong>环形队列表示缓冲区&lt;/strong>并且采用 &lt;strong>lock 确保并发访问的安全性&lt;/strong>。&lt;/p></description></item><item><title>GolangEP01_并发之绕不过的context</title><link>https://LTXWorld.github.io/posts/005golangep01_%E5%B9%B6%E5%8F%9101_context/</link><pubDate>Sun, 01 Dec 2024 12:00:57 +0800</pubDate><guid>https://LTXWorld.github.io/posts/005golangep01_%E5%B9%B6%E5%8F%9101_context/</guid><description>&lt;h2 id="引子">引子&lt;/h2>
&lt;p>今天心血来潮，给自己梳理梳理golang中这个十分重要的东东——context，毕竟也是在面试中考察到，但是反问自己的时候却感觉一点也说不出来什么有价值的东西，所以今天我来一次刨根究底。&lt;/p></description></item></channel></rss>