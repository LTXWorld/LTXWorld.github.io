<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>DebugEP02_私有镜像出问题啦 | LTX&#39;s Blog</title>
<meta name="keywords" content="Nginx, CORS, Docker">
<meta name="description" content="引子
在使用私有镜像仓库时突然出现了认证问题，跟着 AI 来回改，在此记录一下改的过程。
首先回顾一下之前的那篇构建私有镜像仓库的文章,我们建立了两个容器，registry用来存放镜像,registry-UI用来给前端显示。">
<meta name="author" content="LTX">
<link rel="canonical" href="http://localhost:1313/posts/047%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E5%87%BA%E9%97%AE%E9%A2%98%E5%95%A6/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.6e3972293bbf4a9f6dd4b21687bb346e044b6210fc163c93db81a72185d1f6d5.css" integrity="sha256-bjlyKTu/Sp9t1LIWh7s0bgRLYhD8FjyT24GnIYXR9tU=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.png">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon.png">
<link rel="apple-touch-icon" href="http://localhost:1313/favicon.png">
<link rel="mask-icon" href="http://localhost:1313/favicon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/047%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E5%87%BA%E9%97%AE%E9%A2%98%E5%95%A6/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">
<script type="text/javascript"

        async

        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">

MathJax.Hub.Config({

  tex2jax: {

    inlineMath: [['$','$'], ['\\(','\\)']],

    displayMath: [['$$','$$'], ['\[\[','\]\]']],

    processEscapes: true,

    processEnvironments: true,

    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],

    TeX: { equationNumbers: { autoNumber: "AMS" },

         extensions: ["AMSmath.js", "AMSsymbols.js"] }

  }

});


MathJax.Hub.Queue(function() {

    

    

    

    var all = MathJax.Hub.getAllJax(), i;

    for(i = 0; i < all.length; i += 1) {

        all[i].SourceElement().parentNode.className += ' has-jax';

    }

});

</script>


<style>

code.has-jax {

    font: inherit;

    font-size: 100%;

    background: inherit;

    border: inherit;

    color: #515151;

}

</style><meta property="og:url" content="http://localhost:1313/posts/047%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E5%87%BA%E9%97%AE%E9%A2%98%E5%95%A6/">
  <meta property="og:site_name" content="LTX&#39;s Blog">
  <meta property="og:title" content="DebugEP02_私有镜像出问题啦">
  <meta property="og:description" content="引子 在使用私有镜像仓库时突然出现了认证问题，跟着 AI 来回改，在此记录一下改的过程。
首先回顾一下之前的那篇构建私有镜像仓库的文章,我们建立了两个容器，registry用来存放镜像,registry-UI用来给前端显示。">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-07-21T19:08:15+08:00">
    <meta property="article:modified_time" content="2025-07-21T19:08:15+08:00">
    <meta property="article:tag" content="Nginx">
    <meta property="article:tag" content="CORS">
    <meta property="article:tag" content="Docker">
      <meta property="og:image" content="http://localhost:1313/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png">
<meta name="twitter:title" content="DebugEP02_私有镜像出问题啦">
<meta name="twitter:description" content="引子
在使用私有镜像仓库时突然出现了认证问题，跟着 AI 来回改，在此记录一下改的过程。
首先回顾一下之前的那篇构建私有镜像仓库的文章,我们建立了两个容器，registry用来存放镜像,registry-UI用来给前端显示。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "DebugEP02_私有镜像出问题啦",
      "item": "http://localhost:1313/posts/047%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E5%87%BA%E9%97%AE%E9%A2%98%E5%95%A6/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "DebugEP02_私有镜像出问题啦",
  "name": "DebugEP02_私有镜像出问题啦",
  "description": "引子 在使用私有镜像仓库时突然出现了认证问题，跟着 AI 来回改，在此记录一下改的过程。\n首先回顾一下之前的那篇构建私有镜像仓库的文章,我们建立了两个容器，registry用来存放镜像,registry-UI用来给前端显示。\n",
  "keywords": [
    "Nginx", "CORS", "Docker"
  ],
  "articleBody": "引子 在使用私有镜像仓库时突然出现了认证问题，跟着 AI 来回改，在此记录一下改的过程。\n首先回顾一下之前的那篇构建私有镜像仓库的文章,我们建立了两个容器，registry用来存放镜像,registry-UI用来给前端显示。\n同时在服务器上使用 nginx 进行了反向代理，对浏览器传来的 https 请求进行处理\n两个80 端口用作 Let’s Encrypt 的 HTTP 验证 两个443 端口：一个用作 Registry,转发到本地:5000端口;一个用作 UI 界面，转发到本地的:8080端口，这两个本地端口其实都是容器服务所暴露的端口。 错误过程 CORS 一开始访问前端 UI 界面，显示了红色错误，显示Access-Control-Allow-Origin header must be set to https://registryui.bfsmlt.top\n这是一个 CORS 问题,为什么呢？因为浏览器前端页面https://registryui.bfsmit.top,会使用 js 向镜像仓库后端发送请求。\n而镜像后端在https://jimlt.bfsmlt.top上，二者不同源。\n关于Cross-Origin Requests,简单描述一下这个概念:\n协议，端口，域名三者有一个不同就不是同源 浏览器默认采用同源策略，防止不同源的网站读取当前网站的敏感信息 在 CORS 下允许服务器声明哪些源可以访问其资源 令我惊讶的是之前使用中一直没有发现问题，而且我在之前那篇文章中在启动 registry 容器时也已经指定了REGISTRY_HTTP_HEADERS_Access-Control-Allow-Origin等相关参数,按理来说应该不会出现 CORS 问题。\n说到这里我觉得有必要梳理一下整个流程\n浏览器访问https://registryui.bfsmlt.top 服务器中的 nginx 将这个请求转发给 ui 容器，即http://localhost:8080 容器返回给浏览器所需的 HTML,CSS,JS；浏览器借此组成界面 浏览器中 JS 根据容器设定的参数会去访问 https://jimlt.bfsmlt.top/v2/_catalog来获取镜像列表 而此时浏览器发现当前网页是在https://registryui.bfsmlt.top加载的，与要访问的https://jimlt.bfsmlt.top/v2/_catalog不同源;发生 CORS 问题 浏览器会发送一个 OPTIONS 预检请求，询问jimlt.bfsmlt.top 是否同意这次跨域请求 所以关键就在这里了，可能我们的容器运行时参数不够，得去修改 nginx,让jimlt.bfsmlt.top允许这次跨域请求。\n为 jimlt.bfsmlt.top 的 server 区域添加如下的预检请求，本质就是增加头部信息。\n# 处理浏览器的预检请求 if ($request_method = 'OPTIONS') { add_header 'Access-Control-Allow-Origin' 'https://registryui.bfsmlt.top' always; add_header 'Access-Control-Allow-Methods' 'HEAD, GET, OPTIONS, DELETE, PUT' always; add_header 'Access-Control-Allow-Headers' 'Authorization, Content-Type, Accept' always; add_header 'Access-Control-Allow-Credentials' 'true' always; add_header 'Access-Control-Max-Age' 1728000; add_header 'Content-Type' 'text/plain; charset=utf-8'; add_header 'Content-Length' 0; return 204; } # 为实际的 API 也加上标头 add_header 'Access-Control-Allow-Origin' 'https://registryui.bfsmlt.top' always; add_header 'Access-Control-Allow-Credentials' 'true' always; 502 Bad Gateway 这样修改之后又出现了新问题502 Bad Gateway502 Bad Gatewaynginx\n这意味着 Nginx 接收到了浏览器的请求，但是将请求转发给 registry 容器时失败了。\n我试着直接访问这个容器curl -I http://127.0.0.1:5000/v2/,显示无法连接。\n于是重启 docker 服务，再次尝试时不再是 502 问题了。终端出现认证问题是 401，因为我们之前设置过密码；\n但是，令人不解的是，浏览器访问页面时又出现了 CORS 问题。\n试着去掉缓存，去掉 cookie，不起作用。问题在于，此时浏览器应该给我出现填写用户名和密码的表单才对。\n更神奇的来了，我直接访问https://jimlt.bfsmlt.top/v2/_catalog成功了，可以看到镜像列表。\n所以我觉得还是从浏览器访问registry容器的这个过程出现了问题。\nUI升级 反思一下，当时我参考的自建镜像仓库的文章来源于 2020年的一篇博客，这个 registryUI 在 2021年进行了一次较大的改动。\n所以来到了改动页面，看看我们需要改什么参数。\n可以发现最大的变化在于以下几点:\nREGISTRY_URL 改为了 NGINX_PROXY_PASS_URL URL 改为了 REGISTRY_URL 从旧版本迁移时，SINGEL_REGISTRY = true 其中NGINX_PROXY_PASS_URL就是为了处理可能出现的 CORS 问题，这个字段表示 UI 容器内部的反向代理，至于到底发生了什么，见下方的最终修改。\n最终修改 到了这里，我感觉到应该是 UI 的版本更替问题，因为在之前使用过程中，好像出现过更新的提示。\n所以我决定将 registry 仓库和 UI 全部进行重建，并将他们放在同一个 dockerCompose 里面进行操作，这样可以充分利用 compose 的便利性。\n由于卷挂载的缘故，重建过程并不会影响之前已经存在的镜像和 TLS 信息 dokcer-compose 文件内容如下：\nversion: '3.8' services: # 後端 Registry 服務 registry: image: registry:2 container_name: registry restart: always ports: - \"5000:5000\" volumes: - /var/lib/registry:/var/lib/registry - /etc/docker/registry/auth:/auth # 如果您的憑證也想在這裡管理，也可以加上，但目前您的 Nginx 在使用，保持現狀即可。 # - /etc/docker/registry/certs:/certs environment: REGISTRY_HTTP_ADDR: 0.0.0.0:5000 REGISTRY_AUTH: htpasswd REGISTRY_AUTH_HTPASSWD_REALM: \"Registry Realm\" REGISTRY_AUTH_HTPASSWD_PATH: /auth/htpasswd networks: - registry-net # 前端 UI 服務 (使用我們最終確定的 v2 版本配置) registry-ui: image: joxit/docker-registry-ui:main container_name: registry-ui restart: always ports: - \"8080:80\" environment: SINGLE_REGISTRY: \"true\" NGINX_PROXY_PASS_URL: \"http://registry:5000\" REGISTRY_TITLE: \"My Private Registry\" DELETE_IMAGES: \"true\" depends_on: - registry networks: - registry-net networks: registry-net: driver: bridge 可以看到在 UI 服务中这两个参数SINGLE_REGISTRY: \"true\",NGINX_PROXY_PASS_URL: \"http://registry:5000\"\nJS的请求此时不会直接打到 registry 容器，而是访问 UI 容器GET https://registryui.bfsmlt.top/v2/_catalog UI 容器的内部 nginx 会将发来的请求反向代理到 http://registry:5000 而 registry 正是镜像容器的服务名称，通过 bridge 网络结构直接发送了过来。 最终后端容器接收请求，处理后再通过原路返回给前端。 注意，这个过程就不会出现 CORS 问题，因为SINGLE_REGISTRY: \"true\"的缘故，浏览器访问的还是同源下的路径，到了我们的服务器 Docker 环境中才转换了访问。\n这里用到了 compose 中的 bridge网络结构，利用了其内建 DNS 的特性——将服务名作为主机名来访问容器。 最后成功在浏览器进行访问，获取了镜像列表。\nGithub issues 一开始遇到问题询问 AI 我觉得无可厚非，但是在尝试过程中发现可能是 UI 出现问题，早该去对应的仓库中找找有没有类似的问题可以参考。\n找到了最近的相关 issue，可以发现就是版本更新带来的参数定义重置问题。\n并且在 README 中，作者也提到了这个问题，他的建议是\nI suggest to have your UI on the same domain than your registry e.g. registry.example.com/ui/ or use NGINX_PROXY_PASS_URL or configure a nginx/apache/haproxy in front of your registry that returns 200 on each OPTIONS requests.\n不要跨域 设置NGINX_PROXY_PASS_URL参数 设置nginx/apache/haproxy 同时他也提到了如果不进行设置会导致 CORS 的最终原因:\nThis is caused by a bug in docker registry, it returns 401 status requests on preflight requests, this breaks W3C preflight-request specification.\n即 registry 在收到预检请求 Options 后不会进行预检，还是会强调身份认证，所以预检失败，自然触发 CORS.\n总结 有趣的一次经历，巩固了 nginx 和 CORS 的相关知识。\n这里是LTX，感谢您阅读这篇博客，人生海海，和自己对话，像只蝴蝶纵横四海。\n",
  "wordCount" : "2568",
  "inLanguage": "zh",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2025-07-21T19:08:15+08:00",
  "dateModified": "2025-07-21T19:08:15+08:00",
  "author":{
    "@type": "Person",
    "name": "LTX"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/047%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E5%87%BA%E9%97%AE%E9%A2%98%E5%95%A6/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "LTX's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.png"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="LTX&#39;s Blog (Alt + H)">LTX&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="LTX&#39;s Blog">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/" title="后花园">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      DebugEP02_私有镜像出问题啦
    </h1>
    <div class="post-meta"><span title='2025-07-21 19:08:15 +0800 CST'>七月 21, 2025</span>&nbsp;·&nbsp;6 分钟&nbsp;·&nbsp;LTX

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%bc%95%e5%ad%90" aria-label="引子">引子</a></li>
                <li>
                    <a href="#%e9%94%99%e8%af%af%e8%bf%87%e7%a8%8b" aria-label="错误过程">错误过程</a><ul>
                        
                <li>
                    <a href="#cors" aria-label="CORS">CORS</a></li>
                <li>
                    <a href="#502-bad-gateway" aria-label="502 Bad Gateway">502 Bad Gateway</a></li>
                <li>
                    <a href="#ui%e5%8d%87%e7%ba%a7" aria-label="UI升级">UI升级</a></li>
                <li>
                    <a href="#%e6%9c%80%e7%bb%88%e4%bf%ae%e6%94%b9" aria-label="最终修改">最终修改</a></li></ul>
                </li>
                <li>
                    <a href="#github-issues" aria-label="Github issues">Github issues</a></li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="引子">引子<a hidden class="anchor" aria-hidden="true" href="#引子">#</a></h2>
<p>在使用私有镜像仓库时突然出现了认证问题，跟着 AI 来回改，在此记录一下改的过程。</p>
<p>首先回顾一下之前的那篇构建私有镜像仓库的文章,我们建立了两个容器，<code>registry</code>用来存放镜像,<code>registry-UI</code>用来给前端显示。</p>
<p>同时在服务器上使用 nginx 进行了反向代理，对浏览器传来的 https 请求进行处理</p>
<ul>
<li>两个80 端口用作 <code>Let’s Encrypt </code>的 HTTP 验证</li>
<li>两个443 端口：一个用作 Registry,转发到本地<code>:5000</code>端口;一个用作 UI 界面，转发到本地的<code>:8080</code>端口，这两个本地端口其实都是容器服务所暴露的端口。</li>
</ul>
<h2 id="错误过程">错误过程<a hidden class="anchor" aria-hidden="true" href="#错误过程">#</a></h2>
<h3 id="cors">CORS<a hidden class="anchor" aria-hidden="true" href="#cors">#</a></h3>
<p>一开始访问前端 UI 界面，显示了红色错误，显示<code>Access-Control-Allow-Origin header must be set to https://registryui.bfsmlt.top</code></p>
<p>这是一个 CORS 问题,为什么呢？因为浏览器前端页面<code>https://registryui.bfsmit.top</code>,会使用 js 向镜像仓库后端发送请求。</p>
<p>而镜像后端在<code>https://jimlt.bfsmlt.top</code>上，二者不同源。</p>
<p>关于<code>Cross-Origin Requests</code>,简单描述一下这个概念:</p>
<ul>
<li><em>协议，端口，域名</em>三者有一个不同就不是同源</li>
<li><strong>浏览器默认采用同源策略，防止不同源的网站读取当前网站的敏感信息</strong></li>
<li>在 CORS 下允许服务器声明哪些源可以访问其资源</li>
</ul>
<p>令我惊讶的是之前使用中一直没有发现问题，而且我在之前那篇文章中在启动 registry 容器时也已经指定了<code>REGISTRY_HTTP_HEADERS_Access-Control-Allow-Origin</code>等相关参数,按理来说应该不会出现 CORS 问题。</p>
<p>说到这里我觉得有必要梳理一下整个流程</p>
<ul>
<li>浏览器访问<code>https://registryui.bfsmlt.top</code></li>
<li>服务器中的 nginx 将这个请求转发给 ui 容器，即<code>http://localhost:8080</code></li>
<li>容器返回给浏览器所需的 <code>HTML,CSS,JS</code>；浏览器借此组成界面</li>
<li>浏览器中 <code>JS</code> 根据容器设定的参数会去访问 <code>https://jimlt.bfsmlt.top/v2/_catalog</code>来获取镜像列表</li>
<li>而此时浏览器发现当前网页是在<code>https://registryui.bfsmlt.top</code>加载的，与要访问的<code>https://jimlt.bfsmlt.top/v2/_catalog</code>不同源;发生 CORS 问题</li>
<li>浏览器会发送一个 <code>OPTIONS</code> <strong>预检</strong>请求，询问<code>jimlt.bfsmlt.top</code> 是否同意这次跨域请求</li>
</ul>
<p>所以关键就在这里了，可能我们的容器运行时参数不够，得去修改 nginx,让<code>jimlt.bfsmlt.top</code>允许这次跨域请求。</p>
<p>为 <code>jimlt.bfsmlt.top</code> 的 <strong>server 区域</strong>添加如下的预检请求，本质就是增加头部信息。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">        <span class="c1"># 处理浏览器的预检请求</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="nv">$request_method</span> <span class="o">=</span> <span class="s1">&#39;OPTIONS&#39;</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            add_header <span class="s1">&#39;Access-Control-Allow-Origin&#39;</span> <span class="s1">&#39;https://registryui.bfsmlt.top&#39;</span> always<span class="p">;</span>
</span></span><span class="line"><span class="cl">            add_header <span class="s1">&#39;Access-Control-Allow-Methods&#39;</span> <span class="s1">&#39;HEAD, GET, OPTIONS, DELETE, PUT&#39;</span> always<span class="p">;</span>
</span></span><span class="line"><span class="cl">            add_header <span class="s1">&#39;Access-Control-Allow-Headers&#39;</span> <span class="s1">&#39;Authorization, Content-Type, Accept&#39;</span> always<span class="p">;</span>
</span></span><span class="line"><span class="cl">            add_header <span class="s1">&#39;Access-Control-Allow-Credentials&#39;</span> <span class="s1">&#39;true&#39;</span> always<span class="p">;</span>
</span></span><span class="line"><span class="cl">            add_header <span class="s1">&#39;Access-Control-Max-Age&#39;</span> 1728000<span class="p">;</span>
</span></span><span class="line"><span class="cl">            add_header <span class="s1">&#39;Content-Type&#39;</span> <span class="s1">&#39;text/plain; charset=utf-8&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            add_header <span class="s1">&#39;Content-Length&#39;</span> 0<span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> 204<span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># 为实际的 API 也加上标头</span>
</span></span><span class="line"><span class="cl">        add_header <span class="s1">&#39;Access-Control-Allow-Origin&#39;</span> <span class="s1">&#39;https://registryui.bfsmlt.top&#39;</span> always<span class="p">;</span>
</span></span><span class="line"><span class="cl">        add_header <span class="s1">&#39;Access-Control-Allow-Credentials&#39;</span> <span class="s1">&#39;true&#39;</span> always<span class="p">;</span>
</span></span></code></pre></div><h3 id="502-bad-gateway">502 Bad Gateway<a hidden class="anchor" aria-hidden="true" href="#502-bad-gateway">#</a></h3>
<p>这样修改之后又出现了新问题<code>&lt;html&gt;&lt;head&gt;&lt;title&gt;502 Bad Gateway&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;502 Bad Gateway&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;</code></p>
<p>这意味着 <strong>Nginx 接收到了浏览器的请求，但是将请求转发给 registry 容器时失败了。</strong></p>
<p>我试着直接访问这个容器<code>curl -I http://127.0.0.1:5000/v2/</code>,显示无法连接。</p>
<p>于是重启 docker 服务，再次尝试时不再是 502 问题了。终端出现认证问题是 401，因为我们之前设置过密码；</p>
<p>但是，令人不解的是，浏览器访问页面时又出现了 CORS 问题。</p>
<p>试着去掉缓存，去掉 cookie，不起作用。问题在于，此时浏览器应该给我出现填写用户名和密码的表单才对。</p>
<p>更神奇的来了，我直接访问<code>https://jimlt.bfsmlt.top/v2/_catalog</code>成功了，可以看到镜像列表。</p>
<p>所以我觉得还是从浏览器访问<code>registry</code>容器的这个过程出现了问题。</p>
<h3 id="ui升级">UI升级<a hidden class="anchor" aria-hidden="true" href="#ui升级">#</a></h3>
<p>反思一下，当时我参考的自建镜像仓库的文章来源于 2020年的一篇博客，这个 <code>registryUI</code> 在 2021年进行了一次<a href="https://github.com/Joxit/docker-registry-ui/wiki/Migrating-from-1.x-to-2.x">较大的改动</a>。</p>
<p>所以来到了改动页面，看看我们需要改什么参数。</p>
<p>可以发现最大的变化在于以下几点:</p>
<ul>
<li><code>REGISTRY_URL</code> 改为了 <code>NGINX_PROXY_PASS_URL</code></li>
<li><code>URL</code> 改为了 <code>REGISTRY_URL</code></li>
<li>从旧版本迁移时，<code>SINGEL_REGISTRY = true</code></li>
</ul>
<p>其中<code>NGINX_PROXY_PASS_URL</code>就是为了处理可能出现的 CORS 问题，这个字段表示 UI 容器内部的反向代理，至于到底发生了什么，见下方的最终修改。</p>
<h3 id="最终修改">最终修改<a hidden class="anchor" aria-hidden="true" href="#最终修改">#</a></h3>
<p>到了这里，我感觉到应该是 UI 的版本更替问题，因为在之前使用过程中，好像出现过更新的提示。</p>
<p>所以我决定将 registry 仓库和 UI 全部进行重建，并将他们放在同一个 <strong>dockerCompose</strong> 里面进行操作，这样可以充分利用 compose 的便利性。</p>
<ul>
<li>由于卷挂载的缘故，重建过程并不会影响之前已经存在的镜像和 TLS 信息</li>
</ul>
<p>dokcer-compose 文件内容如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yml" data-lang="yml"><span class="line"><span class="cl"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;3.8&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 後端 Registry 服務</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">registry</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">registry:2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="l">registry</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l">always</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;5000:5000&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">/var/lib/registry:/var/lib/registry</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">/etc/docker/registry/auth:/auth</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c"># 如果您的憑證也想在這裡管理，也可以加上，但目前您的 Nginx 在使用，保持現狀即可。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c"># - /etc/docker/registry/certs:/certs </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">REGISTRY_HTTP_ADDR</span><span class="p">:</span><span class="w"> </span><span class="m">0.0.0.0</span><span class="p">:</span><span class="m">5000</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">REGISTRY_AUTH</span><span class="p">:</span><span class="w"> </span><span class="l">htpasswd</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">REGISTRY_AUTH_HTPASSWD_REALM</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;Registry Realm&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">REGISTRY_AUTH_HTPASSWD_PATH</span><span class="p">:</span><span class="w"> </span><span class="l">/auth/htpasswd</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">registry-net</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 前端 UI 服務 (使用我們最終確定的 v2 版本配置)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">registry-ui</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">joxit/docker-registry-ui:main</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="l">registry-ui</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l">always</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;8080:80&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">SINGLE_REGISTRY</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;true&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">NGINX_PROXY_PASS_URL</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;http://registry:5000&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">REGISTRY_TITLE</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;My Private Registry&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">DELETE_IMAGES</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;true&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">registry</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">registry-net</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">registry-net</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">driver</span><span class="p">:</span><span class="w"> </span><span class="l">bridge</span><span class="w">
</span></span></span></code></pre></div><p>可以看到在 UI 服务中这两个参数<code>SINGLE_REGISTRY: &quot;true&quot;</code>,<code>NGINX_PROXY_PASS_URL: &quot;http://registry:5000&quot;</code></p>
<ul>
<li>JS的请求此时不会直接打到 registry 容器，而是访问 UI 容器<code>GET https://registryui.bfsmlt.top/v2/_catalog</code></li>
<li>UI 容器的内部 nginx 会将发来的请求反向代理到 <code>http://registry:5000</code></li>
<li>而 registry 正是镜像容器的服务名称，通过 bridge 网络结构直接发送了过来。</li>
<li>最终后端容器接收请求，处理后再通过原路返回给前端。</li>
</ul>
<p>注意，这个过程就不会出现 CORS 问题，因为<code>SINGLE_REGISTRY: &quot;true&quot;</code>的缘故，<em>浏览器访问的还是同源下的路径，到了我们的服务器 Docker 环境中才转换了访问</em>。</p>
<ul>
<li>这里用到了 compose 中的 bridge网络结构，利用了其内建 DNS 的特性——将服务名作为主机名来访问容器。</li>
</ul>
<p>最后成功在浏览器进行访问，获取了镜像列表。</p>
<h2 id="github-issues">Github issues<a hidden class="anchor" aria-hidden="true" href="#github-issues">#</a></h2>
<p>一开始遇到问题询问 AI 我觉得无可厚非，但是在尝试过程中发现可能是 UI 出现问题，早该去对应的仓库中找找有没有类似的问题可以参考。</p>
<p>找到了最近的相关 <a href="https://github.com/Joxit/docker-registry-ui/issues/426">issue</a>，可以发现就是版本更新带来的参数定义重置问题。</p>
<p>并且在 README 中，作者也提到了这个问题，他的建议是</p>
<blockquote>
<p>I suggest to have your UI on the same domain than your registry e.g. registry.example.com/ui/ or use NGINX_PROXY_PASS_URL or configure a nginx/apache/haproxy in front of your registry that returns 200 on each OPTIONS requests.</p></blockquote>
<ul>
<li>不要跨域</li>
<li>设置<code>NGINX_PROXY_PASS_URL</code>参数</li>
<li>设置<code>nginx/apache/haproxy</code></li>
</ul>
<p>同时他也提到了如果不进行设置会导致 CORS 的最终原因:</p>
<blockquote>
<p>This is caused by a bug in docker registry, it returns 401 status requests on preflight requests, this breaks W3C preflight-request specification.</p></blockquote>
<p>即 registry 在收到预检请求 Options 后不会进行预检，还是会强调身份认证，所以预检失败，自然触发 CORS.</p>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<p>有趣的一次经历，巩固了 nginx 和 CORS 的相关知识。</p>
<p><strong>这里是LTX，感谢您阅读这篇博客，人生海海，和自己对话，像只蝴蝶纵横四海。</strong></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/nginx/">Nginx</a></li>
      <li><a href="http://localhost:1313/tags/cors/">CORS</a></li>
      <li><a href="http://localhost:1313/tags/docker/">Docker</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/049cors/">
    <span class="title">« 上一页</span>
    <br>
    <span>兴趣八股之计算机网络EP03——CORS浅探</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/046golangep07-range%E9%81%8D%E5%8E%86/">
    <span class="title">下一页 »</span>
    <br>
    <span>GolangEP07-Range遍历(上)</span>
  </a>
</nav>

  </footer><div id="tw-comment"></div>

<script>

    

    const getStoredTheme = () => localStorage.getItem("pref-theme") === "light" ? "light" : "dark";

    const setGiscusTheme = () => {

        const sendMessage = (message) => {

            const iframe = document.querySelector('iframe.giscus-frame');

            if (iframe) {

                iframe.contentWindow.postMessage({giscus: message}, 'https://giscus.app');

            }

        }

        sendMessage({setConfig: {theme: getStoredTheme()}})

    }


    document.addEventListener("DOMContentLoaded", () => {

        const giscusAttributes = {

            "src": "https://giscus.app/client.js",

            "data-repo": "LTXWorld\/LTXWorld.github.io",

            "data-repo-id": "R_kgDONODUuA",

            "data-category": "Announcements",

            "data-category-id": "DIC_kwDONODUuM4CkMUw",

            "data-mapping": "pathname",

            "data-strict": "0",

            "data-reactions-enabled": "1",

            "data-emit-metadata": "0",

            "data-input-position": "bottom",

            "data-theme": getStoredTheme(),

            "data-lang": "zh-CN",

            "data-loading": "lazy",

            "crossorigin": "anonymous",

        };


        

        const giscusScript = document.createElement("script");

        Object.entries(giscusAttributes).forEach(

                ([key, value]) => giscusScript.setAttribute(key, value));

        document.querySelector("#tw-comment").appendChild(giscusScript);


        

        const themeSwitcher = document.querySelector("#theme-toggle");

        if (themeSwitcher) {

            themeSwitcher.addEventListener("click", setGiscusTheme);

        }

        const themeFloatSwitcher = document.querySelector("#theme-toggle-float");

        if (themeFloatSwitcher) {

            themeFloatSwitcher.addEventListener("click", setGiscusTheme);

        }

    });

</script>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://LTXWorld.github.io/">©2025 LTX&rsquo;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a><div class="ltx-music-player" id="ltx-music-player" role="group" aria-label="背景音乐播放器">
  <audio id="ltx-music-audio" preload="metadata"></audio>
  <div class="ltx-drag-handle" data-role="drag-handle" title="上下拖动调整位置"></div>
  <div class="ltx-music-header">
    <div class="ltx-music-visual">
      <div class="ltx-disc" data-role="disc" aria-hidden="true">
        <img data-role="cover" alt="" loading="lazy" decoding="async">
        <div class="ltx-disc-center"></div>
      </div>
    </div>
    <div class="ltx-music-meta">
      <span class="ltx-music-title" data-role="title"></span>
      <span class="ltx-music-artist" data-role="artist"></span>
    </div>
    <button type="button" class="ltx-music-hide" data-action="collapse" aria-label="隐藏播放器">&#215;</button>
  </div>
  <div class="ltx-music-progress" data-role="progress" aria-label="进度条" role="slider">
    <div class="ltx-music-progress-fill" data-role="progress-fill"></div>
  </div>
  <div class="ltx-music-time">
    <span data-role="current">0:00</span>
    <span data-role="total">--:--</span>
  </div>
  <div class="ltx-music-controls">
    <button type="button" data-action="prev" aria-label="上一首">⏮</button>
    <button type="button" data-action="toggle" aria-label="播放或暂停">
      <span data-icon="play">▶</span>
      <span data-icon="pause">⏸</span>
    </button>
    <button type="button" data-action="next" aria-label="下一首">⏭</button>
    <button type="button" data-action="mute" aria-label="静音或取消静音">
      <span data-icon="unmuted">🔊</span>
      <span data-icon="muted">🔇</span>
    </button>
  </div>
  <div class="ltx-autoplay-tip" data-role="tip" aria-live="polite"></div>
</div>
<button type="button" class="ltx-music-fab" id="ltx-music-fab" aria-label="显示音乐播放器">&#9835;</button>
<script>
  window.LTX_MUSIC_CONFIG = {"autoplay":true,"defaultCover":"","loopPlaylist":true,"startVolume":0.6,"tracks":[{"artist":"王力宏","file":"/audio/02 - 依然爱你.mp3","title":"依然爱你"},{"artist":"王力宏","file":"/audio/05 - 改变自己.mp3","title":"改变自己"},{"artist":"王力宏","file":"/audio/11 - 爱错.mp3","title":"爱错"}]};
  (function () {
    const config = window.LTX_MUSIC_CONFIG || {};
    if (!config.tracks || !config.tracks.length) {
      return;
    }

    const player = document.getElementById('ltx-music-player');
    const audio = player.querySelector('audio');
    const titleEl = player.querySelector('[data-role="title"]');
    const artistEl = player.querySelector('[data-role="artist"]');
    const progressEl = player.querySelector('[data-role="progress"]');
    const progressFillEl = player.querySelector('[data-role="progress-fill"]');
    const currentTimeEl = player.querySelector('[data-role="current"]');
    const totalTimeEl = player.querySelector('[data-role="total"]');
    const tipEl = player.querySelector('[data-role="tip"]');
    const coverEl = player.querySelector('[data-role="cover"]');

    const toggleBtn = player.querySelector('[data-action="toggle"]');
    const prevBtn = player.querySelector('[data-action="prev"]');
    const nextBtn = player.querySelector('[data-action="next"]');
    const muteBtn = player.querySelector('[data-action="mute"]');
    const collapseBtn = player.querySelector('[data-action="collapse"]');
    const dragHandle = player.querySelector('[data-role="drag-handle"]');
    const fabButton = document.getElementById('ltx-music-fab');

    const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
    const formatTime = (seconds) => {
      if (!Number.isFinite(seconds)) {
        return '--:--';
      }
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${String(mins).padStart(1, '0')}:${String(secs).padStart(2, '0')}`;
    };

    const minOffset = -120;
    const maxOffset = 220;
    const hideThreshold = 180;
    const dragState = { active: false, startY: 0, startOffset: 0, pointerId: null };

    const state = {
      index: 0,
      tracks: config.tracks,
      autoplay: config.autoplay !== false,
      loopPlaylist: config.loopPlaylist !== false,
      offset: 0,
      collapsed: false,
    };

    const setOffset = (value) => {
      state.offset = clamp(value, minOffset, maxOffset);
      player.style.setProperty('--ltx-offset', `${state.offset}px`);
    };

    const setCollapsed = (value) => {
      const collapsed = Boolean(value);
      state.collapsed = collapsed;
      player.classList.toggle('ltx-collapsed', collapsed);
      if (collapsed) {
        player.classList.remove('ltx-dragging');
        state.offset = 0;
        player.style.removeProperty('--ltx-offset');
        if (fabButton) {
          fabButton.classList.add('ltx-visible');
          fabButton.setAttribute('aria-hidden', 'false');
          fabButton.tabIndex = 0;
        }
      } else {
        setOffset(0);
        if (fabButton) {
          fabButton.classList.remove('ltx-visible');
          fabButton.setAttribute('aria-hidden', 'true');
          fabButton.tabIndex = -1;
        }
      }
    };

    const updateMuteClass = () => {
      const muted = audio.muted || audio.volume === 0;
      player.classList.toggle('ltx-muted', muted);
    };

    audio.volume = clamp(config.startVolume ?? 0.6, 0, 1);
    updateMuteClass();
    setCollapsed(false);

    const updateProgress = () => {
      const duration = audio.duration || 0;
      const current = audio.currentTime || 0;
      const percentage = duration ? (current / duration) * 100 : 0;
      progressFillEl.style.width = `${percentage}%`;
      currentTimeEl.textContent = formatTime(current);
      totalTimeEl.textContent = formatTime(duration);
    };

    const setTrack = (nextIndex, options = {}) => {
      const total = state.tracks.length;
      state.index = ((nextIndex % total) + total) % total;
      const track = state.tracks[state.index];
      if (!track || !track.file) {
        console.warn('LTX music player: 音频文件缺失', track);
        tipEl.textContent = '音频文件缺失，请检查配置';
        return;
      }
      const cover = track.cover || config.defaultCover || '';
      if (coverEl) {
        if (cover) {
          coverEl.src = cover;
          coverEl.alt = track.title ? `${track.title} 封面` : '音乐封面';
          player.classList.add('ltx-has-cover');
        } else {
          coverEl.removeAttribute('src');
          coverEl.alt = '';
          player.classList.remove('ltx-has-cover');
        }
      }
      titleEl.textContent = track.title || `Track ${state.index + 1}`;
      artistEl.textContent = track.artist || '';
      audio.src = track.file;
      player.dataset.trackIndex = state.index;
      tipEl.textContent = '';
      player.classList.remove('ltx-autoplay-blocked');
      updateProgress();
      if (options.play) {
        attemptPlay();
      }
    };

    const attemptPlay = () => {
      audio.play().then(() => {
        player.classList.remove('ltx-autoplay-blocked');
        tipEl.textContent = '';
      }).catch(() => {
        player.classList.add('ltx-autoplay-blocked');
        tipEl.textContent = '浏览器阻止了自动播放，请点击播放按钮';
      });
    };

    const playNext = (autoTriggered = false) => {
      const shouldPlay = !audio.paused || autoTriggered;
      const nextIndex = state.index + 1;
      if (nextIndex >= state.tracks.length && !state.loopPlaylist) {
        audio.currentTime = audio.duration || 0;
        audio.pause();
        return;
      }
      setTrack(nextIndex, { play: shouldPlay });
    };

    const playPrev = () => {
      const shouldPlay = !audio.paused;
      setTrack(state.index - 1, { play: shouldPlay });
    };

    if (collapseBtn) {
      collapseBtn.addEventListener('click', () => setCollapsed(true));
    }

    if (fabButton) {
      fabButton.addEventListener('click', () => setCollapsed(false));
      fabButton.setAttribute('aria-hidden', 'true');
      fabButton.tabIndex = -1;
    }

    if (dragHandle) {
      dragHandle.style.touchAction = 'none';
      dragHandle.addEventListener('pointerdown', (event) => {
        if (state.collapsed) {
          return;
        }
        dragState.active = true;
        dragState.pointerId = event.pointerId;
        dragState.startY = event.clientY;
        dragState.startOffset = state.offset;
        if (dragHandle.setPointerCapture) {
          try {
            dragHandle.setPointerCapture(event.pointerId);
          } catch (err) {
             
          }
        }
        player.classList.add('ltx-dragging');
      });

      dragHandle.addEventListener('pointermove', (event) => {
        if (!dragState.active) {
          return;
        }
        const delta = event.clientY - dragState.startY;
        setOffset(dragState.startOffset + delta);
      });

      const finishDrag = () => {
        if (!dragState.active) {
          return;
        }
        if (dragState.pointerId !== null && dragHandle.releasePointerCapture) {
          try {
            dragHandle.releasePointerCapture(dragState.pointerId);
          } catch (err) {
             
          }
        }
        dragState.active = false;
        dragState.pointerId = null;
        player.classList.remove('ltx-dragging');
        if (state.offset > hideThreshold) {
          setCollapsed(true);
        } else {
          setOffset(state.offset);
        }
      };

      ['pointerup', 'pointercancel'].forEach((eventName) => {
        dragHandle.addEventListener(eventName, finishDrag);
      });

      dragHandle.addEventListener('pointerleave', () => {
        if (!dragState.active) {
          return;
        }
        finishDrag();
      });
    }

    toggleBtn.addEventListener('click', () => {
      if (audio.paused) {
        attemptPlay();
      } else {
        audio.pause();
      }
    });

    prevBtn.addEventListener('click', playPrev);
    nextBtn.addEventListener('click', () => playNext(false));

    muteBtn.addEventListener('click', () => {
      audio.muted = !audio.muted;
      updateMuteClass();
    });

    progressEl.addEventListener('click', (event) => {
      const rect = progressEl.getBoundingClientRect();
      const ratio = clamp((event.clientX - rect.left) / rect.width, 0, 1);
      if (Number.isFinite(audio.duration)) {
        audio.currentTime = ratio * audio.duration;
      }
    });

    audio.addEventListener('timeupdate', updateProgress);
    audio.addEventListener('loadedmetadata', updateProgress);

    audio.addEventListener('play', () => {
      player.classList.add('ltx-playing');
      player.classList.remove('ltx-autoplay-blocked');
      tipEl.textContent = '';
    });

    audio.addEventListener('pause', () => {
      player.classList.remove('ltx-playing');
    });

    audio.addEventListener('ended', () => {
      playNext(true);
    });

    audio.addEventListener('volumechange', updateMuteClass);

    setTrack(0, { play: state.autoplay });
  })();
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
