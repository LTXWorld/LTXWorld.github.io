<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>GolangEP01_并发之绕不过的context | LTX&#39;s Blog</title>
<meta name="keywords" content="Golang, 源码, Context">
<meta name="description" content="引子
今天心血来潮，给自己梳理梳理golang中这个十分重要的东东——context，毕竟也是在面试中考察到，但是反问自己的时候却感觉一点也说不出来什么有价值的东西，所以今天我来一次刨根究底。">
<meta name="author" content="LTX">
<link rel="canonical" href="http://localhost:1313/posts/005golangep01_%E5%B9%B6%E5%8F%9101_context/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.60bb00c7b34dfc1f8b8a6f21b1fe067b40b3bc3a287fc1d4a3657a89a977208e.css" integrity="sha256-YLsAx7NN/B&#43;Lim8hsf4Ge0CzvDoof8HUo2V6ial3II4=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.png">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon.png">
<link rel="apple-touch-icon" href="http://localhost:1313/favicon.png">
<link rel="mask-icon" href="http://localhost:1313/favicon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/005golangep01_%E5%B9%B6%E5%8F%9101_context/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">
<script type="text/javascript"

        async

        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">

MathJax.Hub.Config({

  tex2jax: {

    inlineMath: [['$','$'], ['\\(','\\)']],

    displayMath: [['$$','$$'], ['\[\[','\]\]']],

    processEscapes: true,

    processEnvironments: true,

    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],

    TeX: { equationNumbers: { autoNumber: "AMS" },

         extensions: ["AMSmath.js", "AMSsymbols.js"] }

  }

});


MathJax.Hub.Queue(function() {

    

    

    

    var all = MathJax.Hub.getAllJax(), i;

    for(i = 0; i < all.length; i += 1) {

        all[i].SourceElement().parentNode.className += ' has-jax';

    }

});

</script>


<style>

code.has-jax {

    font: inherit;

    font-size: 100%;

    background: inherit;

    border: inherit;

    color: #515151;

}

</style><meta property="og:url" content="http://localhost:1313/posts/005golangep01_%E5%B9%B6%E5%8F%9101_context/">
  <meta property="og:site_name" content="LTX&#39;s Blog">
  <meta property="og:title" content="GolangEP01_并发之绕不过的context">
  <meta property="og:description" content="引子 今天心血来潮，给自己梳理梳理golang中这个十分重要的东东——context，毕竟也是在面试中考察到，但是反问自己的时候却感觉一点也说不出来什么有价值的东西，所以今天我来一次刨根究底。">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-12-01T12:00:57+08:00">
    <meta property="article:modified_time" content="2024-12-01T12:00:57+08:00">
    <meta property="article:tag" content="Golang">
    <meta property="article:tag" content="源码">
    <meta property="article:tag" content="Context">
      <meta property="og:image" content="http://localhost:1313/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png">
<meta name="twitter:title" content="GolangEP01_并发之绕不过的context">
<meta name="twitter:description" content="引子
今天心血来潮，给自己梳理梳理golang中这个十分重要的东东——context，毕竟也是在面试中考察到，但是反问自己的时候却感觉一点也说不出来什么有价值的东西，所以今天我来一次刨根究底。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "GolangEP01_并发之绕不过的context",
      "item": "http://localhost:1313/posts/005golangep01_%E5%B9%B6%E5%8F%9101_context/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "GolangEP01_并发之绕不过的context",
  "name": "GolangEP01_并发之绕不过的context",
  "description": "引子 今天心血来潮，给自己梳理梳理golang中这个十分重要的东东——context，毕竟也是在面试中考察到，但是反问自己的时候却感觉一点也说不出来什么有价值的东西，所以今天我来一次刨根究底。\n",
  "keywords": [
    "Golang", "源码", "Context"
  ],
  "articleBody": "引子 今天心血来潮，给自己梳理梳理golang中这个十分重要的东东——context，毕竟也是在面试中考察到，但是反问自己的时候却感觉一点也说不出来什么有价值的东西，所以今天我来一次刨根究底。\n源码解析 Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.\n这是来自于官方的最新说明，意味着 context 携带终止期限，取消信号，以及跨API，进程之间通信等信息。\n即context设计的核心目标是\n任务取消机制：跨API和Goroutine的任务取消信号传播机制 超时控制：超时或截止时间控制任务生命周期 数据共享：在不同函数调用间共享元数据 明确了这些，我们进入到源码中。\nContext接口及错误变量 下面这段是来自于Chatgpt的精简版（去掉了长长的英文注释），可以发现Context是一个接口，其中包含了四个方法等待实现。context.Context\n其中第二个比较特殊，返回的是一个channel。\ntype Context interface { Deadline() (deadline time.Time, ok bool) // 返回任务截止时间 Done() \u003c-chan struct{} // 返回取消信号的 channel Err() error // 返回上下文取消的原因 Value(key any) any // 获取上下文中的值 } Done 返回一个仅接收的内部通道，当取消信号发到通道后，此通道得关闭，同时context取消； 关闭通道是唯一一个所有消费者 goroutine 都能够感知到的通道操作 case \u003c-ctx.Done() 如果 Done 通道还未关闭，Err 返回 nil；如果关闭了，就会返回其关闭原因，具体见下面的两个错误类型变量 ctx.Err() 说到这里我们需要补充一下，整个context包中一共有以下这些上下文类型,接下来就会根据这几种类型分别阐述。\nemptyCtx cancleCtx timerCtx valueCtx 以及cancleCtx下的一系列衍生体 定义完了接口，接下来是两个错误类型变量:\nvar Canceled = errors.New(\"context canceled\") var DeadlineExceeded error = deadlineExceededError{} // type deadlineExceededError struct{} func (deadlineExceededError) Error() string { return \"context deadline exceeded\" } func (deadlineExceededError) Timeout() bool { return true } func (deadlineExceededError) Temporary() bool { return true } 根据源码中的注释可以得知\nCanceld是上下文被取消时的错误类型，是一个简单的 error 对象，由 errors.New 创建。 DealineExceeded表示上下文超出截止时间的错误类型，具体实现是 deadlineExceededError，一个实现了 error 接口的结构体，可以为这个错误类型提供更加丰富的信息。 下面三个实现的来自于error的接口表示这是由于超时而引起的错误，暂时性的。 看到这里，我想你已经猜出为什么要定义这两个变量了，正是能够适配 context 接口中的 Err() 方法，至于到底怎么具体实现的 Err() 方法我们后面再说。\nemptyCtx结构 type emptyCtx struct{} func (emptyCtx) Deadline() (deadline time.Time, ok bool) { return } func (emptyCtx) Done() \u003c-chan struct{} { return nil } func (emptyCtx) Err() error { return nil } func (emptyCtx) Value(key any) any { return nil } 显而易见，这是一个空的上下文实现，通常用作上下文链的根节点或者占位符。 注释中也提到，这是一个没有任何状态信息，不包含取消、截止时间、或值存储功能，不能通过取消函数手动取消的上下文。\nBackgroundCtx \u0026 todoCtx结构 type backgroundCtx struct{ emptyCtx } func (backgroundCtx) String() string { return \"context.Background\" } type todoCtx struct{ emptyCtx } func (todoCtx) String() string { return \"context.TODO\" } 这两个接口就用到了emptyCtx,提供了最基础的上下文功能，为开发中的代码提供一个临时的上下文对象，避免为空。\nBackground 通常用于上下文链的根节点。 todo 通常用作占位符 推荐使用 todo，二者在行为上是一致的，但是 todo 的语义更加明确，让人们知道到这是一个待确定的地方；而 background 更常见在顶层的调用上，是根。 对应的还有两个方法来生成二者。\nfunc Background() Context { return backgroundCtx{} } func TODO() Context { return todoCtx{} } cancelCtx:支持显示取消的结构 type cancelCtx struct { Context mu sync.Mutex // protects following fields done atomic.Value // of chan struct{}, created lazily, closed by first cancel call children map[canceler]struct{} // set to nil by the first cancel call err error // set to non-nil by the first cancel call cause error // set to non-nil by the first cancel call } func (c *cancelCtx) Value(key any) any { if key == \u0026cancelCtxKey { return c } return value(c.Context, key) } func (c *cancelCtx) Done() \u003c-chan struct{} { d := c.done.Load() if d != nil { return d.(chan struct{}) } c.mu.Lock() defer c.mu.Unlock() d = c.done.Load() if d == nil { d = make(chan struct{}) c.done.Store(d) } return d.(chan struct{}) } func (c *cancelCtx) Err() error { c.mu.Lock() err := c.err c.mu.Unlock() return err } 哦，原来你小子嵌套了Context祖宗，你是儿子啊！然后你还多定义了什么：\nmu，很常见的保护并发访问 done 存储一个懒加载的通道，上下文被取消时关闭此通道；（这里的atomic.Value先放放） children,存储派生于该上下文的子上下文，形成一个上下文链（取消时通知他们） err，错误，通常用上面那两个错误变量 casuse，错误原因。 后面的这几个就是实现Context接口中的方法\nvalue:如果键是 cancelCtxKey，直接返回 cancelCtx 本身；否则交给父上下文处理 Done:先从 done.Load 获取已有通道，如果有了，直接返回；如果没有，创建一个新通道并存储（注意加锁后又尝试加载了一次，防止其他协程创建了通道）；相同上下文返回唯一通道 这是一种双检查锁的模式 Err:保证线程安全地返回错误状态 接下来是此结构中最重要的 cancel 方法，用于取消当前上下文，并传播取消信号到所有的子上下文，整个流程大致总结如下：\n设置 err 和 cause 表示上下文已经被取消 关闭 Done 通道以通知所有监听者 遍历递归取消所有子上下文（链条） 最后清理资源 // 是否需要将当前上下文从其父上下文的 children 集合中移除，取消的错误信息，取消的原因 func (c *cancelCtx) cancel(removeFromParent bool, err, cause error) { if err == nil { panic(\"context: internal error: missing cancel error\") } if cause == nil { cause = err } // 锁定状态，防止重复取消 c.mu.Lock() if c.err != nil { c.mu.Unlock() return // already canceled } c.err = err c.cause = cause // 检查done通道是否已创建，如果没有就存储一个，否则调用close关闭通道 d, _ := c.done.Load().(chan struct{}) if d == nil { c.done.Store(closedchan) } else { close(d) } // 至此，通知所有子上下文关闭,递归地调用cancel方法 for child := range c.children { // NOTE: acquiring the child's lock while holding parent's lock. child.cancel(false, err, cause) } // 清空子上下文集合 c.children = nil c.mu.Unlock() if removeFromParent { removeChild(c.Context, c) } } CancelFunc函数类型 // A CancelFunc tells an operation to abandon its work. // A CancelFunc does not wait for the work to stop. // A CancelFunc may be called by multiple goroutines simultaneously. // After the first call, subsequent calls to a CancelFunc do nothing. type CancelFunc func() 是一个函数类型，表示一个无参数、无返回值的函数，并发安全，一次性触发（只有第一次调用会有效）。\n之所以这里定义为函数类型，就是为了让其他需要使用到CancelFunc的方法通过闭包来绑定具体的逻辑。稍后我们在一些具体方法中就能看到。\nWithCancel \u0026 WithCancelCause func WithCancel(parent Context) (ctx Context, cancel CancelFunc) { c := withCancel(parent) return c, func() { c.cancel(true, Canceled, nil) } } type CancelCauseFunc func(cause error) func WithCancelCause(parent Context) (ctx Context, cancel CancelCauseFunc) { c := withCancel(parent) return c, func(cause error) { c.cancel(true, Canceled, cause) } } WithCancel 传入父上下文，创建一个取消上下文，返回此上下文和一个取消函数 可以发现正如我们上面所说，利用闭包，直接返回了一个取消函数cancel来触发上下文的取消 WithCancelCause 将WithCancel中的CancelFunc换为CancelCasuseFunc，带有取消原因。 下面的闭包函数中可以传入一个取消原因cause error func withCancel(parent Context) *cancelCtx { if parent == nil { panic(\"cannot create context from nil parent\") } c := \u0026cancelCtx{} c.propagateCancel(parent, c) return c } 这个withCancel就是上面两个方法分别调用的核心方法来创建一个cancelCtx上下文实例。\n先判断父上下文是否为空（上下文链必须有一个根），随后创建一个cancelCtx上下文实例，调用propagateCancel关联父子并监听父上下文的取消事件。\n说到这里可能有些懵逼了，那我们就来看看这个 propagateCancel 是怎么个事！\npropagateCancel 顾名思义，传播，用于将子取消逻辑与父取消逻辑联系起来形成一个链。具体代码逻辑的解释见注释。\n// propagateCancel arranges for child to be canceled when parent is. // It sets the parent context of cancelCtx. func (c *cancelCtx) propagateCancel(parent Context, child canceler) { c.Context = parent // parent作为基础（即上面的嵌套Context） done := parent.Done() // 获取parent的Done通道，记录着取消信号的channel if done == nil { // 如果为空，说明没有取消信号，parent永远不会取消 return // parent is never canceled } select { case \u003c-done: // ? // parent is already canceled child.cancel(false, parent.Err(), Cause(parent)) return default: } // 检查parent类型是否为cancelCtx或派生类型 if p, ok := parentCancelCtx(parent); ok { // parent is a *cancelCtx, or derives from one. p.mu.Lock() if p.err != nil { // 如果错误类型不为空，证明parent已被取消了 // parent has already been canceled child.cancel(false, p.err, p.cause) } else { // 否则将child加入到parent的子集中 if p.children == nil { p.children = make(map[canceler]struct{}) } p.children[child] = struct{}{} } p.mu.Unlock() return } // 如果parent实现了AfterFunc方法，这个之后我们会说，是一种定时回调 if a, ok := parent.(afterFuncer); ok { // parent implements an AfterFunc method. c.mu.Lock() stop := a.AfterFunc(func() { child.cancel(false, parent.Err(), Cause(parent)) }) c.Context = stopCtx{ Context: parent, stop: stop, } c.mu.Unlock() return } // 用于处理无法直接关联的上下文，goroutine同时监听parent和child的Done通道 goroutines.Add(1) go func() { select { case \u003c-parent.Done(): child.cancel(false, parent.Err(), Cause(parent)) case \u003c-child.Done(): } }() } 所以，回到最开始的 withCancel 中，构建了一个取消传播链，可以调用 CancelFunc 来触发取消逻辑，释放资源。\nCause 从Context中提取取消原因(cause)\nfunc Cause(c Context) error { if cc, ok := c.Value(\u0026cancelCtxKey).(*cancelCtx); ok { cc.mu.Lock() defer cc.mu.Unlock() return cc.cause } return c.Err() } afterFuncCtx 在cancelCtx的基础上实现回调。\ntype afterFuncCtx struct { cancelCtx once sync.Once // 确保 f 只被执行一次 f func() // 要在上下文完成时调用的回调函数 } AfterFunc传入回调函数f，并将afterFuncCtx关联到父上下文\nfunc AfterFunc(ctx Context, f func()) (stop func() bool) { a := \u0026afterFuncCtx{ f: f, } // 将 afterFuncCtx 作为子上下文，关联到父上下文 ctx a.cancelCtx.propagateCancel(ctx, a) // 返回的 stop 函数用于停止回调的执行 return func() bool { stopped := false a.once.Do(func() { stopped = true }) if stopped { a.cancel(true, Canceled, nil) } return stopped } } timerCtx 这是cancelCtx的扩展，支持设置截止时间的上下文类型，多了 timer 和 deadline 字段。\ntype timerCtx struct { cancelCtx timer *time.Timer // Under cancelCtx.mu. deadline time.Time } // 返回当前截止时间以及标志位 func (c *timerCtx) Deadline() (deadline time.Time, ok bool) { return c.deadline, true } func (c *timerCtx) String() string { return contextName(c.cancelCtx.Context) + \".WithDeadline(\" + c.deadline.String() + \" [\" + time.Until(c.deadline).String() + \"])\" } // 调用cancelCtx的cancel实现取消，多了定时器 func (c *timerCtx) cancel(removeFromParent bool, err, cause error) { c.cancelCtx.cancel(false, err, cause) if removeFromParent { // Remove this timerCtx from its parent cancelCtx's children. removeChild(c.cancelCtx.Context, c) } c.mu.Lock() if c.timer != nil { c.timer.Stop() c.timer = nil } c.mu.Unlock() } WithTimeout \u0026 WithDeadline 基于超时持续时间创建上下文；基于指定的截止时间创建上下文\nfunc WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) { return WithDeadline(parent, time.Now().Add(timeout)) } func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) { return WithDeadlineCause(parent, d, nil) } 可以发现最终还是调用的是 WithDeadlineCause 这个方法\n1.检查父上下文是否有更早的截止时间 2.创建timerCtx 3.计算剩余时间 4.设置定时器 5.返回上下文和取消函数\nfunc WithDeadlineCause(parent Context, d time.Time, cause error) (Context, CancelFunc) { if parent == nil { panic(\"cannot create context from nil parent\") } if cur, ok := parent.Deadline(); ok \u0026\u0026 cur.Before(d) { // The current deadline is already sooner than the new one. return WithCancel(parent) } c := \u0026timerCtx{ deadline: d, } // 关联到父上下文并计算截止时间的剩余时间 c.cancelCtx.propagateCancel(parent, c) dur := time.Until(d) if dur \u003c= 0 { c.cancel(true, DeadlineExceeded, cause) // deadline has already passed return c, func() { c.cancel(false, Canceled, nil) } } // 设置定时器，到时间后自动取消上下文 c.mu.Lock() defer c.mu.Unlock() if c.err == nil { c.timer = time.AfterFunc(dur, func() { c.cancel(true, DeadlineExceeded, cause) }) } return c, func() { c.cancel(true, Canceled, nil) } } valueCtx 实现键值对存储功能的一种上下文类型,适合携带少量元数据。\ntype valueCtx struct { Context key, val any } Value:如果当前上下文没有匹配的键，则调用 value 函数继续在父上下文中查找。\nvalue:递归辅助方法，用于在上下文链中查找指定key对应的值\nfunc (c *valueCtx) String() string { return contextName(c.Context) + \".WithValue(\" + stringify(c.key) + \", \" + stringify(c.val) + \")\" } func (c *valueCtx) Value(key any) any { if c.key == key { return c.val } return value(c.Context, key) } func value(c Context, key any) any { for { switch ctx := c.(type) { // 如果是valueCtx类型 case *valueCtx: if key == ctx.key { return ctx.val } c = ctx.Context //向父上下文继续找 // 如果是cancelCtx类型 case *cancelCtx: if key == \u0026cancelCtxKey { return c } c = ctx.Context // 如果是withoutCancelCtx类型 case withoutCancelCtx: if key == \u0026cancelCtxKey { // This implements Cause(ctx) == nil // when ctx is created using WithoutCancel. return nil } c = ctx.c // 如果是timerCtx类型 case *timerCtx: if key == \u0026cancelCtxKey { return \u0026ctx.cancelCtx } c = ctx.Context // 如果是backgroundCtx，todoCtx类型即根上下文 case backgroundCtx, todoCtx: return nil default: return c.Value(key) } } } withValue方法 func WithValue(parent Context, key, val any) Context { if parent == nil { panic(\"cannot create context from nil parent\") } if key == nil { panic(\"nil key\") } if !reflectlite.TypeOf(key).Comparable() { panic(\"key is not comparable\") } return \u0026valueCtx{parent, key, val} } 常用的Go Context 类型对比 类型 功能描述 支持取消 支持超时/截止时间 支持键值对存储 emptyCtx 根上下文类型。用于创建 context.Background() 和 context.TODO()，无任何功能。 否 否 否 cancelCtx 支持取消功能，通过 WithCancel 或 WithCancelCause 创建，可以传播取消信号。 是 否 否 timerCtx 基于 cancelCtx，支持取消和超时，通过 WithTimeout 和 WithDeadline 创建。 是 是 否 valueCtx 支持键值对存储，通过 WithValue 创建，通常嵌套在其他类型上下文中使用。 否 否 是 平时是如何使用的 这里举例说明context以及其中的常见方法在代码中是如何使用的。\nWithTimeout\u0026WithDeadline 在这段代码中，context.WithTimeout 起到了控制数据库操作是否超时的作用\nfunc (m MovieModel) Insert(movie *Movie) error { // 插入一条新记录的SQL语句，并返回信息（Postgresql专有) query := ` INSERT INTO movies (title, year, runtime, genres) VALUES ($1, $2, $3, $4) RETURNING id, created_at, version` // 创建一个代表着占位符的movie中的属性切片 args := []interface{}{movie.Title, movie.Year, movie.Runtime, pq.Array(movie.Genres)} // Create a context with a 3-second timeout // 如果数据库操作在3s内没有完成，操作自动取消，返回超时错误 ctx, cancle := context.WithTimeout(context.Background(), 3*time.Second) defer cancle() // 使用QueryRowContext方法执行,利用传入的ctx进行SQL查询，并使用Scan方法将返回值注入到movie的三个属性中 return m.DB.QueryRowContext(ctx, query, args...).Scan(\u0026movie.ID, \u0026movie.CreatedAt, \u0026movie.Version) } 总结 Golang中经常使用 Context，以上四种 Context 类型各有其作用，通常利用其自带的函数例如WithTimeout(),Background()来进行控制操作。\n其中值得注意的是 cancleCtx 的取消机制中的传播链，存在回调机制，值得我多去思考。\n这里是LTX，感谢您阅读这篇博客，人生海海，和自己对话，像只蝴蝶纵横四海。\n",
  "wordCount" : "4803",
  "inLanguage": "zh",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2024-12-01T12:00:57+08:00",
  "dateModified": "2024-12-01T12:00:57+08:00",
  "author":{
    "@type": "Person",
    "name": "LTX"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/005golangep01_%E5%B9%B6%E5%8F%9101_context/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "LTX's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.png"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="LTX&#39;s Blog (Alt + H)">LTX&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="LTX&#39;s Blog">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/" title="后花园">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      GolangEP01_并发之绕不过的context
    </h1>
    <div class="post-meta"><span title='2024-12-01 12:00:57 +0800 CST'>十二月 1, 2024</span>&nbsp;·&nbsp;10 分钟&nbsp;·&nbsp;LTX

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%bc%95%e5%ad%90" aria-label="引子">引子</a></li>
                <li>
                    <a href="#%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90" aria-label="源码解析">源码解析</a><ul>
                        
                <li>
                    <a href="#context%e6%8e%a5%e5%8f%a3%e5%8f%8a%e9%94%99%e8%af%af%e5%8f%98%e9%87%8f" aria-label="Context接口及错误变量">Context接口及错误变量</a></li>
                <li>
                    <a href="#emptyctx%e7%bb%93%e6%9e%84" aria-label="emptyCtx结构">emptyCtx结构</a><ul>
                        
                <li>
                    <a href="#backgroundctx--todoctx%e7%bb%93%e6%9e%84" aria-label="BackgroundCtx &amp; todoCtx结构">BackgroundCtx &amp; todoCtx结构</a></li></ul>
                </li>
                <li>
                    <a href="#cancelctx%e6%94%af%e6%8c%81%e6%98%be%e7%a4%ba%e5%8f%96%e6%b6%88%e7%9a%84%e7%bb%93%e6%9e%84" aria-label="cancelCtx:支持显示取消的结构">cancelCtx:支持显示取消的结构</a><ul>
                        
                <li>
                    <a href="#cancelfunc%e5%87%bd%e6%95%b0%e7%b1%bb%e5%9e%8b" aria-label="CancelFunc函数类型">CancelFunc函数类型</a></li>
                <li>
                    <a href="#withcancel--withcancelcause" aria-label="WithCancel &amp; WithCancelCause">WithCancel &amp; WithCancelCause</a></li>
                <li>
                    <a href="#propagatecancel" aria-label="propagateCancel">propagateCancel</a></li>
                <li>
                    <a href="#cause" aria-label="Cause">Cause</a></li>
                <li>
                    <a href="#afterfuncctx" aria-label="afterFuncCtx">afterFuncCtx</a></li></ul>
                </li>
                <li>
                    <a href="#timerctx" aria-label="timerCtx">timerCtx</a><ul>
                        
                <li>
                    <a href="#withtimeout--withdeadline" aria-label="WithTimeout &amp; WithDeadline">WithTimeout &amp; WithDeadline</a></li></ul>
                </li>
                <li>
                    <a href="#valuectx" aria-label="valueCtx">valueCtx</a><ul>
                        
                <li>
                    <a href="#withvalue%e6%96%b9%e6%b3%95" aria-label="withValue方法">withValue方法</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e7%9a%84go-context-%e7%b1%bb%e5%9e%8b%e5%af%b9%e6%af%94" aria-label="常用的Go Context 类型对比">常用的Go Context 类型对比</a></li>
                <li>
                    <a href="#%e5%b9%b3%e6%97%b6%e6%98%af%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8%e7%9a%84" aria-label="平时是如何使用的">平时是如何使用的</a><ul>
                        
                <li>
                    <a href="#withtimeoutwithdeadline" aria-label="WithTimeout&amp;WithDeadline">WithTimeout&amp;WithDeadline</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="引子">引子<a hidden class="anchor" aria-hidden="true" href="#引子">#</a></h2>
<p>今天心血来潮，给自己梳理梳理golang中这个十分重要的东东——context，毕竟也是在面试中考察到，但是反问自己的时候却感觉一点也说不出来什么有价值的东西，所以今天我来一次刨根究底。</p>
<p><img loading="lazy" src="/img/jb/coffee.webp"></p>
<h2 id="源码解析">源码解析<a hidden class="anchor" aria-hidden="true" href="#源码解析">#</a></h2>
<blockquote>
<p>Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.</p></blockquote>
<p>这是来自于官方的最新说明，意味着 context <strong>携带终止期限，取消信号，以及跨API，进程之间通信</strong>等信息。</p>
<p>即context设计的核心目标是</p>
<ul>
<li>任务取消机制：跨API和Goroutine的任务取消信号传播机制</li>
<li>超时控制：超时或截止时间控制任务生命周期</li>
<li>数据共享：在不同函数调用间共享元数据</li>
</ul>
<p>明确了这些，我们进入到<a href="https://cs.opensource.google/go/go/&#43;/refs/tags/go1.23.3:src/context/context.go;l=227">源码</a>中。</p>
<h3 id="context接口及错误变量">Context接口及错误变量<a hidden class="anchor" aria-hidden="true" href="#context接口及错误变量">#</a></h3>
<p>下面这段是来自于Chatgpt的精简版（去掉了长长的英文注释），可以发现Context是一个接口，其中包含了四个方法等待实现。<code>context.Context</code></p>
<p>其中第二个比较特殊，返回的是一个channel。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Context</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Deadline</span><span class="p">()</span> <span class="p">(</span><span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="c1">// 返回任务截止时间</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Done</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>                  <span class="c1">// 返回取消信号的 channel</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Err</span><span class="p">()</span> <span class="kt">error</span>                             <span class="c1">// 返回上下文取消的原因</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Value</span><span class="p">(</span><span class="nx">key</span> <span class="kt">any</span><span class="p">)</span> <span class="kt">any</span>                      <span class="c1">// 获取上下文中的值</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>Done 返回一个仅接收的<strong>内部通道</strong>，当取消信号发到通道后，此通道得关闭，同时context取消；
<ul>
<li><em>关闭通道是唯一一个所有消费者 goroutine 都能够感知到的通道操作</em></li>
<li><code>case &lt;-ctx.Done()</code></li>
</ul>
</li>
<li>如果 Done 通道还未关闭，Err 返回 nil；如果关闭了，就会返回其关闭原因，具体见下面的两个错误类型变量
<ul>
<li><code>ctx.Err()</code></li>
</ul>
</li>
</ul>
<p>说到这里我们需要补充一下，整个context包中一共有以下这些上下文类型,接下来就会根据这几种类型分别阐述。</p>
<ul>
<li>emptyCtx</li>
<li>cancleCtx</li>
<li>timerCtx</li>
<li>valueCtx</li>
<li>以及cancleCtx下的一系列衍生体</li>
</ul>
<p>定义完了接口，接下来是两个错误类型变量:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">Canceled</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;context canceled&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">DeadlineExceeded</span> <span class="kt">error</span> <span class="p">=</span> <span class="nx">deadlineExceededError</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">deadlineExceededError</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">deadlineExceededError</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span>   <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;context deadline exceeded&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">deadlineExceededError</span><span class="p">)</span> <span class="nf">Timeout</span><span class="p">()</span> <span class="kt">bool</span>   <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">deadlineExceededError</span><span class="p">)</span> <span class="nf">Temporary</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">}</span>
</span></span></code></pre></div><p>根据源码中的注释可以得知</p>
<ul>
<li>Canceld是<strong>上下文被取消时</strong>的错误类型，是一个简单的 error 对象，由 errors.New 创建。</li>
<li>DealineExceeded表示<strong>上下文超出截止时间</strong>的错误类型，具体实现是 deadlineExceededError，一个实现了 error 接口的结构体，可以为这个错误类型提供更加丰富的信息。</li>
<li>下面三个实现的来自于error的接口表示这是由于超时而引起的错误，暂时性的。</li>
</ul>
<p>看到这里，我想你已经猜出为什么要定义这两个变量了，正是能够适配 context 接口中的 Err() 方法，至于到底怎么具体实现的 Err() 方法我们后面再说。</p>
<h3 id="emptyctx结构">emptyCtx结构<a hidden class="anchor" aria-hidden="true" href="#emptyctx结构">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">emptyCtx</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">emptyCtx</span><span class="p">)</span> <span class="nf">Deadline</span><span class="p">()</span> <span class="p">(</span><span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">emptyCtx</span><span class="p">)</span> <span class="nf">Done</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">emptyCtx</span><span class="p">)</span> <span class="nf">Err</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">emptyCtx</span><span class="p">)</span> <span class="nf">Value</span><span class="p">(</span><span class="nx">key</span> <span class="kt">any</span><span class="p">)</span> <span class="kt">any</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>显而易见，这是一个空的上下文实现，通常用作上下文链的根节点或者占位符。
注释中也提到，<strong>这是一个没有任何状态信息，不包含取消、截止时间、或值存储功能，不能通过取消函数手动取消的上下文。</strong></p>
<h4 id="backgroundctx--todoctx结构">BackgroundCtx &amp; todoCtx结构<a hidden class="anchor" aria-hidden="true" href="#backgroundctx--todoctx结构">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">backgroundCtx</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">emptyCtx</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">backgroundCtx</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="s">&#34;context.Background&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">todoCtx</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">emptyCtx</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">todoCtx</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="s">&#34;context.TODO&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这两个接口就用到了emptyCtx,提供了最基础的上下文功能，为开发中的代码提供一个临时的上下文对象，避免为空。</p>
<ul>
<li>Background 通常用于上下文链的<strong>根节点</strong>。</li>
<li>todo 通常用作占位符</li>
<li>推荐使用 todo，二者在行为上是一致的，但是 todo 的语义更加明确，让人们知道到这是一个待确定的地方；而 background 更常见在顶层的调用上，是根。</li>
</ul>
<p>对应的还有两个方法来生成二者。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Background</span><span class="p">()</span> <span class="nx">Context</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">backgroundCtx</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">TODO</span><span class="p">()</span> <span class="nx">Context</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">todoCtx</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="cancelctx支持显示取消的结构">cancelCtx:支持显示取消的结构<a hidden class="anchor" aria-hidden="true" href="#cancelctx支持显示取消的结构">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">cancelCtx</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Context</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">mu</span>       <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>            <span class="c1">// protects following fields</span>
</span></span><span class="line"><span class="cl">	<span class="nx">done</span>     <span class="nx">atomic</span><span class="p">.</span><span class="nx">Value</span>          <span class="c1">// of chan struct{}, created lazily, closed by first cancel call</span>
</span></span><span class="line"><span class="cl">	<span class="nx">children</span> <span class="kd">map</span><span class="p">[</span><span class="nx">canceler</span><span class="p">]</span><span class="kd">struct</span><span class="p">{}</span> <span class="c1">// set to nil by the first cancel call</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span>      <span class="kt">error</span>                 <span class="c1">// set to non-nil by the first cancel call</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cause</span>    <span class="kt">error</span>                 <span class="c1">// set to non-nil by the first cancel call</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cancelCtx</span><span class="p">)</span> <span class="nf">Value</span><span class="p">(</span><span class="nx">key</span> <span class="kt">any</span><span class="p">)</span> <span class="kt">any</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">key</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">cancelCtxKey</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">c</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">value</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cancelCtx</span><span class="p">)</span> <span class="nf">Done</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">Load</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">d</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">d</span><span class="p">.(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">Load</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">d</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">d</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">d</span><span class="p">.(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cancelCtx</span><span class="p">)</span> <span class="nf">Err</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>哦，原来你小子嵌套了Context祖宗，你是儿子啊！然后你还多定义了什么：</p>
<ul>
<li>mu，很常见的保护并发访问</li>
<li>done 存储一个<strong>懒加载的通道</strong>，上下文被取消时关闭此通道；（这里的atomic.Value先放放）</li>
<li>children,存储派生于该上下文的子上下文，形成一个<strong>上下文链</strong>（取消时通知他们）</li>
<li>err，错误，通常用上面那两个错误变量</li>
<li>casuse，错误原因。</li>
</ul>
<p>后面的这几个就是实现Context接口中的方法</p>
<ul>
<li>value:如果键是 cancelCtxKey，直接返回 cancelCtx 本身；否则交给父上下文处理</li>
<li>Done:先从 done.Load 获取已有通道，如果有了，直接返回；如果没有，创建一个新通道并存储（注意加锁后又尝试加载了一次，防止其他协程创建了通道）；<strong>相同上下文返回唯一通道</strong>
<ul>
<li>这是一种双检查锁的模式</li>
</ul>
</li>
<li>Err:保证线程安全地返回错误状态</li>
</ul>
<p>接下来是此结构中最重要的 cancel 方法，用于<strong>取消当前上下文，并传播取消信号到所有的子上下文</strong>，整个流程大致总结如下：</p>
<ul>
<li>设置 err 和 cause 表示上下文已经被取消</li>
<li>关闭 Done 通道以通知所有监听者</li>
<li>遍历递归取消所有子上下文（链条）</li>
<li>最后清理资源</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 是否需要将当前上下文从其父上下文的 children 集合中移除，取消的错误信息，取消的原因</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cancelCtx</span><span class="p">)</span> <span class="nf">cancel</span><span class="p">(</span><span class="nx">removeFromParent</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">cause</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;context: internal error: missing cancel error&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">cause</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">cause</span> <span class="p">=</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 锁定状态，防止重复取消</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="c1">// already canceled</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">cause</span> <span class="p">=</span> <span class="nx">cause</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 检查done通道是否已创建，如果没有就存储一个，否则调用close关闭通道</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">d</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">closedchan</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">close</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 至此，通知所有子上下文关闭,递归地调用cancel方法</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">child</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">children</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// NOTE: acquiring the child&#39;s lock while holding parent&#39;s lock.</span>
</span></span><span class="line"><span class="cl">		<span class="nx">child</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">cause</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 清空子上下文集合</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">children</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">removeFromParent</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">removeChild</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="cancelfunc函数类型">CancelFunc函数类型<a hidden class="anchor" aria-hidden="true" href="#cancelfunc函数类型">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// A CancelFunc tells an operation to abandon its work.</span>
</span></span><span class="line"><span class="cl"><span class="c1">// A CancelFunc does not wait for the work to stop.</span>
</span></span><span class="line"><span class="cl"><span class="c1">// A CancelFunc may be called by multiple goroutines simultaneously.</span>
</span></span><span class="line"><span class="cl"><span class="c1">// After the first call, subsequent calls to a CancelFunc do nothing.</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">CancelFunc</span> <span class="kd">func</span><span class="p">()</span>
</span></span></code></pre></div><p>是一个函数类型，表示一个无参数、无返回值的函数，并发安全，一次性触发（只有第一次调用会有效）。</p>
<p>之所以这里定义为函数类型，就是为了让其他需要使用到CancelFunc的方法通过<strong>闭包</strong>来绑定具体的逻辑。稍后我们在一些具体方法中就能看到。</p>
<h4 id="withcancel--withcancelcause">WithCancel &amp; WithCancelCause<a hidden class="anchor" aria-hidden="true" href="#withcancel--withcancelcause">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">WithCancel</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">ctx</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">cancel</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span> <span class="o">:=</span> <span class="nf">withCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">CancelCauseFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">cause</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">WithCancelCause</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">ctx</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">cancel</span> <span class="nx">CancelCauseFunc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span> <span class="o">:=</span> <span class="nf">withCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">cause</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">,</span> <span class="nx">cause</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol>
<li>WithCancel</li>
</ol>
<ul>
<li>传入父上下文，创建一个取消上下文，返回此上下文和一个取消函数</li>
<li>可以发现正如我们上面所说，利用闭包，直接返回了一个取消函数cancel来触发上下文的取消</li>
</ul>
<ol start="2">
<li>WithCancelCause</li>
</ol>
<ul>
<li>将WithCancel中的CancelFunc换为CancelCasuseFunc，带有取消原因。</li>
<li>下面的闭包函数中可以传入一个取消原因<code>cause error</code></li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">withCancel</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">)</span> <span class="o">*</span><span class="nx">cancelCtx</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">parent</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;cannot create context from nil parent&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">cancelCtx</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">propagateCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">c</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这个withCancel就是上面两个方法分别调用的核心方法来创建一个cancelCtx上下文实例。</p>
<p>先判断父上下文是否为空（上下文链必须有一个根），<strong>随后创建一个cancelCtx上下文实例，调用propagateCancel关联父子并监听父上下文的取消事件</strong>。</p>
<p>说到这里可能有些懵逼了，那我们就来看看这个 propagateCancel 是怎么个事！</p>
<p><img loading="lazy" src="/img/ys/ye.webp"></p>
<h4 id="propagatecancel">propagateCancel<a hidden class="anchor" aria-hidden="true" href="#propagatecancel">#</a></h4>
<p>顾名思义，传播，用于将<strong>子取消逻辑与父取消逻辑联系起来形成一个链</strong>。具体代码逻辑的解释见注释。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// propagateCancel arranges for child to be canceled when parent is.</span>
</span></span><span class="line"><span class="cl"><span class="c1">// It sets the parent context of cancelCtx.</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cancelCtx</span><span class="p">)</span> <span class="nf">propagateCancel</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">child</span> <span class="nx">canceler</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">Context</span> <span class="p">=</span> <span class="nx">parent</span> <span class="c1">// parent作为基础（即上面的嵌套Context）</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">done</span> <span class="o">:=</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span> <span class="c1">// 获取parent的Done通道，记录着取消信号的channel</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">done</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// 如果为空，说明没有取消信号，parent永远不会取消</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="c1">// parent is never canceled</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span> <span class="c1">// ?</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// parent is already canceled</span>
</span></span><span class="line"><span class="cl">		<span class="nx">child</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">Err</span><span class="p">(),</span> <span class="nf">Cause</span><span class="p">(</span><span class="nx">parent</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 检查parent类型是否为cancelCtx或派生类型</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">parentCancelCtx</span><span class="p">(</span><span class="nx">parent</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// parent is a *cancelCtx, or derives from one.</span>
</span></span><span class="line"><span class="cl">		<span class="nx">p</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// 如果错误类型不为空，证明parent已被取消了</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// parent has already been canceled</span>
</span></span><span class="line"><span class="cl">			<span class="nx">child</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">err</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">cause</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 否则将child加入到parent的子集中</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">children</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">p</span><span class="p">.</span><span class="nx">children</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">canceler</span><span class="p">]</span><span class="kd">struct</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">p</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">child</span><span class="p">]</span> <span class="p">=</span> <span class="kd">struct</span><span class="p">{}{}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">p</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果parent实现了AfterFunc方法，这个之后我们会说，是一种定时回调</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">parent</span><span class="p">.(</span><span class="nx">afterFuncer</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// parent implements an AfterFunc method.</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">stop</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">AfterFunc</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">child</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">Err</span><span class="p">(),</span> <span class="nf">Cause</span><span class="p">(</span><span class="nx">parent</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="p">})</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">Context</span> <span class="p">=</span> <span class="nx">stopCtx</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">Context</span><span class="p">:</span> <span class="nx">parent</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">stop</span><span class="p">:</span>    <span class="nx">stop</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 用于处理无法直接关联的上下文，goroutine同时监听parent和child的Done通道</span>
</span></span><span class="line"><span class="cl">	<span class="nx">goroutines</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">parent</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">			<span class="nx">child</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">Err</span><span class="p">(),</span> <span class="nf">Cause</span><span class="p">(</span><span class="nx">parent</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">child</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>所以，回到最开始的 withCancel 中，构建了一个取消传播链，可以调用 CancelFunc 来触发取消逻辑，释放资源。</p>
<h4 id="cause">Cause<a hidden class="anchor" aria-hidden="true" href="#cause">#</a></h4>
<p>从Context中提取取消原因(cause)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Cause</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">cc</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">cancelCtxKey</span><span class="p">).(</span><span class="o">*</span><span class="nx">cancelCtx</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">defer</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">cause</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Err</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="afterfuncctx">afterFuncCtx<a hidden class="anchor" aria-hidden="true" href="#afterfuncctx">#</a></h4>
<p>在cancelCtx的基础上实现回调。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">afterFuncCtx</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cancelCtx</span>
</span></span><span class="line"><span class="cl">	<span class="nx">once</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span> <span class="c1">// 确保 f 只被执行一次</span>
</span></span><span class="line"><span class="cl">	<span class="nx">f</span>    <span class="kd">func</span><span class="p">()</span>    <span class="c1">// 要在上下文完成时调用的回调函数</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>AfterFunc传入<strong>回调函数f</strong>，并将afterFuncCtx关联到父上下文</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">AfterFunc</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">(</span><span class="nx">stop</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">a</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">afterFuncCtx</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">f</span><span class="p">:</span> <span class="nx">f</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 将 afterFuncCtx 作为子上下文，关联到父上下文 ctx</span>
</span></span><span class="line"><span class="cl">	<span class="nx">a</span><span class="p">.</span><span class="nx">cancelCtx</span><span class="p">.</span><span class="nf">propagateCancel</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 返回的 stop 函数用于停止回调的执行</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">stopped</span> <span class="o">:=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="nx">a</span><span class="p">.</span><span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">stopped</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">		<span class="p">})</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">stopped</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">a</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">stopped</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="timerctx">timerCtx<a hidden class="anchor" aria-hidden="true" href="#timerctx">#</a></h3>
<p>这是cancelCtx的扩展，支持设置截止时间的上下文类型，多了 timer 和 deadline 字段。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">timerCtx</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cancelCtx</span>
</span></span><span class="line"><span class="cl">	<span class="nx">timer</span> <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Timer</span> <span class="c1">// Under cancelCtx.mu.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 返回当前截止时间以及标志位</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">timerCtx</span><span class="p">)</span> <span class="nf">Deadline</span><span class="p">()</span> <span class="p">(</span><span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">deadline</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">timerCtx</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">contextName</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">cancelCtx</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;.WithDeadline(&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">deadline</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34; [&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">		<span class="nx">time</span><span class="p">.</span><span class="nf">Until</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">deadline</span><span class="p">).</span><span class="nf">String</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34;])&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 调用cancelCtx的cancel实现取消，多了定时器</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">timerCtx</span><span class="p">)</span> <span class="nf">cancel</span><span class="p">(</span><span class="nx">removeFromParent</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">cause</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">cancelCtx</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">cause</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">removeFromParent</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Remove this timerCtx from its parent cancelCtx&#39;s children.</span>
</span></span><span class="line"><span class="cl">		<span class="nf">removeChild</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">cancelCtx</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">timer</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">timer</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="withtimeout--withdeadline">WithTimeout &amp; WithDeadline<a hidden class="anchor" aria-hidden="true" href="#withtimeout--withdeadline">#</a></h4>
<p>基于超时持续时间创建上下文；基于指定的截止时间创建上下文</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">timeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">(</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">WithDeadline</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">timeout</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">WithDeadline</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">d</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">(</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">WithDeadlineCause</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">d</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>可以发现最终还是调用的是 <strong>WithDeadlineCause</strong> 这个方法</p>
<p>1.检查父上下文是否有更早的截止时间
2.创建timerCtx
3.计算剩余时间
4.设置定时器
5.返回上下文和取消函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">WithDeadlineCause</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">d</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">cause</span> <span class="kt">error</span><span class="p">)</span> <span class="p">(</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">parent</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;cannot create context from nil parent&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">cur</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">Deadline</span><span class="p">();</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">cur</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// The current deadline is already sooner than the new one.</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nf">WithCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">timerCtx</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">deadline</span><span class="p">:</span> <span class="nx">d</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 关联到父上下文并计算截止时间的剩余时间</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">cancelCtx</span><span class="p">.</span><span class="nf">propagateCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">dur</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Until</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">dur</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">DeadlineExceeded</span><span class="p">,</span> <span class="nx">cause</span><span class="p">)</span> <span class="c1">// deadline has already passed</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置定时器，到时间后自动取消上下文</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">timer</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">AfterFunc</span><span class="p">(</span><span class="nx">dur</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">DeadlineExceeded</span><span class="p">,</span> <span class="nx">cause</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="valuectx">valueCtx<a hidden class="anchor" aria-hidden="true" href="#valuectx">#</a></h3>
<p>实现<strong>键值对存储功能</strong>的一种上下文类型,适合携带少量元数据。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">valueCtx</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Context</span>
</span></span><span class="line"><span class="cl">	<span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">any</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Value:如果当前上下文没有匹配的键，则调用 value 函数继续在父上下文中查找。</p>
<p>value:递归辅助方法，用于在上下文链中查找指定key对应的值</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">valueCtx</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">contextName</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;.WithValue(&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">		<span class="nf">stringify</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;, &#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">		<span class="nf">stringify</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;)&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">valueCtx</span><span class="p">)</span> <span class="nf">Value</span><span class="p">(</span><span class="nx">key</span> <span class="kt">any</span><span class="p">)</span> <span class="kt">any</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">key</span> <span class="o">==</span> <span class="nx">key</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">val</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">value</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">value</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">any</span><span class="p">)</span> <span class="kt">any</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">switch</span> <span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果是valueCtx类型</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="o">*</span><span class="nx">valueCtx</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">key</span> <span class="o">==</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">key</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">val</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span> <span class="p">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">Context</span> <span class="c1">//向父上下文继续找</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果是cancelCtx类型</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="o">*</span><span class="nx">cancelCtx</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">key</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">cancelCtxKey</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="nx">c</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span> <span class="p">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">Context</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果是withoutCancelCtx类型</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">withoutCancelCtx</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">key</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">cancelCtxKey</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// This implements Cause(ctx) == nil</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// when ctx is created using WithoutCancel.</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span> <span class="p">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">c</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果是timerCtx类型</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="o">*</span><span class="nx">timerCtx</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">key</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">cancelCtxKey</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="o">&amp;</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">cancelCtx</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span> <span class="p">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">Context</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果是backgroundCtx，todoCtx类型即根上下文</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">backgroundCtx</span><span class="p">,</span> <span class="nx">todoCtx</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="withvalue方法">withValue方法<a hidden class="anchor" aria-hidden="true" href="#withvalue方法">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">WithValue</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">any</span><span class="p">)</span> <span class="nx">Context</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">parent</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;cannot create context from nil parent&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">key</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;nil key&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">reflectlite</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">key</span><span class="p">).</span><span class="nf">Comparable</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;key is not comparable&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">valueCtx</span><span class="p">{</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="常用的go-context-类型对比">常用的Go Context 类型对比<a hidden class="anchor" aria-hidden="true" href="#常用的go-context-类型对比">#</a></h2>
<table>
  <thead>
      <tr>
          <th><strong>类型</strong></th>
          <th><strong>功能描述</strong></th>
          <th><strong>支持取消</strong></th>
          <th><strong>支持超时/截止时间</strong></th>
          <th><strong>支持键值对存储</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong><code>emptyCtx</code></strong></td>
          <td>根上下文类型。用于创建 <code>context.Background()</code> 和 <code>context.TODO()</code>，无任何功能。</td>
          <td>否</td>
          <td>否</td>
          <td>否</td>
      </tr>
      <tr>
          <td><strong><code>cancelCtx</code></strong></td>
          <td>支持取消功能，通过 <code>WithCancel</code> 或 <code>WithCancelCause</code> 创建，可以传播取消信号。</td>
          <td>是</td>
          <td>否</td>
          <td>否</td>
      </tr>
      <tr>
          <td><strong><code>timerCtx</code></strong></td>
          <td>基于 <code>cancelCtx</code>，支持取消和超时，通过 <code>WithTimeout</code> 和 <code>WithDeadline</code> 创建。</td>
          <td>是</td>
          <td>是</td>
          <td>否</td>
      </tr>
      <tr>
          <td><strong><code>valueCtx</code></strong></td>
          <td>支持键值对存储，通过 <code>WithValue</code> 创建，通常嵌套在其他类型上下文中使用。</td>
          <td>否</td>
          <td>否</td>
          <td>是</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="平时是如何使用的">平时是如何使用的<a hidden class="anchor" aria-hidden="true" href="#平时是如何使用的">#</a></h2>
<p>这里举例说明context以及其中的常见方法在代码中是如何使用的。</p>
<h3 id="withtimeoutwithdeadline">WithTimeout&amp;WithDeadline<a hidden class="anchor" aria-hidden="true" href="#withtimeoutwithdeadline">#</a></h3>
<p>在这段代码中，<code>context.WithTimeout</code> 起到了控制数据库操作是否超时的作用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">MovieModel</span><span class="p">)</span> <span class="nf">Insert</span><span class="p">(</span><span class="nx">movie</span> <span class="o">*</span><span class="nx">Movie</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 插入一条新记录的SQL语句，并返回信息（Postgresql专有)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">query</span> <span class="o">:=</span> <span class="s">`
</span></span></span><span class="line"><span class="cl"><span class="s">			INSERT INTO movies (title, year, runtime, genres)
</span></span></span><span class="line"><span class="cl"><span class="s">			VALUES ($1, $2, $3, $4)
</span></span></span><span class="line"><span class="cl"><span class="s">			RETURNING id, created_at, version`</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个代表着占位符的movie中的属性切片</span>
</span></span><span class="line"><span class="cl">	<span class="nx">args</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">interface</span><span class="p">{}{</span><span class="nx">movie</span><span class="p">.</span><span class="nx">Title</span><span class="p">,</span> <span class="nx">movie</span><span class="p">.</span><span class="nx">Year</span><span class="p">,</span> <span class="nx">movie</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">,</span> <span class="nx">pq</span><span class="p">.</span><span class="nf">Array</span><span class="p">(</span><span class="nx">movie</span><span class="p">.</span><span class="nx">Genres</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Create a context with a 3-second timeout</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 如果数据库操作在3s内没有完成，操作自动取消，返回超时错误</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancle</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">3</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancle</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 使用QueryRowContext方法执行,利用传入的ctx进行SQL查询，并使用Scan方法将返回值注入到movie的三个属性中</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nx">DB</span><span class="p">.</span><span class="nf">QueryRowContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">query</span><span class="p">,</span> <span class="nx">args</span><span class="o">...</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">movie</span><span class="p">.</span><span class="nx">ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">movie</span><span class="p">.</span><span class="nx">CreatedAt</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">movie</span><span class="p">.</span><span class="nx">Version</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<p>Golang中经常使用 Context，以上四种 Context 类型各有其作用，通常利用其自带的函数例如<code>WithTimeout()</code>,<code>Background()</code>来进行控制操作。</p>
<p>其中值得注意的是 cancleCtx 的取消机制中的传播链，存在回调机制，值得我多去思考。</p>
<p><strong>这里是LTX，感谢您阅读这篇博客，人生海海，和自己对话，像只蝴蝶纵横四海。</strong></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/golang/">Golang</a></li>
      <li><a href="http://localhost:1313/tags/%E6%BA%90%E7%A0%81/">源码</a></li>
      <li><a href="http://localhost:1313/tags/context/">Context</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/006golanggorm%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81/">
    <span class="title">« 上一页</span>
    <br>
    <span>Golang源码小试牛刀:Gorm框架源码小探01</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/004risc-v_deployment/">
    <span class="title">下一页 »</span>
    <br>
    <span>玩转RISCV开发板02-配置好容器化环境</span>
  </a>
</nav>

  </footer><div id="tw-comment"></div>

<script>

    

    const getStoredTheme = () => localStorage.getItem("pref-theme") === "light" ? "light" : "dark";

    const setGiscusTheme = () => {

        const sendMessage = (message) => {

            const iframe = document.querySelector('iframe.giscus-frame');

            if (iframe) {

                iframe.contentWindow.postMessage({giscus: message}, 'https://giscus.app');

            }

        }

        sendMessage({setConfig: {theme: getStoredTheme()}})

    }


    document.addEventListener("DOMContentLoaded", () => {

        const giscusAttributes = {

            "src": "https://giscus.app/client.js",

            "data-repo": "LTXWorld\/LTXWorld.github.io",

            "data-repo-id": "R_kgDONODUuA",

            "data-category": "Announcements",

            "data-category-id": "DIC_kwDONODUuM4CkMUw",

            "data-mapping": "pathname",

            "data-strict": "0",

            "data-reactions-enabled": "1",

            "data-emit-metadata": "0",

            "data-input-position": "bottom",

            "data-theme": getStoredTheme(),

            "data-lang": "zh-CN",

            "data-loading": "lazy",

            "crossorigin": "anonymous",

        };


        

        const giscusScript = document.createElement("script");

        Object.entries(giscusAttributes).forEach(

                ([key, value]) => giscusScript.setAttribute(key, value));

        document.querySelector("#tw-comment").appendChild(giscusScript);


        

        const themeSwitcher = document.querySelector("#theme-toggle");

        if (themeSwitcher) {

            themeSwitcher.addEventListener("click", setGiscusTheme);

        }

        const themeFloatSwitcher = document.querySelector("#theme-toggle-float");

        if (themeFloatSwitcher) {

            themeFloatSwitcher.addEventListener("click", setGiscusTheme);

        }

    });

</script>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://LTXWorld.github.io/">©2025 LTX&rsquo;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
