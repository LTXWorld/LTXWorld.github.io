<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>GolangEP01_并发之绕不过的context | LTX's Blog</title>
<meta name=keywords content="Golang,源码,Context"><meta name=description content="引子
今天心血来潮，给自己梳理梳理golang中这个十分重要的东东——context，毕竟也是在面试中考察到，但是反问自己的时候却感觉一点也说不出来什么有价值的东西，所以今天我来一次刨根究底。"><meta name=author content="LTX"><link rel=canonical href=https://LTXWorld.github.io/posts/005golangep01_%E5%B9%B6%E5%8F%9101_context/><link crossorigin=anonymous href=/assets/css/stylesheet.5f0ddd8622920919e414fdd8cc3f59e09ea98fa129491973ab7d95306b6604d0.css integrity="sha256-Xw3dhiKSCRnkFP3YzD9Z4J6pj6EpSRlzq32VMGtmBNA=" rel="preload stylesheet" as=style><link rel=icon href=https://LTXWorld.github.io/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://LTXWorld.github.io/favicon.png><link rel=icon type=image/png sizes=32x32 href=https://LTXWorld.github.io/favicon.png><link rel=apple-touch-icon href=https://LTXWorld.github.io/favicon.png><link rel=mask-icon href=https://LTXWorld.github.io/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://LTXWorld.github.io/posts/005golangep01_%E5%B9%B6%E5%8F%9101_context/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><meta property="og:url" content="https://LTXWorld.github.io/posts/005golangep01_%E5%B9%B6%E5%8F%9101_context/"><meta property="og:site_name" content="LTX's Blog"><meta property="og:title" content="GolangEP01_并发之绕不过的context"><meta property="og:description" content="引子 今天心血来潮，给自己梳理梳理golang中这个十分重要的东东——context，毕竟也是在面试中考察到，但是反问自己的时候却感觉一点也说不出来什么有价值的东西，所以今天我来一次刨根究底。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-01T12:00:57+08:00"><meta property="article:modified_time" content="2024-12-01T12:00:57+08:00"><meta property="article:tag" content="Golang"><meta property="article:tag" content="源码"><meta property="article:tag" content="Context"><meta property="og:image" content="https://LTXWorld.github.io/images/papermod-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://LTXWorld.github.io/images/papermod-cover.png"><meta name=twitter:title content="GolangEP01_并发之绕不过的context"><meta name=twitter:description content="引子
今天心血来潮，给自己梳理梳理golang中这个十分重要的东东——context，毕竟也是在面试中考察到，但是反问自己的时候却感觉一点也说不出来什么有价值的东西，所以今天我来一次刨根究底。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://LTXWorld.github.io/posts/"},{"@type":"ListItem","position":2,"name":"GolangEP01_并发之绕不过的context","item":"https://LTXWorld.github.io/posts/005golangep01_%E5%B9%B6%E5%8F%9101_context/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"GolangEP01_并发之绕不过的context","name":"GolangEP01_并发之绕不过的context","description":"引子 今天心血来潮，给自己梳理梳理golang中这个十分重要的东东——context，毕竟也是在面试中考察到，但是反问自己的时候却感觉一点也说不出来什么有价值的东西，所以今天我来一次刨根究底。\n","keywords":["Golang","源码","Context"],"articleBody":"引子 今天心血来潮，给自己梳理梳理golang中这个十分重要的东东——context，毕竟也是在面试中考察到，但是反问自己的时候却感觉一点也说不出来什么有价值的东西，所以今天我来一次刨根究底。\n源码解析 Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.\n这是来自于官方的最新说明，意味着 context 携带终止期限，取消信号，以及跨API，进程之间通信等信息。\n即context设计的核心目标是\n任务取消机制：跨API和Goroutine的任务取消信号传播机制 超时控制：超时或截止时间控制任务生命周期 数据共享：在不同函数调用间共享元数据 明确了这些，我们进入到源码中。\nContext接口及错误变量 下面这段是来自于Chatgpt的精简版（去掉了长长的英文注释），可以发现Context是一个接口，其中包含了四个方法等待实现。context.Context\n其中第二个比较特殊，返回的是一个channel。\ntype Context interface { Deadline() (deadline time.Time, ok bool) // 返回任务截止时间 Done() \u003c-chan struct{} // 返回取消信号的 channel Err() error // 返回上下文取消的原因 Value(key any) any // 获取上下文中的值 } Done 返回一个仅接收的内部通道，当取消信号发到通道后，此通道得关闭，同时context取消； 关闭通道是唯一一个所有消费者 goroutine 都能够感知到的通道操作 case \u003c-ctx.Done() 如果 Done 通道还未关闭，Err 返回 nil；如果关闭了，就会返回其关闭原因，具体见下面的两个错误类型变量 ctx.Err() 说到这里我们需要补充一下，整个context包中一共有以下这些上下文类型,接下来就会根据这几种类型分别阐述。\nemptyCtx cancleCtx timerCtx valueCtx 以及cancleCtx下的一系列衍生体 定义完了接口，接下来是两个错误类型变量:\nvar Canceled = errors.New(\"context canceled\") var DeadlineExceeded error = deadlineExceededError{} // type deadlineExceededError struct{} func (deadlineExceededError) Error() string { return \"context deadline exceeded\" } func (deadlineExceededError) Timeout() bool { return true } func (deadlineExceededError) Temporary() bool { return true } 根据源码中的注释可以得知\nCanceld是上下文被取消时的错误类型，是一个简单的 error 对象，由 errors.New 创建。 DealineExceeded表示上下文超出截止时间的错误类型，具体实现是 deadlineExceededError，一个实现了 error 接口的结构体，可以为这个错误类型提供更加丰富的信息。 下面三个实现的来自于error的接口表示这是由于超时而引起的错误，暂时性的。 看到这里，我想你已经猜出为什么要定义这两个变量了，正是能够适配 context 接口中的 Err() 方法，至于到底怎么具体实现的 Err() 方法我们后面再说。\nemptyCtx结构 type emptyCtx struct{} func (emptyCtx) Deadline() (deadline time.Time, ok bool) { return } func (emptyCtx) Done() \u003c-chan struct{} { return nil } func (emptyCtx) Err() error { return nil } func (emptyCtx) Value(key any) any { return nil } 显而易见，这是一个空的上下文实现，通常用作上下文链的根节点或者占位符。 注释中也提到，这是一个没有任何状态信息，不包含取消、截止时间、或值存储功能，不能通过取消函数手动取消的上下文。\nBackgroundCtx \u0026 todoCtx结构 type backgroundCtx struct{ emptyCtx } func (backgroundCtx) String() string { return \"context.Background\" } type todoCtx struct{ emptyCtx } func (todoCtx) String() string { return \"context.TODO\" } 这两个接口就用到了emptyCtx,提供了最基础的上下文功能，为开发中的代码提供一个临时的上下文对象，避免为空。\nBackground 通常用于上下文链的根节点。 todo 通常用作占位符 推荐使用 todo，二者在行为上是一致的，但是 todo 的语义更加明确，让人们知道到这是一个待确定的地方；而 background 更常见在顶层的调用上，是根。 对应的还有两个方法来生成二者。\nfunc Background() Context { return backgroundCtx{} } func TODO() Context { return todoCtx{} } cancelCtx:支持显示取消的结构 type cancelCtx struct { Context mu sync.Mutex // protects following fields done atomic.Value // of chan struct{}, created lazily, closed by first cancel call children map[canceler]struct{} // set to nil by the first cancel call err error // set to non-nil by the first cancel call cause error // set to non-nil by the first cancel call } func (c *cancelCtx) Value(key any) any { if key == \u0026cancelCtxKey { return c } return value(c.Context, key) } func (c *cancelCtx) Done() \u003c-chan struct{} { d := c.done.Load() if d != nil { return d.(chan struct{}) } c.mu.Lock() defer c.mu.Unlock() d = c.done.Load() if d == nil { d = make(chan struct{}) c.done.Store(d) } return d.(chan struct{}) } func (c *cancelCtx) Err() error { c.mu.Lock() err := c.err c.mu.Unlock() return err } 哦，原来你小子嵌套了Context祖宗，你是儿子啊！然后你还多定义了什么：\nmu，很常见的保护并发访问 done 存储一个懒加载的通道，上下文被取消时关闭此通道；（这里的atomic.Value先放放） children,存储派生于该上下文的子上下文，形成一个上下文链（取消时通知他们） err，错误，通常用上面那两个错误变量 casuse，错误原因。 后面的这几个就是实现Context接口中的方法\nvalue:如果键是 cancelCtxKey，直接返回 cancelCtx 本身；否则交给父上下文处理 Done:先从 done.Load 获取已有通道，如果有了，直接返回；如果没有，创建一个新通道并存储（注意加锁后又尝试加载了一次，防止其他协程创建了通道）；相同上下文返回唯一通道 这是一种双检查锁的模式 Err:保证线程安全地返回错误状态 接下来是此结构中最重要的 cancel 方法，用于取消当前上下文，并传播取消信号到所有的子上下文，整个流程大致总结如下：\n设置 err 和 cause 表示上下文已经被取消 关闭 Done 通道以通知所有监听者 遍历递归取消所有子上下文（链条） 最后清理资源 // 是否需要将当前上下文从其父上下文的 children 集合中移除，取消的错误信息，取消的原因 func (c *cancelCtx) cancel(removeFromParent bool, err, cause error) { if err == nil { panic(\"context: internal error: missing cancel error\") } if cause == nil { cause = err } // 锁定状态，防止重复取消 c.mu.Lock() if c.err != nil { c.mu.Unlock() return // already canceled } c.err = err c.cause = cause // 检查done通道是否已创建，如果没有就存储一个，否则调用close关闭通道 d, _ := c.done.Load().(chan struct{}) if d == nil { c.done.Store(closedchan) } else { close(d) } // 至此，通知所有子上下文关闭,递归地调用cancel方法 for child := range c.children { // NOTE: acquiring the child's lock while holding parent's lock. child.cancel(false, err, cause) } // 清空子上下文集合 c.children = nil c.mu.Unlock() if removeFromParent { removeChild(c.Context, c) } } CancelFunc函数类型 // A CancelFunc tells an operation to abandon its work. // A CancelFunc does not wait for the work to stop. // A CancelFunc may be called by multiple goroutines simultaneously. // After the first call, subsequent calls to a CancelFunc do nothing. type CancelFunc func() 是一个函数类型，表示一个无参数、无返回值的函数，并发安全，一次性触发（只有第一次调用会有效）。\n之所以这里定义为函数类型，就是为了让其他需要使用到CancelFunc的方法通过闭包来绑定具体的逻辑。稍后我们在一些具体方法中就能看到。\nWithCancel \u0026 WithCancelCause func WithCancel(parent Context) (ctx Context, cancel CancelFunc) { c := withCancel(parent) return c, func() { c.cancel(true, Canceled, nil) } } type CancelCauseFunc func(cause error) func WithCancelCause(parent Context) (ctx Context, cancel CancelCauseFunc) { c := withCancel(parent) return c, func(cause error) { c.cancel(true, Canceled, cause) } } WithCancel 传入父上下文，创建一个取消上下文，返回此上下文和一个取消函数 可以发现正如我们上面所说，利用闭包，直接返回了一个取消函数cancel来触发上下文的取消 WithCancelCause 将WithCancel中的CancelFunc换为CancelCasuseFunc，带有取消原因。 下面的闭包函数中可以传入一个取消原因cause error func withCancel(parent Context) *cancelCtx { if parent == nil { panic(\"cannot create context from nil parent\") } c := \u0026cancelCtx{} c.propagateCancel(parent, c) return c } 这个withCancel就是上面两个方法分别调用的核心方法来创建一个cancelCtx上下文实例。\n先判断父上下文是否为空（上下文链必须有一个根），随后创建一个cancelCtx上下文实例，调用propagateCancel关联父子并监听父上下文的取消事件。\n说到这里可能有些懵逼了，那我们就来看看这个 propagateCancel 是怎么个事！\npropagateCancel 顾名思义，传播，用于将子取消逻辑与父取消逻辑联系起来形成一个链。具体代码逻辑的解释见注释。\n// propagateCancel arranges for child to be canceled when parent is. // It sets the parent context of cancelCtx. func (c *cancelCtx) propagateCancel(parent Context, child canceler) { c.Context = parent // parent作为基础（即上面的嵌套Context） done := parent.Done() // 获取parent的Done通道，记录着取消信号的channel if done == nil { // 如果为空，说明没有取消信号，parent永远不会取消 return // parent is never canceled } select { case \u003c-done: // ? // parent is already canceled child.cancel(false, parent.Err(), Cause(parent)) return default: } // 检查parent类型是否为cancelCtx或派生类型 if p, ok := parentCancelCtx(parent); ok { // parent is a *cancelCtx, or derives from one. p.mu.Lock() if p.err != nil { // 如果错误类型不为空，证明parent已被取消了 // parent has already been canceled child.cancel(false, p.err, p.cause) } else { // 否则将child加入到parent的子集中 if p.children == nil { p.children = make(map[canceler]struct{}) } p.children[child] = struct{}{} } p.mu.Unlock() return } // 如果parent实现了AfterFunc方法，这个之后我们会说，是一种定时回调 if a, ok := parent.(afterFuncer); ok { // parent implements an AfterFunc method. c.mu.Lock() stop := a.AfterFunc(func() { child.cancel(false, parent.Err(), Cause(parent)) }) c.Context = stopCtx{ Context: parent, stop: stop, } c.mu.Unlock() return } // 用于处理无法直接关联的上下文，goroutine同时监听parent和child的Done通道 goroutines.Add(1) go func() { select { case \u003c-parent.Done(): child.cancel(false, parent.Err(), Cause(parent)) case \u003c-child.Done(): } }() } 所以，回到最开始的 withCancel 中，构建了一个取消传播链，可以调用 CancelFunc 来触发取消逻辑，释放资源。\nCause 从Context中提取取消原因(cause)\nfunc Cause(c Context) error { if cc, ok := c.Value(\u0026cancelCtxKey).(*cancelCtx); ok { cc.mu.Lock() defer cc.mu.Unlock() return cc.cause } return c.Err() } afterFuncCtx 在cancelCtx的基础上实现回调。\ntype afterFuncCtx struct { cancelCtx once sync.Once // 确保 f 只被执行一次 f func() // 要在上下文完成时调用的回调函数 } AfterFunc传入回调函数f，并将afterFuncCtx关联到父上下文\nfunc AfterFunc(ctx Context, f func()) (stop func() bool) { a := \u0026afterFuncCtx{ f: f, } // 将 afterFuncCtx 作为子上下文，关联到父上下文 ctx a.cancelCtx.propagateCancel(ctx, a) // 返回的 stop 函数用于停止回调的执行 return func() bool { stopped := false a.once.Do(func() { stopped = true }) if stopped { a.cancel(true, Canceled, nil) } return stopped } } timerCtx 这是cancelCtx的扩展，支持设置截止时间的上下文类型，多了 timer 和 deadline 字段。\ntype timerCtx struct { cancelCtx timer *time.Timer // Under cancelCtx.mu. deadline time.Time } // 返回当前截止时间以及标志位 func (c *timerCtx) Deadline() (deadline time.Time, ok bool) { return c.deadline, true } func (c *timerCtx) String() string { return contextName(c.cancelCtx.Context) + \".WithDeadline(\" + c.deadline.String() + \" [\" + time.Until(c.deadline).String() + \"])\" } // 调用cancelCtx的cancel实现取消，多了定时器 func (c *timerCtx) cancel(removeFromParent bool, err, cause error) { c.cancelCtx.cancel(false, err, cause) if removeFromParent { // Remove this timerCtx from its parent cancelCtx's children. removeChild(c.cancelCtx.Context, c) } c.mu.Lock() if c.timer != nil { c.timer.Stop() c.timer = nil } c.mu.Unlock() } WithTimeout \u0026 WithDeadline 基于超时持续时间创建上下文；基于指定的截止时间创建上下文\nfunc WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) { return WithDeadline(parent, time.Now().Add(timeout)) } func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) { return WithDeadlineCause(parent, d, nil) } 可以发现最终还是调用的是 WithDeadlineCause 这个方法\n1.检查父上下文是否有更早的截止时间 2.创建timerCtx 3.计算剩余时间 4.设置定时器 5.返回上下文和取消函数\nfunc WithDeadlineCause(parent Context, d time.Time, cause error) (Context, CancelFunc) { if parent == nil { panic(\"cannot create context from nil parent\") } if cur, ok := parent.Deadline(); ok \u0026\u0026 cur.Before(d) { // The current deadline is already sooner than the new one. return WithCancel(parent) } c := \u0026timerCtx{ deadline: d, } // 关联到父上下文并计算截止时间的剩余时间 c.cancelCtx.propagateCancel(parent, c) dur := time.Until(d) if dur \u003c= 0 { c.cancel(true, DeadlineExceeded, cause) // deadline has already passed return c, func() { c.cancel(false, Canceled, nil) } } // 设置定时器，到时间后自动取消上下文 c.mu.Lock() defer c.mu.Unlock() if c.err == nil { c.timer = time.AfterFunc(dur, func() { c.cancel(true, DeadlineExceeded, cause) }) } return c, func() { c.cancel(true, Canceled, nil) } } valueCtx 实现键值对存储功能的一种上下文类型,适合携带少量元数据。\ntype valueCtx struct { Context key, val any } Value:如果当前上下文没有匹配的键，则调用 value 函数继续在父上下文中查找。\nvalue:递归辅助方法，用于在上下文链中查找指定key对应的值\nfunc (c *valueCtx) String() string { return contextName(c.Context) + \".WithValue(\" + stringify(c.key) + \", \" + stringify(c.val) + \")\" } func (c *valueCtx) Value(key any) any { if c.key == key { return c.val } return value(c.Context, key) } func value(c Context, key any) any { for { switch ctx := c.(type) { // 如果是valueCtx类型 case *valueCtx: if key == ctx.key { return ctx.val } c = ctx.Context //向父上下文继续找 // 如果是cancelCtx类型 case *cancelCtx: if key == \u0026cancelCtxKey { return c } c = ctx.Context // 如果是withoutCancelCtx类型 case withoutCancelCtx: if key == \u0026cancelCtxKey { // This implements Cause(ctx) == nil // when ctx is created using WithoutCancel. return nil } c = ctx.c // 如果是timerCtx类型 case *timerCtx: if key == \u0026cancelCtxKey { return \u0026ctx.cancelCtx } c = ctx.Context // 如果是backgroundCtx，todoCtx类型即根上下文 case backgroundCtx, todoCtx: return nil default: return c.Value(key) } } } withValue方法 func WithValue(parent Context, key, val any) Context { if parent == nil { panic(\"cannot create context from nil parent\") } if key == nil { panic(\"nil key\") } if !reflectlite.TypeOf(key).Comparable() { panic(\"key is not comparable\") } return \u0026valueCtx{parent, key, val} } 常用的Go Context 类型对比 类型 功能描述 支持取消 支持超时/截止时间 支持键值对存储 emptyCtx 根上下文类型。用于创建 context.Background() 和 context.TODO()，无任何功能。 否 否 否 cancelCtx 支持取消功能，通过 WithCancel 或 WithCancelCause 创建，可以传播取消信号。 是 否 否 timerCtx 基于 cancelCtx，支持取消和超时，通过 WithTimeout 和 WithDeadline 创建。 是 是 否 valueCtx 支持键值对存储，通过 WithValue 创建，通常嵌套在其他类型上下文中使用。 否 否 是 平时是如何使用的 这里举例说明context以及其中的常见方法在代码中是如何使用的。\nWithTimeout\u0026WithDeadline 在这段代码中，context.WithTimeout 起到了控制数据库操作是否超时的作用\nfunc (m MovieModel) Insert(movie *Movie) error { // 插入一条新记录的SQL语句，并返回信息（Postgresql专有) query := ` INSERT INTO movies (title, year, runtime, genres) VALUES ($1, $2, $3, $4) RETURNING id, created_at, version` // 创建一个代表着占位符的movie中的属性切片 args := []interface{}{movie.Title, movie.Year, movie.Runtime, pq.Array(movie.Genres)} // Create a context with a 3-second timeout // 如果数据库操作在3s内没有完成，操作自动取消，返回超时错误 ctx, cancle := context.WithTimeout(context.Background(), 3*time.Second) defer cancle() // 使用QueryRowContext方法执行,利用传入的ctx进行SQL查询，并使用Scan方法将返回值注入到movie的三个属性中 return m.DB.QueryRowContext(ctx, query, args...).Scan(\u0026movie.ID, \u0026movie.CreatedAt, \u0026movie.Version) } 总结 Golang中经常使用 Context，以上四种 Context 类型各有其作用，通常利用其自带的函数例如WithTimeout(),Background()来进行控制操作。\n其中值得注意的是 cancleCtx 的取消机制中的传播链，存在回调机制，值得我多去思考。\n这里是LTX，感谢您阅读这篇博客，人生海海，和自己对话，像只蝴蝶纵横四海。\n","wordCount":"4803","inLanguage":"zh","image":"https://LTXWorld.github.io/images/papermod-cover.png","datePublished":"2024-12-01T12:00:57+08:00","dateModified":"2024-12-01T12:00:57+08:00","author":{"@type":"Person","name":"LTX"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://LTXWorld.github.io/posts/005golangep01_%E5%B9%B6%E5%8F%9101_context/"},"publisher":{"@type":"Organization","name":"LTX's Blog","logo":{"@type":"ImageObject","url":"https://LTXWorld.github.io/favicon.png"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://LTXWorld.github.io/ accesskey=h title="LTX's Blog (Alt + H)">LTX's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://LTXWorld.github.io/ title="LTX's Blog"><span>首页</span></a></li><li><a href=https://LTXWorld.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://LTXWorld.github.io/categories/ title=Categories><span>分类</span></a></li><li><a href=https://LTXWorld.github.io/tags/ title=Tags><span>标签</span></a></li><li><a href=https://LTXWorld.github.io/search/ title=搜索><span>搜索</span></a></li><li><a href=https://LTXWorld.github.io/about/ title=后花园><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">GolangEP01_并发之绕不过的context</h1><div class=post-meta><span title='2024-12-01 12:00:57 +0800 CST'>十二月 1, 2024</span>&nbsp;·&nbsp;10 分钟&nbsp;·&nbsp;LTX</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%bc%95%e5%ad%90 aria-label=引子>引子</a></li><li><a href=#%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90 aria-label=源码解析>源码解析</a><ul><li><a href=#context%e6%8e%a5%e5%8f%a3%e5%8f%8a%e9%94%99%e8%af%af%e5%8f%98%e9%87%8f aria-label=Context接口及错误变量>Context接口及错误变量</a></li><li><a href=#emptyctx%e7%bb%93%e6%9e%84 aria-label=emptyCtx结构>emptyCtx结构</a><ul><li><a href=#backgroundctx--todoctx%e7%bb%93%e6%9e%84 aria-label="BackgroundCtx & todoCtx结构">BackgroundCtx & todoCtx结构</a></li></ul></li><li><a href=#cancelctx%e6%94%af%e6%8c%81%e6%98%be%e7%a4%ba%e5%8f%96%e6%b6%88%e7%9a%84%e7%bb%93%e6%9e%84 aria-label=cancelCtx:支持显示取消的结构>cancelCtx:支持显示取消的结构</a><ul><li><a href=#cancelfunc%e5%87%bd%e6%95%b0%e7%b1%bb%e5%9e%8b aria-label=CancelFunc函数类型>CancelFunc函数类型</a></li><li><a href=#withcancel--withcancelcause aria-label="WithCancel & WithCancelCause">WithCancel & WithCancelCause</a></li><li><a href=#propagatecancel aria-label=propagateCancel>propagateCancel</a></li><li><a href=#cause aria-label=Cause>Cause</a></li><li><a href=#afterfuncctx aria-label=afterFuncCtx>afterFuncCtx</a></li></ul></li><li><a href=#timerctx aria-label=timerCtx>timerCtx</a><ul><li><a href=#withtimeout--withdeadline aria-label="WithTimeout & WithDeadline">WithTimeout & WithDeadline</a></li></ul></li><li><a href=#valuectx aria-label=valueCtx>valueCtx</a><ul><li><a href=#withvalue%e6%96%b9%e6%b3%95 aria-label=withValue方法>withValue方法</a></li></ul></li></ul></li><li><a href=#%e5%b8%b8%e7%94%a8%e7%9a%84go-context-%e7%b1%bb%e5%9e%8b%e5%af%b9%e6%af%94 aria-label="常用的Go Context 类型对比">常用的Go Context 类型对比</a></li><li><a href=#%e5%b9%b3%e6%97%b6%e6%98%af%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8%e7%9a%84 aria-label=平时是如何使用的>平时是如何使用的</a><ul><li><a href=#withtimeoutwithdeadline aria-label=WithTimeout&amp;WithDeadline>WithTimeout&amp;WithDeadline</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></div></details></div><div class=post-content><h2 id=引子>引子<a hidden class=anchor aria-hidden=true href=#引子>#</a></h2><p>今天心血来潮，给自己梳理梳理golang中这个十分重要的东东——context，毕竟也是在面试中考察到，但是反问自己的时候却感觉一点也说不出来什么有价值的东西，所以今天我来一次刨根究底。</p><p><img loading=lazy src=/img/jb/coffee.webp></p><h2 id=源码解析>源码解析<a hidden class=anchor aria-hidden=true href=#源码解析>#</a></h2><blockquote><p>Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.</p></blockquote><p>这是来自于官方的最新说明，意味着 context <strong>携带终止期限，取消信号，以及跨API，进程之间通信</strong>等信息。</p><p>即context设计的核心目标是</p><ul><li>任务取消机制：跨API和Goroutine的任务取消信号传播机制</li><li>超时控制：超时或截止时间控制任务生命周期</li><li>数据共享：在不同函数调用间共享元数据</li></ul><p>明确了这些，我们进入到<a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.3:src/context/context.go;l=227">源码</a>中。</p><h3 id=context接口及错误变量>Context接口及错误变量<a hidden class=anchor aria-hidden=true href=#context接口及错误变量>#</a></h3><p>下面这段是来自于Chatgpt的精简版（去掉了长长的英文注释），可以发现Context是一个接口，其中包含了四个方法等待实现。<code>context.Context</code></p><p>其中第二个比较特殊，返回的是一个channel。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Context</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Deadline</span><span class=p>()</span> <span class=p>(</span><span class=nx>deadline</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=p>,</span> <span class=nx>ok</span> <span class=kt>bool</span><span class=p>)</span> <span class=c1>// 返回任务截止时间</span>
</span></span><span class=line><span class=cl>    <span class=nf>Done</span><span class=p>()</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{}</span>                  <span class=c1>// 返回取消信号的 channel</span>
</span></span><span class=line><span class=cl>    <span class=nf>Err</span><span class=p>()</span> <span class=kt>error</span>                             <span class=c1>// 返回上下文取消的原因</span>
</span></span><span class=line><span class=cl>    <span class=nf>Value</span><span class=p>(</span><span class=nx>key</span> <span class=kt>any</span><span class=p>)</span> <span class=kt>any</span>                      <span class=c1>// 获取上下文中的值</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>Done 返回一个仅接收的<strong>内部通道</strong>，当取消信号发到通道后，此通道得关闭，同时context取消；<ul><li><em>关闭通道是唯一一个所有消费者 goroutine 都能够感知到的通道操作</em></li><li><code>case &lt;-ctx.Done()</code></li></ul></li><li>如果 Done 通道还未关闭，Err 返回 nil；如果关闭了，就会返回其关闭原因，具体见下面的两个错误类型变量<ul><li><code>ctx.Err()</code></li></ul></li></ul><p>说到这里我们需要补充一下，整个context包中一共有以下这些上下文类型,接下来就会根据这几种类型分别阐述。</p><ul><li>emptyCtx</li><li>cancleCtx</li><li>timerCtx</li><li>valueCtx</li><li>以及cancleCtx下的一系列衍生体</li></ul><p>定义完了接口，接下来是两个错误类型变量:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>Canceled</span> <span class=p>=</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;context canceled&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>DeadlineExceeded</span> <span class=kt>error</span> <span class=p>=</span> <span class=nx>deadlineExceededError</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=c1>//</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>deadlineExceededError</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>deadlineExceededError</span><span class=p>)</span> <span class=nf>Error</span><span class=p>()</span> <span class=kt>string</span>   <span class=p>{</span> <span class=k>return</span> <span class=s>&#34;context deadline exceeded&#34;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>deadlineExceededError</span><span class=p>)</span> <span class=nf>Timeout</span><span class=p>()</span> <span class=kt>bool</span>   <span class=p>{</span> <span class=k>return</span> <span class=kc>true</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>deadlineExceededError</span><span class=p>)</span> <span class=nf>Temporary</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span> <span class=k>return</span> <span class=kc>true</span> <span class=p>}</span>
</span></span></code></pre></div><p>根据源码中的注释可以得知</p><ul><li>Canceld是<strong>上下文被取消时</strong>的错误类型，是一个简单的 error 对象，由 errors.New 创建。</li><li>DealineExceeded表示<strong>上下文超出截止时间</strong>的错误类型，具体实现是 deadlineExceededError，一个实现了 error 接口的结构体，可以为这个错误类型提供更加丰富的信息。</li><li>下面三个实现的来自于error的接口表示这是由于超时而引起的错误，暂时性的。</li></ul><p>看到这里，我想你已经猜出为什么要定义这两个变量了，正是能够适配 context 接口中的 Err() 方法，至于到底怎么具体实现的 Err() 方法我们后面再说。</p><h3 id=emptyctx结构>emptyCtx结构<a hidden class=anchor aria-hidden=true href=#emptyctx结构>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>emptyCtx</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>emptyCtx</span><span class=p>)</span> <span class=nf>Deadline</span><span class=p>()</span> <span class=p>(</span><span class=nx>deadline</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=p>,</span> <span class=nx>ok</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>emptyCtx</span><span class=p>)</span> <span class=nf>Done</span><span class=p>()</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>emptyCtx</span><span class=p>)</span> <span class=nf>Err</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>emptyCtx</span><span class=p>)</span> <span class=nf>Value</span><span class=p>(</span><span class=nx>key</span> <span class=kt>any</span><span class=p>)</span> <span class=kt>any</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>显而易见，这是一个空的上下文实现，通常用作上下文链的根节点或者占位符。
注释中也提到，<strong>这是一个没有任何状态信息，不包含取消、截止时间、或值存储功能，不能通过取消函数手动取消的上下文。</strong></p><h4 id=backgroundctx--todoctx结构>BackgroundCtx & todoCtx结构<a hidden class=anchor aria-hidden=true href=#backgroundctx--todoctx结构>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>backgroundCtx</span> <span class=kd>struct</span><span class=p>{</span> <span class=nx>emptyCtx</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>backgroundCtx</span><span class=p>)</span> <span class=nf>String</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=s>&#34;context.Background&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>todoCtx</span> <span class=kd>struct</span><span class=p>{</span> <span class=nx>emptyCtx</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>todoCtx</span><span class=p>)</span> <span class=nf>String</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=s>&#34;context.TODO&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这两个接口就用到了emptyCtx,提供了最基础的上下文功能，为开发中的代码提供一个临时的上下文对象，避免为空。</p><ul><li>Background 通常用于上下文链的<strong>根节点</strong>。</li><li>todo 通常用作占位符</li><li>推荐使用 todo，二者在行为上是一致的，但是 todo 的语义更加明确，让人们知道到这是一个待确定的地方；而 background 更常见在顶层的调用上，是根。</li></ul><p>对应的还有两个方法来生成二者。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Background</span><span class=p>()</span> <span class=nx>Context</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>backgroundCtx</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TODO</span><span class=p>()</span> <span class=nx>Context</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>todoCtx</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=cancelctx支持显示取消的结构>cancelCtx:支持显示取消的结构<a hidden class=anchor aria-hidden=true href=#cancelctx支持显示取消的结构>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>cancelCtx</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Context</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>mu</span>       <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>            <span class=c1>// protects following fields</span>
</span></span><span class=line><span class=cl>	<span class=nx>done</span>     <span class=nx>atomic</span><span class=p>.</span><span class=nx>Value</span>          <span class=c1>// of chan struct{}, created lazily, closed by first cancel call</span>
</span></span><span class=line><span class=cl>	<span class=nx>children</span> <span class=kd>map</span><span class=p>[</span><span class=nx>canceler</span><span class=p>]</span><span class=kd>struct</span><span class=p>{}</span> <span class=c1>// set to nil by the first cancel call</span>
</span></span><span class=line><span class=cl>	<span class=nx>err</span>      <span class=kt>error</span>                 <span class=c1>// set to non-nil by the first cancel call</span>
</span></span><span class=line><span class=cl>	<span class=nx>cause</span>    <span class=kt>error</span>                 <span class=c1>// set to non-nil by the first cancel call</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>cancelCtx</span><span class=p>)</span> <span class=nf>Value</span><span class=p>(</span><span class=nx>key</span> <span class=kt>any</span><span class=p>)</span> <span class=kt>any</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>key</span> <span class=o>==</span> <span class=o>&amp;</span><span class=nx>cancelCtxKey</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>c</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>value</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>cancelCtx</span><span class=p>)</span> <span class=nf>Done</span><span class=p>()</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>d</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>done</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>d</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>d</span><span class=p>.(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>d</span> <span class=p>=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>done</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>d</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>d</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>done</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>d</span><span class=p>.(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>cancelCtx</span><span class=p>)</span> <span class=nf>Err</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>哦，原来你小子嵌套了Context祖宗，你是儿子啊！然后你还多定义了什么：</p><ul><li>mu，很常见的保护并发访问</li><li>done 存储一个<strong>懒加载的通道</strong>，上下文被取消时关闭此通道；（这里的atomic.Value先放放）</li><li>children,存储派生于该上下文的子上下文，形成一个<strong>上下文链</strong>（取消时通知他们）</li><li>err，错误，通常用上面那两个错误变量</li><li>casuse，错误原因。</li></ul><p>后面的这几个就是实现Context接口中的方法</p><ul><li>value:如果键是 cancelCtxKey，直接返回 cancelCtx 本身；否则交给父上下文处理</li><li>Done:先从 done.Load 获取已有通道，如果有了，直接返回；如果没有，创建一个新通道并存储（注意加锁后又尝试加载了一次，防止其他协程创建了通道）；<strong>相同上下文返回唯一通道</strong><ul><li>这是一种双检查锁的模式</li></ul></li><li>Err:保证线程安全地返回错误状态</li></ul><p>接下来是此结构中最重要的 cancel 方法，用于<strong>取消当前上下文，并传播取消信号到所有的子上下文</strong>，整个流程大致总结如下：</p><ul><li>设置 err 和 cause 表示上下文已经被取消</li><li>关闭 Done 通道以通知所有监听者</li><li>遍历递归取消所有子上下文（链条）</li><li>最后清理资源</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 是否需要将当前上下文从其父上下文的 children 集合中移除，取消的错误信息，取消的原因</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>cancelCtx</span><span class=p>)</span> <span class=nf>cancel</span><span class=p>(</span><span class=nx>removeFromParent</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>err</span><span class=p>,</span> <span class=nx>cause</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>panic</span><span class=p>(</span><span class=s>&#34;context: internal error: missing cancel error&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>cause</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>cause</span> <span class=p>=</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 锁定状态，防止重复取消</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=c1>// already canceled</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>err</span> <span class=p>=</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>cause</span> <span class=p>=</span> <span class=nx>cause</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 检查done通道是否已创建，如果没有就存储一个，否则调用close关闭通道</span>
</span></span><span class=line><span class=cl>	<span class=nx>d</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>done</span><span class=p>.</span><span class=nf>Load</span><span class=p>().(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>d</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>done</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=nx>closedchan</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>close</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 至此，通知所有子上下文关闭,递归地调用cancel方法</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>child</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>c</span><span class=p>.</span><span class=nx>children</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// NOTE: acquiring the child&#39;s lock while holding parent&#39;s lock.</span>
</span></span><span class=line><span class=cl>		<span class=nx>child</span><span class=p>.</span><span class=nf>cancel</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span> <span class=nx>err</span><span class=p>,</span> <span class=nx>cause</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 清空子上下文集合</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>children</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>removeFromParent</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>removeChild</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=cancelfunc函数类型>CancelFunc函数类型<a hidden class=anchor aria-hidden=true href=#cancelfunc函数类型>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// A CancelFunc tells an operation to abandon its work.</span>
</span></span><span class=line><span class=cl><span class=c1>// A CancelFunc does not wait for the work to stop.</span>
</span></span><span class=line><span class=cl><span class=c1>// A CancelFunc may be called by multiple goroutines simultaneously.</span>
</span></span><span class=line><span class=cl><span class=c1>// After the first call, subsequent calls to a CancelFunc do nothing.</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>CancelFunc</span> <span class=kd>func</span><span class=p>()</span>
</span></span></code></pre></div><p>是一个函数类型，表示一个无参数、无返回值的函数，并发安全，一次性触发（只有第一次调用会有效）。</p><p>之所以这里定义为函数类型，就是为了让其他需要使用到CancelFunc的方法通过<strong>闭包</strong>来绑定具体的逻辑。稍后我们在一些具体方法中就能看到。</p><h4 id=withcancel--withcancelcause>WithCancel & WithCancelCause<a hidden class=anchor aria-hidden=true href=#withcancel--withcancelcause>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>WithCancel</span><span class=p>(</span><span class=nx>parent</span> <span class=nx>Context</span><span class=p>)</span> <span class=p>(</span><span class=nx>ctx</span> <span class=nx>Context</span><span class=p>,</span> <span class=nx>cancel</span> <span class=nx>CancelFunc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span> <span class=o>:=</span> <span class=nf>withCancel</span><span class=p>(</span><span class=nx>parent</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>c</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>c</span><span class=p>.</span><span class=nf>cancel</span><span class=p>(</span><span class=kc>true</span><span class=p>,</span> <span class=nx>Canceled</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>CancelCauseFunc</span> <span class=kd>func</span><span class=p>(</span><span class=nx>cause</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>WithCancelCause</span><span class=p>(</span><span class=nx>parent</span> <span class=nx>Context</span><span class=p>)</span> <span class=p>(</span><span class=nx>ctx</span> <span class=nx>Context</span><span class=p>,</span> <span class=nx>cancel</span> <span class=nx>CancelCauseFunc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span> <span class=o>:=</span> <span class=nf>withCancel</span><span class=p>(</span><span class=nx>parent</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>c</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>cause</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span> <span class=nx>c</span><span class=p>.</span><span class=nf>cancel</span><span class=p>(</span><span class=kc>true</span><span class=p>,</span> <span class=nx>Canceled</span><span class=p>,</span> <span class=nx>cause</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol><li>WithCancel</li></ol><ul><li>传入父上下文，创建一个取消上下文，返回此上下文和一个取消函数</li><li>可以发现正如我们上面所说，利用闭包，直接返回了一个取消函数cancel来触发上下文的取消</li></ul><ol start=2><li>WithCancelCause</li></ol><ul><li>将WithCancel中的CancelFunc换为CancelCasuseFunc，带有取消原因。</li><li>下面的闭包函数中可以传入一个取消原因<code>cause error</code></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>withCancel</span><span class=p>(</span><span class=nx>parent</span> <span class=nx>Context</span><span class=p>)</span> <span class=o>*</span><span class=nx>cancelCtx</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>parent</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>panic</span><span class=p>(</span><span class=s>&#34;cannot create context from nil parent&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>cancelCtx</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>propagateCancel</span><span class=p>(</span><span class=nx>parent</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>c</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这个withCancel就是上面两个方法分别调用的核心方法来创建一个cancelCtx上下文实例。</p><p>先判断父上下文是否为空（上下文链必须有一个根），<strong>随后创建一个cancelCtx上下文实例，调用propagateCancel关联父子并监听父上下文的取消事件</strong>。</p><p>说到这里可能有些懵逼了，那我们就来看看这个 propagateCancel 是怎么个事！</p><p><img loading=lazy src=/img/ys/ye.webp></p><h4 id=propagatecancel>propagateCancel<a hidden class=anchor aria-hidden=true href=#propagatecancel>#</a></h4><p>顾名思义，传播，用于将<strong>子取消逻辑与父取消逻辑联系起来形成一个链</strong>。具体代码逻辑的解释见注释。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// propagateCancel arranges for child to be canceled when parent is.</span>
</span></span><span class=line><span class=cl><span class=c1>// It sets the parent context of cancelCtx.</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>cancelCtx</span><span class=p>)</span> <span class=nf>propagateCancel</span><span class=p>(</span><span class=nx>parent</span> <span class=nx>Context</span><span class=p>,</span> <span class=nx>child</span> <span class=nx>canceler</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>Context</span> <span class=p>=</span> <span class=nx>parent</span> <span class=c1>// parent作为基础（即上面的嵌套Context）</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>done</span> <span class=o>:=</span> <span class=nx>parent</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span> <span class=c1>// 获取parent的Done通道，记录着取消信号的channel</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>done</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span> <span class=c1>// 如果为空，说明没有取消信号，parent永远不会取消</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=c1>// parent is never canceled</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>done</span><span class=p>:</span> <span class=c1>// ?</span>
</span></span><span class=line><span class=cl>		<span class=c1>// parent is already canceled</span>
</span></span><span class=line><span class=cl>		<span class=nx>child</span><span class=p>.</span><span class=nf>cancel</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span> <span class=nx>parent</span><span class=p>.</span><span class=nf>Err</span><span class=p>(),</span> <span class=nf>Cause</span><span class=p>(</span><span class=nx>parent</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 检查parent类型是否为cancelCtx或派生类型</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>p</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nf>parentCancelCtx</span><span class=p>(</span><span class=nx>parent</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// parent is a *cancelCtx, or derives from one.</span>
</span></span><span class=line><span class=cl>		<span class=nx>p</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span> <span class=c1>// 如果错误类型不为空，证明parent已被取消了</span>
</span></span><span class=line><span class=cl>			<span class=c1>// parent has already been canceled</span>
</span></span><span class=line><span class=cl>			<span class=nx>child</span><span class=p>.</span><span class=nf>cancel</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span> <span class=nx>p</span><span class=p>.</span><span class=nx>err</span><span class=p>,</span> <span class=nx>p</span><span class=p>.</span><span class=nx>cause</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span> <span class=c1>// 否则将child加入到parent的子集中</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>children</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>p</span><span class=p>.</span><span class=nx>children</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=nx>canceler</span><span class=p>]</span><span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>p</span><span class=p>.</span><span class=nx>children</span><span class=p>[</span><span class=nx>child</span><span class=p>]</span> <span class=p>=</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>p</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果parent实现了AfterFunc方法，这个之后我们会说，是一种定时回调</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>a</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>parent</span><span class=p>.(</span><span class=nx>afterFuncer</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// parent implements an AfterFunc method.</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nx>stop</span> <span class=o>:=</span> <span class=nx>a</span><span class=p>.</span><span class=nf>AfterFunc</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>child</span><span class=p>.</span><span class=nf>cancel</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span> <span class=nx>parent</span><span class=p>.</span><span class=nf>Err</span><span class=p>(),</span> <span class=nf>Cause</span><span class=p>(</span><span class=nx>parent</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=p>})</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>Context</span> <span class=p>=</span> <span class=nx>stopCtx</span><span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>Context</span><span class=p>:</span> <span class=nx>parent</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=nx>stop</span><span class=p>:</span>    <span class=nx>stop</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 用于处理无法直接关联的上下文，goroutine同时监听parent和child的Done通道</span>
</span></span><span class=line><span class=cl>	<span class=nx>goroutines</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>parent</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span>
</span></span><span class=line><span class=cl>			<span class=nx>child</span><span class=p>.</span><span class=nf>cancel</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span> <span class=nx>parent</span><span class=p>.</span><span class=nf>Err</span><span class=p>(),</span> <span class=nf>Cause</span><span class=p>(</span><span class=nx>parent</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>child</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>所以，回到最开始的 withCancel 中，构建了一个取消传播链，可以调用 CancelFunc 来触发取消逻辑，释放资源。</p><h4 id=cause>Cause<a hidden class=anchor aria-hidden=true href=#cause>#</a></h4><p>从Context中提取取消原因(cause)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Cause</span><span class=p>(</span><span class=nx>c</span> <span class=nx>Context</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>cc</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Value</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>cancelCtxKey</span><span class=p>).(</span><span class=o>*</span><span class=nx>cancelCtx</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>cc</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nx>cc</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>cc</span><span class=p>.</span><span class=nx>cause</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Err</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=afterfuncctx>afterFuncCtx<a hidden class=anchor aria-hidden=true href=#afterfuncctx>#</a></h4><p>在cancelCtx的基础上实现回调。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>afterFuncCtx</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>cancelCtx</span>
</span></span><span class=line><span class=cl>	<span class=nx>once</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Once</span> <span class=c1>// 确保 f 只被执行一次</span>
</span></span><span class=line><span class=cl>	<span class=nx>f</span>    <span class=kd>func</span><span class=p>()</span>    <span class=c1>// 要在上下文完成时调用的回调函数</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>AfterFunc传入<strong>回调函数f</strong>，并将afterFuncCtx关联到父上下文</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>AfterFunc</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>Context</span><span class=p>,</span> <span class=nx>f</span> <span class=kd>func</span><span class=p>())</span> <span class=p>(</span><span class=nx>stop</span> <span class=kd>func</span><span class=p>()</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>a</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>afterFuncCtx</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>f</span><span class=p>:</span> <span class=nx>f</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 将 afterFuncCtx 作为子上下文，关联到父上下文 ctx</span>
</span></span><span class=line><span class=cl>	<span class=nx>a</span><span class=p>.</span><span class=nx>cancelCtx</span><span class=p>.</span><span class=nf>propagateCancel</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 返回的 stop 函数用于停止回调的执行</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kd>func</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>stopped</span> <span class=o>:=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=nx>a</span><span class=p>.</span><span class=nx>once</span><span class=p>.</span><span class=nf>Do</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>stopped</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>		<span class=p>})</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>stopped</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>a</span><span class=p>.</span><span class=nf>cancel</span><span class=p>(</span><span class=kc>true</span><span class=p>,</span> <span class=nx>Canceled</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>stopped</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=timerctx>timerCtx<a hidden class=anchor aria-hidden=true href=#timerctx>#</a></h3><p>这是cancelCtx的扩展，支持设置截止时间的上下文类型，多了 timer 和 deadline 字段。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>timerCtx</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>cancelCtx</span>
</span></span><span class=line><span class=cl>	<span class=nx>timer</span> <span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Timer</span> <span class=c1>// Under cancelCtx.mu.</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>deadline</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 返回当前截止时间以及标志位</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>timerCtx</span><span class=p>)</span> <span class=nf>Deadline</span><span class=p>()</span> <span class=p>(</span><span class=nx>deadline</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=p>,</span> <span class=nx>ok</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>c</span><span class=p>.</span><span class=nx>deadline</span><span class=p>,</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>timerCtx</span><span class=p>)</span> <span class=nf>String</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>contextName</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>cancelCtx</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=o>+</span> <span class=s>&#34;.WithDeadline(&#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>deadline</span><span class=p>.</span><span class=nf>String</span><span class=p>()</span> <span class=o>+</span> <span class=s>&#34; [&#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>		<span class=nx>time</span><span class=p>.</span><span class=nf>Until</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>deadline</span><span class=p>).</span><span class=nf>String</span><span class=p>()</span> <span class=o>+</span> <span class=s>&#34;])&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 调用cancelCtx的cancel实现取消，多了定时器</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>timerCtx</span><span class=p>)</span> <span class=nf>cancel</span><span class=p>(</span><span class=nx>removeFromParent</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>err</span><span class=p>,</span> <span class=nx>cause</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>cancelCtx</span><span class=p>.</span><span class=nf>cancel</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span> <span class=nx>err</span><span class=p>,</span> <span class=nx>cause</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>removeFromParent</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Remove this timerCtx from its parent cancelCtx&#39;s children.</span>
</span></span><span class=line><span class=cl>		<span class=nf>removeChild</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>cancelCtx</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>timer</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>timer</span><span class=p>.</span><span class=nf>Stop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>timer</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=withtimeout--withdeadline>WithTimeout & WithDeadline<a hidden class=anchor aria-hidden=true href=#withtimeout--withdeadline>#</a></h4><p>基于超时持续时间创建上下文；基于指定的截止时间创建上下文</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>WithTimeout</span><span class=p>(</span><span class=nx>parent</span> <span class=nx>Context</span><span class=p>,</span> <span class=nx>timeout</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span><span class=p>)</span> <span class=p>(</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>CancelFunc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>WithDeadline</span><span class=p>(</span><span class=nx>parent</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Add</span><span class=p>(</span><span class=nx>timeout</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>WithDeadline</span><span class=p>(</span><span class=nx>parent</span> <span class=nx>Context</span><span class=p>,</span> <span class=nx>d</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=p>)</span> <span class=p>(</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>CancelFunc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>WithDeadlineCause</span><span class=p>(</span><span class=nx>parent</span><span class=p>,</span> <span class=nx>d</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可以发现最终还是调用的是 <strong>WithDeadlineCause</strong> 这个方法</p><p>1.检查父上下文是否有更早的截止时间
2.创建timerCtx
3.计算剩余时间
4.设置定时器
5.返回上下文和取消函数</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>WithDeadlineCause</span><span class=p>(</span><span class=nx>parent</span> <span class=nx>Context</span><span class=p>,</span> <span class=nx>d</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=p>,</span> <span class=nx>cause</span> <span class=kt>error</span><span class=p>)</span> <span class=p>(</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>CancelFunc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>parent</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>panic</span><span class=p>(</span><span class=s>&#34;cannot create context from nil parent&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>cur</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>parent</span><span class=p>.</span><span class=nf>Deadline</span><span class=p>();</span> <span class=nx>ok</span> <span class=o>&amp;&amp;</span> <span class=nx>cur</span><span class=p>.</span><span class=nf>Before</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// The current deadline is already sooner than the new one.</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nf>WithCancel</span><span class=p>(</span><span class=nx>parent</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>timerCtx</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>deadline</span><span class=p>:</span> <span class=nx>d</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 关联到父上下文并计算截止时间的剩余时间</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>cancelCtx</span><span class=p>.</span><span class=nf>propagateCancel</span><span class=p>(</span><span class=nx>parent</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>dur</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Until</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>dur</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nf>cancel</span><span class=p>(</span><span class=kc>true</span><span class=p>,</span> <span class=nx>DeadlineExceeded</span><span class=p>,</span> <span class=nx>cause</span><span class=p>)</span> <span class=c1>// deadline has already passed</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>c</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>c</span><span class=p>.</span><span class=nf>cancel</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span> <span class=nx>Canceled</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 设置定时器，到时间后自动取消上下文</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>timer</span> <span class=p>=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>AfterFunc</span><span class=p>(</span><span class=nx>dur</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>c</span><span class=p>.</span><span class=nf>cancel</span><span class=p>(</span><span class=kc>true</span><span class=p>,</span> <span class=nx>DeadlineExceeded</span><span class=p>,</span> <span class=nx>cause</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>c</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>c</span><span class=p>.</span><span class=nf>cancel</span><span class=p>(</span><span class=kc>true</span><span class=p>,</span> <span class=nx>Canceled</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=valuectx>valueCtx<a hidden class=anchor aria-hidden=true href=#valuectx>#</a></h3><p>实现<strong>键值对存储功能</strong>的一种上下文类型,适合携带少量元数据。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>valueCtx</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Context</span>
</span></span><span class=line><span class=cl>	<span class=nx>key</span><span class=p>,</span> <span class=nx>val</span> <span class=kt>any</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Value:如果当前上下文没有匹配的键，则调用 value 函数继续在父上下文中查找。</p><p>value:递归辅助方法，用于在上下文链中查找指定key对应的值</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>valueCtx</span><span class=p>)</span> <span class=nf>String</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>contextName</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=o>+</span> <span class=s>&#34;.WithValue(&#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>		<span class=nf>stringify</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>key</span><span class=p>)</span> <span class=o>+</span> <span class=s>&#34;, &#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>		<span class=nf>stringify</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>val</span><span class=p>)</span> <span class=o>+</span> <span class=s>&#34;)&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>valueCtx</span><span class=p>)</span> <span class=nf>Value</span><span class=p>(</span><span class=nx>key</span> <span class=kt>any</span><span class=p>)</span> <span class=kt>any</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>key</span> <span class=o>==</span> <span class=nx>key</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>c</span><span class=p>.</span><span class=nx>val</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>value</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>value</span><span class=p>(</span><span class=nx>c</span> <span class=nx>Context</span><span class=p>,</span> <span class=nx>key</span> <span class=kt>any</span><span class=p>)</span> <span class=kt>any</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>switch</span> <span class=nx>ctx</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.(</span><span class=kd>type</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 如果是valueCtx类型</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>*</span><span class=nx>valueCtx</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>key</span> <span class=o>==</span> <span class=nx>ctx</span><span class=p>.</span><span class=nx>key</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=nx>ctx</span><span class=p>.</span><span class=nx>val</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>c</span> <span class=p>=</span> <span class=nx>ctx</span><span class=p>.</span><span class=nx>Context</span> <span class=c1>//向父上下文继续找</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 如果是cancelCtx类型</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>*</span><span class=nx>cancelCtx</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>key</span> <span class=o>==</span> <span class=o>&amp;</span><span class=nx>cancelCtxKey</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=nx>c</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>c</span> <span class=p>=</span> <span class=nx>ctx</span><span class=p>.</span><span class=nx>Context</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 如果是withoutCancelCtx类型</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>withoutCancelCtx</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>key</span> <span class=o>==</span> <span class=o>&amp;</span><span class=nx>cancelCtxKey</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=c1>// This implements Cause(ctx) == nil</span>
</span></span><span class=line><span class=cl>				<span class=c1>// when ctx is created using WithoutCancel.</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>c</span> <span class=p>=</span> <span class=nx>ctx</span><span class=p>.</span><span class=nx>c</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 如果是timerCtx类型</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>*</span><span class=nx>timerCtx</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>key</span> <span class=o>==</span> <span class=o>&amp;</span><span class=nx>cancelCtxKey</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=o>&amp;</span><span class=nx>ctx</span><span class=p>.</span><span class=nx>cancelCtx</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>c</span> <span class=p>=</span> <span class=nx>ctx</span><span class=p>.</span><span class=nx>Context</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 如果是backgroundCtx，todoCtx类型即根上下文</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>backgroundCtx</span><span class=p>,</span> <span class=nx>todoCtx</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Value</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=withvalue方法>withValue方法<a hidden class=anchor aria-hidden=true href=#withvalue方法>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>WithValue</span><span class=p>(</span><span class=nx>parent</span> <span class=nx>Context</span><span class=p>,</span> <span class=nx>key</span><span class=p>,</span> <span class=nx>val</span> <span class=kt>any</span><span class=p>)</span> <span class=nx>Context</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>parent</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>panic</span><span class=p>(</span><span class=s>&#34;cannot create context from nil parent&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>key</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>panic</span><span class=p>(</span><span class=s>&#34;nil key&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>reflectlite</span><span class=p>.</span><span class=nf>TypeOf</span><span class=p>(</span><span class=nx>key</span><span class=p>).</span><span class=nf>Comparable</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>panic</span><span class=p>(</span><span class=s>&#34;key is not comparable&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>valueCtx</span><span class=p>{</span><span class=nx>parent</span><span class=p>,</span> <span class=nx>key</span><span class=p>,</span> <span class=nx>val</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=常用的go-context-类型对比>常用的Go Context 类型对比<a hidden class=anchor aria-hidden=true href=#常用的go-context-类型对比>#</a></h2><table><thead><tr><th><strong>类型</strong></th><th><strong>功能描述</strong></th><th><strong>支持取消</strong></th><th><strong>支持超时/截止时间</strong></th><th><strong>支持键值对存储</strong></th></tr></thead><tbody><tr><td><strong><code>emptyCtx</code></strong></td><td>根上下文类型。用于创建 <code>context.Background()</code> 和 <code>context.TODO()</code>，无任何功能。</td><td>否</td><td>否</td><td>否</td></tr><tr><td><strong><code>cancelCtx</code></strong></td><td>支持取消功能，通过 <code>WithCancel</code> 或 <code>WithCancelCause</code> 创建，可以传播取消信号。</td><td>是</td><td>否</td><td>否</td></tr><tr><td><strong><code>timerCtx</code></strong></td><td>基于 <code>cancelCtx</code>，支持取消和超时，通过 <code>WithTimeout</code> 和 <code>WithDeadline</code> 创建。</td><td>是</td><td>是</td><td>否</td></tr><tr><td><strong><code>valueCtx</code></strong></td><td>支持键值对存储，通过 <code>WithValue</code> 创建，通常嵌套在其他类型上下文中使用。</td><td>否</td><td>否</td><td>是</td></tr></tbody></table><hr><h2 id=平时是如何使用的>平时是如何使用的<a hidden class=anchor aria-hidden=true href=#平时是如何使用的>#</a></h2><p>这里举例说明context以及其中的常见方法在代码中是如何使用的。</p><h3 id=withtimeoutwithdeadline>WithTimeout&amp;WithDeadline<a hidden class=anchor aria-hidden=true href=#withtimeoutwithdeadline>#</a></h3><p>在这段代码中，<code>context.WithTimeout</code> 起到了控制数据库操作是否超时的作用</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=nx>MovieModel</span><span class=p>)</span> <span class=nf>Insert</span><span class=p>(</span><span class=nx>movie</span> <span class=o>*</span><span class=nx>Movie</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 插入一条新记录的SQL语句，并返回信息（Postgresql专有)</span>
</span></span><span class=line><span class=cl>	<span class=nx>query</span> <span class=o>:=</span> <span class=s>`
</span></span></span><span class=line><span class=cl><span class=s>			INSERT INTO movies (title, year, runtime, genres)
</span></span></span><span class=line><span class=cl><span class=s>			VALUES ($1, $2, $3, $4)
</span></span></span><span class=line><span class=cl><span class=s>			RETURNING id, created_at, version`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 创建一个代表着占位符的movie中的属性切片</span>
</span></span><span class=line><span class=cl>	<span class=nx>args</span> <span class=o>:=</span> <span class=p>[]</span><span class=kd>interface</span><span class=p>{}{</span><span class=nx>movie</span><span class=p>.</span><span class=nx>Title</span><span class=p>,</span> <span class=nx>movie</span><span class=p>.</span><span class=nx>Year</span><span class=p>,</span> <span class=nx>movie</span><span class=p>.</span><span class=nx>Runtime</span><span class=p>,</span> <span class=nx>pq</span><span class=p>.</span><span class=nf>Array</span><span class=p>(</span><span class=nx>movie</span><span class=p>.</span><span class=nx>Genres</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Create a context with a 3-second timeout</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 如果数据库操作在3s内没有完成，操作自动取消，返回超时错误</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancle</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithTimeout</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=mi>3</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nf>cancle</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 使用QueryRowContext方法执行,利用传入的ctx进行SQL查询，并使用Scan方法将返回值注入到movie的三个属性中</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>m</span><span class=p>.</span><span class=nx>DB</span><span class=p>.</span><span class=nf>QueryRowContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>query</span><span class=p>,</span> <span class=nx>args</span><span class=o>...</span><span class=p>).</span><span class=nf>Scan</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>movie</span><span class=p>.</span><span class=nx>ID</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>movie</span><span class=p>.</span><span class=nx>CreatedAt</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>movie</span><span class=p>.</span><span class=nx>Version</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>Golang中经常使用 Context，以上四种 Context 类型各有其作用，通常利用其自带的函数例如<code>WithTimeout()</code>,<code>Background()</code>来进行控制操作。</p><p>其中值得注意的是 cancleCtx 的取消机制中的传播链，存在回调机制，值得我多去思考。</p><p><strong>这里是LTX，感谢您阅读这篇博客，人生海海，和自己对话，像只蝴蝶纵横四海。</strong></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://LTXWorld.github.io/tags/golang/>Golang</a></li><li><a href=https://LTXWorld.github.io/tags/%E6%BA%90%E7%A0%81/>源码</a></li><li><a href=https://LTXWorld.github.io/tags/context/>Context</a></li></ul><nav class=paginav><a class=prev href=https://LTXWorld.github.io/posts/007golangep02_%E5%B9%B6%E5%8F%9102chan/><span class=title>« 上一页</span><br><span>GolangEP02_并发中的Channel</span>
</a><a class=next href=https://LTXWorld.github.io/posts/004risc-v_deployment/><span class=title>下一页 »</span><br><span>玩转RISCV开发板02-配置好容器化环境</span></a></nav></footer><div id=tw-comment></div><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="light"?"light":"dark",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const s={src:"https://giscus.app/client.js","data-repo":"LTXWorld/LTXWorld.github.io","data-repo-id":"R_kgDONODUuA","data-category":"Announcements","data-category-id":"DIC_kwDONODUuM4CkMUw","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"zh-CN","data-loading":"lazy",crossorigin:"anonymous"},e=document.createElement("script");Object.entries(s).forEach(([t,n])=>e.setAttribute(t,n)),document.querySelector("#tw-comment").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme);const n=document.querySelector("#theme-toggle-float");n&&n.addEventListener("click",setGiscusTheme)})</script></article></main><footer class=footer><span><a href=https://LTXWorld.github.io/>©2025 LTX&rsquo;s Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><div class=ltx-music-player id=ltx-music-player role=group aria-label=背景音乐播放器><audio id=ltx-music-audio preload=metadata></audio><div class=ltx-music-header><div class=ltx-music-visual><div class=ltx-disc data-role=disc aria-hidden=true><img data-role=cover alt loading=lazy decoding=async><div class=ltx-disc-center></div></div></div><div class=ltx-music-meta><span class=ltx-music-title data-role=title></span>
<span class=ltx-music-artist data-role=artist></span></div></div><div class=ltx-music-progress data-role=progress aria-label=进度条 role=slider><div class=ltx-music-progress-fill data-role=progress-fill></div></div><div class=ltx-music-time><span data-role=current>0:00</span>
<span data-role=total>--:--</span></div><div class=ltx-music-controls><button type=button data-action=prev aria-label=上一首>⏮</button>
<button type=button data-action=toggle aria-label=播放或暂停>
<span data-icon=play>▶</span>
<span data-icon=pause>⏸</span>
</button>
<button type=button data-action=next aria-label=下一首>⏭</button>
<button type=button data-action=mute aria-label=静音或取消静音>
<span data-icon=unmuted>🔊</span>
<span data-icon=muted>🔇</span></button></div><div class=ltx-autoplay-tip data-role=tip aria-live=polite></div></div><script>window.LTX_MUSIC_CONFIG={autoplay:!0,defaultCover:"",loopPlaylist:!0,startVolume:.6,tracks:[{artist:"王力宏",file:"/audio/02 - 依然爱你.mp3",title:"依然爱你"},{artist:"王力宏",file:"/audio/05 - 改变自己.mp3",title:"改变自己"},{artist:"王力宏",file:"/audio/11 - 爱错.mp3",title:"爱错"}]},function(){const s=window.LTX_MUSIC_CONFIG||{};if(!s.tracks||!s.tracks.length)return;const t=document.getElementById("ltx-music-player"),e=t.querySelector("audio"),w=t.querySelector('[data-role="title"]'),_=t.querySelector('[data-role="artist"]'),l=t.querySelector('[data-role="progress"]'),f=t.querySelector('[data-role="progress-fill"]'),y=t.querySelector('[data-role="current"]'),j=t.querySelector('[data-role="total"]'),o=t.querySelector('[data-role="tip"]'),i=t.querySelector('[data-role="cover"]'),b=t.querySelector('[data-action="toggle"]'),v=t.querySelector('[data-action="prev"]'),g=t.querySelector('[data-action="next"]'),p=t.querySelector('[data-action="mute"]'),u=(e,t,n)=>Math.min(Math.max(e,t),n),m=e=>{if(!Number.isFinite(e))return"--:--";const t=Math.floor(e/60),n=Math.floor(e%60);return`${String(t).padStart(1,"0")}:${String(n).padStart(2,"0")}`},n={index:0,tracks:s.tracks,autoplay:s.autoplay!==!1,loopPlaylist:s.loopPlaylist!==!1},c=()=>{const n=e.muted||e.volume===0;t.classList.toggle("ltx-muted",n)};e.volume=u(s.startVolume??.6,0,1),c();const r=()=>{const t=e.duration||0,n=e.currentTime||0,s=t?n/t*100:0;f.style.width=`${s}%`,y.textContent=m(n),j.textContent=m(t)},a=(a,c={})=>{const u=n.tracks.length;n.index=(a%u+u)%u;const l=n.tracks[n.index];if(!l||!l.file){console.warn("LTX music player: 音频文件缺失",l),o.textContent="音频文件缺失，请检查配置";return}const h=l.cover||s.defaultCover||"";i&&(h?(i.src=h,i.alt=l.title?`${l.title} 封面`:"音乐封面",t.classList.add("ltx-has-cover")):(i.removeAttribute("src"),i.alt="",t.classList.remove("ltx-has-cover"))),w.textContent=l.title||`Track ${n.index+1}`,_.textContent=l.artist||"",e.src=l.file,t.dataset.trackIndex=n.index,o.textContent="",t.classList.remove("ltx-autoplay-blocked"),r(),c.play&&d()},d=()=>{e.play().then(()=>{t.classList.remove("ltx-autoplay-blocked"),o.textContent=""}).catch(()=>{t.classList.add("ltx-autoplay-blocked"),o.textContent="浏览器阻止了自动播放，请点击播放按钮"})},h=(t=!1)=>{const o=!e.paused||t,s=n.index+1;if(s>=n.tracks.length&&!n.loopPlaylist){e.currentTime=e.duration||0,e.pause();return}a(s,{play:o})},O=()=>{const t=!e.paused;a(n.index-1,{play:t})};b.addEventListener("click",()=>{e.paused?d():e.pause()}),v.addEventListener("click",O),g.addEventListener("click",()=>h(!1)),p.addEventListener("click",()=>{e.muted=!e.muted,c()}),l.addEventListener("click",t=>{const n=l.getBoundingClientRect(),s=u((t.clientX-n.left)/n.width,0,1);Number.isFinite(e.duration)&&(e.currentTime=s*e.duration)}),e.addEventListener("timeupdate",r),e.addEventListener("loadedmetadata",r),e.addEventListener("play",()=>{t.classList.add("ltx-playing"),t.classList.remove("ltx-autoplay-blocked"),o.textContent=""}),e.addEventListener("pause",()=>{t.classList.remove("ltx-playing")}),e.addEventListener("ended",()=>{h(!0)}),e.addEventListener("volumechange",c),a(0,{play:n.autoplay})}()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>