<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>GolangEP05_Go中的并发 | LTX's Blog</title>
<meta name=keywords content="Golang,源码,并发"><meta name=description content='引子
之前的两篇文章关于context和channel，我们都从源码的角度去讨论了其各自的底层原理以及使用方法。
但是我并没有从宏观的角度上来阐述为什么我们需要并发？为什么要设计这两种结构来处理并发，本着做到"what-how-why"的态度，我们今天来深入讨论一下 Go 中的并发。'><meta name=author content="LTX"><link rel=canonical href=https://LTXWorld.github.io/posts/031golangep05_%E5%B9%B6%E5%8F%9103%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%A8%E8%AE%BA%E5%B9%B6%E5%8F%91/><link crossorigin=anonymous href=/assets/css/stylesheet.c8ce79b6b2fa93a6f3465e7adf11510ca336c9c5f1e952a18dc605f3b152b55e.css integrity="sha256-yM55trL6k6bzRl563xFRDKM2ycXx6VKhjcYF87FStV4=" rel="preload stylesheet" as=style><link rel=icon href=https://LTXWorld.github.io/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://LTXWorld.github.io/favicon.png><link rel=icon type=image/png sizes=32x32 href=https://LTXWorld.github.io/favicon.png><link rel=apple-touch-icon href=https://LTXWorld.github.io/favicon.png><link rel=mask-icon href=https://LTXWorld.github.io/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://LTXWorld.github.io/posts/031golangep05_%E5%B9%B6%E5%8F%9103%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%A8%E8%AE%BA%E5%B9%B6%E5%8F%91/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><meta property="og:url" content="https://LTXWorld.github.io/posts/031golangep05_%E5%B9%B6%E5%8F%9103%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%A8%E8%AE%BA%E5%B9%B6%E5%8F%91/"><meta property="og:site_name" content="LTX's Blog"><meta property="og:title" content="GolangEP05_Go中的并发"><meta property="og:description" content='引子 之前的两篇文章关于context和channel，我们都从源码的角度去讨论了其各自的底层原理以及使用方法。
但是我并没有从宏观的角度上来阐述为什么我们需要并发？为什么要设计这两种结构来处理并发，本着做到"what-how-why"的态度，我们今天来深入讨论一下 Go 中的并发。'><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-03T21:04:26+08:00"><meta property="article:modified_time" content="2025-05-03T21:04:26+08:00"><meta property="article:tag" content="Golang"><meta property="article:tag" content="源码"><meta property="article:tag" content="并发"><meta property="og:image" content="https://LTXWorld.github.io/images/papermod-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://LTXWorld.github.io/images/papermod-cover.png"><meta name=twitter:title content="GolangEP05_Go中的并发"><meta name=twitter:description content='引子
之前的两篇文章关于context和channel，我们都从源码的角度去讨论了其各自的底层原理以及使用方法。
但是我并没有从宏观的角度上来阐述为什么我们需要并发？为什么要设计这两种结构来处理并发，本着做到"what-how-why"的态度，我们今天来深入讨论一下 Go 中的并发。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://LTXWorld.github.io/posts/"},{"@type":"ListItem","position":2,"name":"GolangEP05_Go中的并发","item":"https://LTXWorld.github.io/posts/031golangep05_%E5%B9%B6%E5%8F%9103%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%A8%E8%AE%BA%E5%B9%B6%E5%8F%91/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"GolangEP05_Go中的并发","name":"GolangEP05_Go中的并发","description":"引子 之前的两篇文章关于context和channel，我们都从源码的角度去讨论了其各自的底层原理以及使用方法。\n但是我并没有从宏观的角度上来阐述为什么我们需要并发？为什么要设计这两种结构来处理并发，本着做到\u0026quot;what-how-why\u0026quot;的态度，我们今天来深入讨论一下 Go 中的并发。\n","keywords":["Golang","源码","并发"],"articleBody":"引子 之前的两篇文章关于context和channel，我们都从源码的角度去讨论了其各自的底层原理以及使用方法。\n但是我并没有从宏观的角度上来阐述为什么我们需要并发？为什么要设计这两种结构来处理并发，本着做到\"what-how-why\"的态度，我们今天来深入讨论一下 Go 中的并发。\n区分并行和并发 这个已经被说烂的话题为什么我还要拿出来说呢？（因为书里写了，bushi）因为自己对其的理解还不够深刻。英文中并行通常是 Parallelism,并发是 Concurrency.\nConcurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once.\n从这句名言可以看出，并发是一种组织结构上的概念，而并行是一种执行上的概念。（这个思想很重要）\n同时我们抛出一个问题：同样的程序，并发就一定并行要快吗？\n在回答这个问题之前，我们应该先了解 Go 中关于并发和并行的常见概念，也就是 goroutine 与 GMP 调度模型。\ngoroutine 在我们学的操作系统课程中，通常用线程thread 描述并发，进程描述并行；但是作为 Go 程序员，我们通常用 goroutine 描述并发，thread描述操作系统线程。\ngoroutine 可以被视作应用级别的 threads，所以这是一种来自于用户态的调度 相当于又把 thread 往里“剥”了一层 那为什么要搞一个 goroutine 出来呢？\nthread 直接由 OS 管理，占用空间大，系统调用和线程调度过程中上下文切换资源消耗大，并且受到 CPU 资源限制，同步问题处理复杂 goroutine 由 Go runtime 管理，占用空间极小（2KB）；运行时的调度器可以将N个 goroutine 映射到 M 个 thread 上，消耗小；Go 提供 context,channel机制处理同步问题容易 GMP模型 上面提到了调度器的作用，其实就是 Go 的调度模型 GMP（这里简单提及，后续会出文章深究）\nG-Goroutine M-OS thread P-CPU core 形象的理解就是 M 作为服务员，通过 P 来服务许多的顾客 G，而管理员就是 Goruntime.\n每个 goroutine 都有三个状态（类似于 thread 的几个状态,但比其简单）\nExecuting Runnable Waiting 还有一个重要概念，这里简单提一嘴：GOMAXPROCS——代表着默认M的数量，同时也是最多有多少 goroutine 同时处于 Executing 状态。\nGOMAX-PROCS is by default equal to the number of available CPU cores；GOMAX-PROCS can be changed and can be less than the number of CPU cores\n最后再简单说说 GoRuntime 是怎么调度以保证并发效率的。\n采用队列保存 goroutine,有本地队列也有全局队列。 遇到自身没有 goroutine 的时候会进行 work stealing,从其他的队列偷一半过来保证并发效率。\n并发一定快吗？ 好了，补充了这么多了，希望大家没有忘记上面提出的问题，并发的写法一定比顺序的快吗？\n以书中的例子——归并排序举例。 因为归并排序每次将元素分为长度相同的两半，直到无法分，然后又对分出的这些内容进行排序，最后组合在一起（形成了一个树形结构）\n如果我们用 goroutine，大概是这样的。\nfunc MergesortV1(s []int) { if len(s) \u003c= 1 { return } middle := len(s) / 2 var wg sync.WaitGroup wg.Add(2) go func() { defer wg.Done() MergesortV1(s[:middle]) }() go func() { defer wg.Done() MergesortV1(s[middle:]) }() wg.Wait() merge(s, middle) } 结果发现，并发反而要比顺序要慢，这是为什么呢？\n还记得我们一开始就说过，并发是一种组织结构，是需要调度的，调度是需要开销的。 尽管我们已经用了 goroutine 这样一个开销较小的结构，但是对于归并排序，每次把元素划分地太小了，导致每一个任务的开销甚至不如调度的开销，所以并发更加耗时。 如何解决这个问题？很明显是 workload 的缘故，所以我们可以设置一个 workload 的 threshhold,不够这个门槛的顺序执行，超过的并发执行。\n并发引起的数据竞争 在上面我们引入了 goroutine 并讨论了 golang 中的并发与并行。接下来讨论常见的数据竞争问题。\n首先要明确一点：goroutine 虽然已经创建，但不一定立刻调度运行（Go 的调度器不保证立即运行）也就是我们写的代码的顺序并不是真正的执行顺序。\n众所周知，数据竞争一直是并发问题下绕不开的话题。Go 中使用 goroutine 这种更小的结构更应该讨论如何面对数据竞争。 同时 Go 也为我们提供了一个运行时参数-race来检查我们的代码中是否有数据竞争问题。\n那我们就来看看 Go 是如何避免数据竞争的。 Go的标准库 sync 下就有一些准备好的方法。\natomic 从单词意思就可以看出来，原子化——不能被打断的操作。atomic.AddInt64(\u0026i, 1) 需要注意的是，其只能作用于具体类型，不能用于像 slices,maps,structs这样的结构。（并且还得指明bit位数）\nmutex 这就类似于操作系统课程中的锁，mutex可以主动给数据区上锁打造临界区，这样自然可以处理数据冲突问题。mutex.Lock()\n但是可能会发生死锁问题——死锁发生的根本原因是所有 goroutine 都被阻塞，没有任何一个能推进程序的执行。 特别是 main 中的被阻塞，而其他的 goroutine还没来得及启动时，那一定会都堵在那里。\nchannel 同时，我们也可以用 channel处理数据竞争，关于其底层原理，见我的文章.\n这里我们使用的是无缓冲的 channel，因为无缓冲型有一个特点是其必须存在一对接收方与发送方，如果少了其中之一，这个通道就会阻塞。 所以无缓冲的通道具有很强的同步一致性。\n有缓冲也可以，但是需要我们进行额外设计。\n区分mutex与channel 区分mutex与channel,二者最本质的区别是前者强调上锁形成一个临界区，而后者强调不同 goroutine 之间的通信协作。\nmu.Lock(),mu.Unlock()保护共享的内存 ch \u003c-1, \u003c-ch发送给通道，通道接收 在 Golang 中有一个原则是：不要通过共享内存来通信，而应该通过通信来共享内存\n区分data race和race condition 解决了数据竞争程序就可以一定按照我们想要的顺序执行吗？不一定。例如\ni := 0 mutex := sync.Mutex{} go func() { mutex.Lock() defer mutex.Unlock() i = 1 }() go func() { mutex.Lock() defer mutex.Unlock() i = 2 }() 很明显，没有数据竞争问题，但是最终结果会是1还是2？得看两个协程的运行先后顺序了。\nA data race occurs when multiple goroutines simultaneously access the same memory location and at least one of them is writing. An application can be free of data races but still have behavior that depends on uncontrolled events (such as goroutine execution, how fast a message is published to a channel, or how long a call to a data-base lasts); this is a race condition.\n可见 mutex 无法解决执行顺序问题，但是 channel 可以，它的核心思想一直是通过通信来共享数据，而不是通过共享数据来通信。 所以我们可以通过channel解决，第二个操作需要等待第一个操作完成（对其阻塞）\ni := 0 done1 := make(chan struct{}) // 用于通知第一个 goroutine 已完成 done2 := make(chan struct{}) // 用于通知第二个 goroutine 已完成 go func() { i = 1 close(done1) // 通知第一个操作已完成 }() go func() { \u003c-done1 // 等待第一个操作完成 i = 2 close(done2) // 通知第二个操作已完成 }() \u003c-done2 // 等待所有操作完成 fmt.Println(i) // 保证输出 2 具体原理简单解释一下：如果 done1 通道阻塞了，第二个 goroutine会被挂起并加入到接收等待队列，调度器会将其移出可运行队列，并切换其他协程，直到被唤醒。\nGo内存模型 上面的执行顺序问题其实在 Go 的内存模型中就已经定义过了。称为多 goroutine 并发操作时的执行顺序规则。 关键在于 happens-before 关系。规定哪些操作必须发生在另一些操作之前。\n1.channel 的发送操作在接收完成之前 1.底层用锁和等待队列实现。 2.close 先于所有“因关闭而返回”的接收操作 1.这样就不会出现关闭后仍能接收的情况 3.无缓冲的 channel 接收操作先于发送完成（这一点有些难理解） 1.就是我们说的接收和发送是一对操作，如果没有准备好的发送，接收就会阻塞\ngoroutine泄漏问题 Context在并发中也是十分重要的一环，用于控制生命周期，具体见这篇文章.最后我们来说一下一个常见问题: goroutine的泄漏——某些 goroutine 在预期之外长期运行或阻塞，无法被回收，导致内存和 CPU 资源浪费，甚至程序崩溃（其实阻塞有时就是死锁）。\n无缓冲 channel 阻塞：我们之前一直强调 channel 要是成对出现的，如果永久阻塞就会泄漏 未关闭 channel 导致接收者阻塞 无限循环的：增加退出条件，例如 ctx.Done() 未处理的 select 分支:最终原因也是堵塞 为了解决堵塞，我们推荐使用有缓冲的 channel，确保关闭通道，使用 context 来控制生命周期，使用 select（case）+default分支结构。\n区分 I/O密集型和CPU密集型任务 I/O 密集型任务：网络请求，文件操作，数据库访问。 CPU 密集型任务：数学计算，图像处理等。\n由于 Go 的调度依赖运行时，之前我们提到他是在用户态的调度，所以上下文的切换成本比 thread 要低得多。于是可以创建数十万级别的 goroutine. 如果有10000个HTTP请求，他就可以开10000个 goroutine，而由于调度器的存在（GMP模型）实际上只需要少量的 OS thread。 其通信模型 channel 也十分适合这类型的任务。\n但是到了 CPU 密集型任务，就得靠 GOMAXPROCS 这个参数了，它是实打实的表征着正在运行的 thread数量，Gol 对于这类任务并没有体现出更优的性能，C/C++ 也许更为合适。\n总结 Go 依靠其独特的 goroutine、channel、context结构，展现出优异的并发能力（特别是在I/O密集型任务上） Go 的核心理念是：不要通过共享内存来通信，而是通过通信来共享内存\n这里是LTX，感谢您阅读这篇博客，人生海海，和自己对话，像只蝴蝶纵横四海。\n","wordCount":"3455","inLanguage":"zh","image":"https://LTXWorld.github.io/images/papermod-cover.png","datePublished":"2025-05-03T21:04:26+08:00","dateModified":"2025-05-03T21:04:26+08:00","author":{"@type":"Person","name":"LTX"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://LTXWorld.github.io/posts/031golangep05_%E5%B9%B6%E5%8F%9103%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%A8%E8%AE%BA%E5%B9%B6%E5%8F%91/"},"publisher":{"@type":"Organization","name":"LTX's Blog","logo":{"@type":"ImageObject","url":"https://LTXWorld.github.io/favicon.png"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://LTXWorld.github.io/ accesskey=h title="LTX's Blog (Alt + H)">LTX's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://LTXWorld.github.io/ title="LTX's Blog"><span>首页</span></a></li><li><a href=https://LTXWorld.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://LTXWorld.github.io/categories/ title=Categories><span>分类</span></a></li><li><a href=https://LTXWorld.github.io/tags/ title=Tags><span>标签</span></a></li><li><a href=https://LTXWorld.github.io/search/ title=搜索><span>搜索</span></a></li><li><a href=https://LTXWorld.github.io/about/ title=后花园><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">GolangEP05_Go中的并发</h1><div class=post-meta><span title='2025-05-03 21:04:26 +0800 CST'>五月 3, 2025</span>&nbsp;·&nbsp;7 分钟&nbsp;·&nbsp;LTX</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%bc%95%e5%ad%90 aria-label=引子>引子</a></li><li><a href=#%e5%8c%ba%e5%88%86%e5%b9%b6%e8%a1%8c%e5%92%8c%e5%b9%b6%e5%8f%91 aria-label=区分并行和并发>区分并行和并发</a><ul><li><a href=#goroutine aria-label=goroutine>goroutine</a></li><li><a href=#gmp%e6%a8%a1%e5%9e%8b aria-label=GMP模型>GMP模型</a></li><li><a href=#%e5%b9%b6%e5%8f%91%e4%b8%80%e5%ae%9a%e5%bf%ab%e5%90%97 aria-label=并发一定快吗？>并发一定快吗？</a></li></ul></li><li><a href=#%e5%b9%b6%e5%8f%91%e5%bc%95%e8%b5%b7%e7%9a%84%e6%95%b0%e6%8d%ae%e7%ab%9e%e4%ba%89 aria-label=并发引起的数据竞争>并发引起的数据竞争</a><ul><li><a href=#atomic aria-label=atomic>atomic</a></li><li><a href=#mutex aria-label=mutex>mutex</a></li><li><a href=#channel aria-label=channel>channel</a></li><li><a href=#%e5%8c%ba%e5%88%86mutex%e4%b8%8echannel aria-label=区分mutex与channel>区分mutex与channel</a></li><li><a href=#%e5%8c%ba%e5%88%86data-race%e5%92%8crace-condition aria-label="区分data race和race condition">区分data race和race condition</a></li><li><a href=#go%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b aria-label=Go内存模型>Go内存模型</a></li></ul></li><li><a href=#goroutine%e6%b3%84%e6%bc%8f%e9%97%ae%e9%a2%98 aria-label=goroutine泄漏问题>goroutine泄漏问题</a></li><li><a href=#%e5%8c%ba%e5%88%86-io%e5%af%86%e9%9b%86%e5%9e%8b%e5%92%8ccpu%e5%af%86%e9%9b%86%e5%9e%8b%e4%bb%bb%e5%8a%a1 aria-label="区分 I/O密集型和CPU密集型任务">区分 I/O密集型和CPU密集型任务</a></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></div></details></div><div class=post-content><h2 id=引子>引子<a hidden class=anchor aria-hidden=true href=#引子>#</a></h2><p>之前的两篇文章关于<a href=https://www.bfsmlt.top/posts/005golangep01_%E5%B9%B6%E5%8F%9101_context/>context</a>和<a href=https://www.bfsmlt.top/posts/007golangep02_%E5%B9%B6%E5%8F%9102chan/>channel</a>，我们都从源码的角度去讨论了其各自的底层原理以及使用方法。</p><p>但是我并没有从宏观的角度上来阐述为什么我们需要并发？为什么要设计这两种结构来处理并发，本着做到"what-how-why"的态度，我们今天来深入讨论一下 Go 中的并发。</p><h2 id=区分并行和并发>区分并行和并发<a hidden class=anchor aria-hidden=true href=#区分并行和并发>#</a></h2><p>这个已经被说烂的话题为什么我还要拿出来说呢？（因为书里写了，bushi）因为自己对其的理解还不够深刻。英文中并行通常是 Parallelism,并发是 Concurrency.</p><blockquote><p>Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once.</p></blockquote><p>从这句名言可以看出，<strong>并发是一种组织结构上的概念，而并行是一种执行上的概念</strong>。（这个思想很重要）</p><p>同时我们抛出一个问题：<em>同样的程序，并发就一定并行要快吗？</em></p><p>在回答这个问题之前，我们应该先了解 Go 中关于并发和并行的常见概念，也就是 goroutine 与 GMP 调度模型。</p><h3 id=goroutine>goroutine<a hidden class=anchor aria-hidden=true href=#goroutine>#</a></h3><p>在我们学的操作系统课程中，通常用线程thread 描述并发，进程描述并行；但是作为 Go 程序员，我们通常用 goroutine 描述并发，thread描述操作系统线程。</p><ul><li>goroutine 可以被视作应用级别的 threads，所以这是一种来自于<strong>用户态的调度</strong></li><li>相当于又把 thread 往里“剥”了一层</li></ul><p>那为什么要搞一个 goroutine 出来呢？</p><ul><li><strong>thread 直接由 OS 管理</strong>，占用空间大，系统调用和线程调度过程中上下文切换资源消耗大，并且受到 CPU 资源限制，同步问题处理复杂</li><li><strong>goroutine 由 Go runtime 管理</strong>，占用空间极小（2KB）；运行时的调度器可以将N个 goroutine 映射到 M 个 thread 上，消耗小；Go 提供 context,channel机制处理同步问题容易</li></ul><h3 id=gmp模型>GMP模型<a hidden class=anchor aria-hidden=true href=#gmp模型>#</a></h3><p>上面提到了调度器的作用，其实就是 Go 的调度模型 GMP（这里简单提及，后续会出文章深究）</p><ul><li>G-Goroutine</li><li>M-OS thread</li><li>P-CPU core</li></ul><p>形象的理解就是 M 作为服务员，通过 P 来服务许多的顾客 G，而管理员就是 Goruntime.</p><p>每个 goroutine 都有三个状态（类似于 thread 的几个状态,但比其简单）</p><ul><li>Executing</li><li>Runnable</li><li>Waiting</li></ul><p>还有一个重要概念，这里简单提一嘴：GOMAXPROCS——<strong>代表着默认M的数量，同时也是最多有多少 goroutine 同时处于 Executing 状态。</strong></p><blockquote><p>GOMAX-PROCS is by default equal to the number of available CPU cores；GOMAX-PROCS can be changed and can be less than the number of CPU cores</p></blockquote><p>最后再简单说说 GoRuntime 是怎么调度以保证并发效率的。</p><p>采用队列保存 goroutine,有本地队列也有全局队列。
遇到自身没有 goroutine 的时候会进行 <strong>work stealing</strong>,从其他的队列偷一半过来保证并发效率。</p><p><img alt=gmp loading=lazy src=/img/golangPic/gmp01.png></p><h3 id=并发一定快吗>并发一定快吗？<a hidden class=anchor aria-hidden=true href=#并发一定快吗>#</a></h3><p>好了，补充了这么多了，希望大家没有忘记上面提出的问题，并发的写法一定比顺序的快吗？</p><p>以书中的例子——归并排序举例。
因为归并排序每次将元素分为长度相同的两半，直到无法分，然后又对分出的这些内容进行排序，最后组合在一起（形成了一个树形结构）</p><p>如果我们用 goroutine，大概是这样的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>MergesortV1</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>middle</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nf>MergesortV1</span><span class=p>(</span><span class=nx>s</span><span class=p>[:</span><span class=nx>middle</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span> 
</span></span><span class=line><span class=cl>        <span class=nf>MergesortV1</span><span class=p>(</span><span class=nx>s</span><span class=p>[</span><span class=nx>middle</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nf>merge</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=nx>middle</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>结果发现，并发反而要比顺序要慢，这是为什么呢？</p><ul><li>还记得我们一开始就说过，并发是一种组织结构，是需要调度的，调度是需要开销的。</li><li>尽管我们已经用了 goroutine 这样一个开销较小的结构，但是对于归并排序，每次把元素划分地太小了，导致每一个任务的开销甚至不如调度的开销，所以并发更加耗时。</li></ul><p>如何解决这个问题？很明显是 <strong>workload</strong> 的缘故，所以我们可以设置一个 workload 的 threshhold,不够这个门槛的顺序执行，超过的并发执行。</p><h2 id=并发引起的数据竞争>并发引起的数据竞争<a hidden class=anchor aria-hidden=true href=#并发引起的数据竞争>#</a></h2><p>在上面我们引入了 goroutine 并讨论了 golang 中的并发与并行。接下来讨论常见的数据竞争问题。</p><p>首先要明确一点：<strong>goroutine 虽然已经创建，但不一定立刻调度运行</strong>（Go 的调度器不保证立即运行）也就是我们写的代码的顺序并不是真正的执行顺序。</p><p>众所周知，数据竞争一直是并发问题下绕不开的话题。Go 中使用 goroutine 这种更小的结构更应该讨论如何面对数据竞争。
同时 Go 也为我们提供了一个运行时参数<code>-race</code>来检查我们的代码中是否有数据竞争问题。</p><p>那我们就来看看 Go 是如何避免数据竞争的。
Go的标准库 <strong>sync</strong> 下就有一些准备好的方法。</p><h3 id=atomic>atomic<a hidden class=anchor aria-hidden=true href=#atomic>#</a></h3><p>从单词意思就可以看出来，原子化——不能被打断的操作。<code>atomic.AddInt64(&amp;i, 1)</code>
需要注意的是，其只能作用于具体类型，不能用于像 slices,maps,structs这样的结构。（并且还得指明bit位数）</p><h3 id=mutex>mutex<a hidden class=anchor aria-hidden=true href=#mutex>#</a></h3><p>这就类似于操作系统课程中的锁，mutex可以主动给数据区上锁打造临界区，这样自然可以处理数据冲突问题。<code>mutex.Lock()</code></p><p>但是可能会发生死锁问题——死锁发生的根本原因是所有 goroutine 都被阻塞，没有任何一个能推进程序的执行。
特别是 main 中的被阻塞，而其他的 goroutine还没来得及启动时，那一定会都堵在那里。</p><h3 id=channel>channel<a hidden class=anchor aria-hidden=true href=#channel>#</a></h3><p>同时，我们也可以用 channel处理数据竞争，关于其底层原理，见我的<a href=https://www.bfsmlt.top/posts/007golangep02_%E5%B9%B6%E5%8F%9102chan/>文章</a>.</p><p>这里我们使用的是无缓冲的 channel，因为无缓冲型有一个特点是其必须存在一对接收方与发送方，如果少了其中之一，这个通道就会阻塞。
所以无缓冲的通道具有很强的同步一致性。</p><p>有缓冲也可以，但是需要我们进行额外设计。</p><h3 id=区分mutex与channel>区分mutex与channel<a hidden class=anchor aria-hidden=true href=#区分mutex与channel>#</a></h3><p>区分mutex与channel,二者最本质的区别是前者强调<strong>上锁形成一个临界区</strong>，而后者强调不同 goroutine 之间的<strong>通信协作</strong>。</p><ul><li><code>mu.Lock(),mu.Unlock()</code>保护共享的内存</li><li><code>ch &lt;-1, &lt;-ch</code>发送给通道，通道接收</li></ul><p>在 Golang 中有一个原则是：<strong>不要通过共享内存来通信，而应该通过通信来共享内存</strong></p><h3 id=区分data-race和race-condition>区分data race和race condition<a hidden class=anchor aria-hidden=true href=#区分data-race和race-condition>#</a></h3><p>解决了数据竞争程序就可以一定按照我们想要的顺序执行吗？不一定。例如</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=nx>mutex</span> <span class=o>:=</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>mutex</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>mutex</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>i</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=p>}()</span>
</span></span><span class=line><span class=cl><span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>mutex</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>mutex</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>i</span> <span class=p>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=p>}()</span>
</span></span></code></pre></div><p>很明显，没有数据竞争问题，但是最终结果会是1还是2？得看两个协程的运行先后顺序了。</p><blockquote><p>A data race occurs when multiple goroutines simultaneously access the same memory location and at least one of them is writing.
An application can be free of data races but still have behavior that depends on uncontrolled events (such as goroutine execution, how fast a message is published to a channel, or how long a call to a data-base lasts); this is a race condition.</p></blockquote><p>可见 mutex 无法解决执行顺序问题，但是 channel 可以，它的核心思想一直是通过通信来共享数据，而不是通过共享数据来通信。
所以我们可以通过channel解决，第二个操作需要等待第一个操作完成（对其阻塞）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=nx>done1</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span> <span class=c1>// 用于通知第一个 goroutine 已完成</span>
</span></span><span class=line><span class=cl><span class=nx>done2</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span> <span class=c1>// 用于通知第二个 goroutine 已完成</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>i</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nb>close</span><span class=p>(</span><span class=nx>done1</span><span class=p>)</span> <span class=c1>// 通知第一个操作已完成</span>
</span></span><span class=line><span class=cl><span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;-</span><span class=nx>done1</span> <span class=c1>// 等待第一个操作完成</span>
</span></span><span class=line><span class=cl>    <span class=nx>i</span> <span class=p>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=nb>close</span><span class=p>(</span><span class=nx>done2</span><span class=p>)</span> <span class=c1>// 通知第二个操作已完成</span>
</span></span><span class=line><span class=cl><span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>&lt;-</span><span class=nx>done2</span> <span class=c1>// 等待所有操作完成</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span> <span class=c1>// 保证输出 2</span>
</span></span></code></pre></div><p>具体原理简单解释一下：如果 done1 通道阻塞了，第二个 goroutine会被挂起并加入到接收等待队列，调度器会将其移出可运行队列，并切换其他协程，直到被唤醒。</p><h3 id=go内存模型>Go内存模型<a hidden class=anchor aria-hidden=true href=#go内存模型>#</a></h3><p>上面的执行顺序问题其实在 Go 的内存模型中就已经定义过了。称为多 goroutine 并发操作时的执行顺序规则。
关键在于 <strong>happens-before</strong> 关系。规定哪些操作必须发生在另一些操作之前。</p><p>1.channel 的发送操作在<strong>接收完成</strong>之前
1.底层用锁和等待队列实现。
2.close 先于所有“因关闭而返回”的接收操作
1.这样就不会出现关闭后仍能接收的情况
3.<strong>无缓冲</strong>的 channel 接收操作先于<strong>发送完成</strong>（这一点有些难理解）
1.就是我们说的接收和发送是一对操作，如果没有准备好的发送，接收就会阻塞</p><h2 id=goroutine泄漏问题>goroutine泄漏问题<a hidden class=anchor aria-hidden=true href=#goroutine泄漏问题>#</a></h2><p>Context在并发中也是十分重要的一环，用于控制生命周期，具体见<a href=https://www.bfsmlt.top/posts/005golangep01_%E5%B9%B6%E5%8F%9101_context/>这篇文章</a>.最后我们来说一下一个常见问题: goroutine的泄漏——某些 goroutine 在预期之外长期运行或阻塞，无法被回收，导致内存和 CPU 资源浪费，甚至程序崩溃（其实阻塞有时就是死锁）。</p><ul><li>无缓冲 channel 阻塞：我们之前一直强调 channel 要是成对出现的，如果永久阻塞就会泄漏</li><li>未关闭 channel 导致接收者阻塞</li><li>无限循环的：增加退出条件，例如 <code>ctx.Done()</code></li><li>未处理的 select 分支:最终原因也是堵塞</li></ul><p>为了解决堵塞，我们推荐使用有缓冲的 channel，确保关闭通道，使用 context 来控制生命周期，使用 select（case）+default分支结构。</p><h2 id=区分-io密集型和cpu密集型任务>区分 I/O密集型和CPU密集型任务<a hidden class=anchor aria-hidden=true href=#区分-io密集型和cpu密集型任务>#</a></h2><p>I/O 密集型任务：网络请求，文件操作，数据库访问。
CPU 密集型任务：数学计算，图像处理等。</p><p>由于 Go 的调度依赖运行时，之前我们提到他是在用户态的调度，所以<strong>上下文的切换成本</strong>比 thread 要低得多。于是可以创建数十万级别的 goroutine.
如果有10000个HTTP请求，他就可以开10000个 goroutine，而由于调度器的存在（GMP模型）实际上只需要少量的 OS thread。
其通信模型 channel 也十分适合这类型的任务。</p><p>但是到了 CPU 密集型任务，就得靠 GOMAXPROCS 这个参数了，它是实打实的表征着正在运行的 thread数量，Gol 对于这类任务并没有体现出更优的性能，C/C++ 也许更为合适。</p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>Go 依靠其独特的 goroutine、channel、context结构，展现出优异的并发能力（特别是在I/O密集型任务上）
Go 的核心理念是：<strong>不要通过共享内存来通信，而是通过通信来共享内存</strong></p><p><strong>这里是LTX，感谢您阅读这篇博客，人生海海，和自己对话，像只蝴蝶纵横四海。</strong></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://LTXWorld.github.io/tags/golang/>Golang</a></li><li><a href=https://LTXWorld.github.io/tags/%E6%BA%90%E7%A0%81/>源码</a></li><li><a href=https://LTXWorld.github.io/tags/%E5%B9%B6%E5%8F%91/>并发</a></li></ul><nav class=paginav><a class=prev href=https://LTXWorld.github.io/posts/032k3sep07%E9%85%8D%E7%BD%AE%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E5%87%86%E5%A4%87%E6%9E%84%E5%BB%BA%E8%B7%A8%E6%9E%B6%E6%9E%84%E9%95%9C%E5%83%8F/><span class=title>« 上一页</span><br><span>K3sEP07——配置私有镜像仓库准备构建跨架构镜像</span>
</a><a class=next href=https://LTXWorld.github.io/posts/029%E6%AF%8F%E6%9C%88%E6%94%B6%E6%94%AF%E5%9B%9E%E9%A1%BEep01-25_04/><span class=title>下一页 »</span><br><span>每月收支回顾EP01_25年</span></a></nav></footer><div id=tw-comment></div><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="light"?"light":"dark",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const s={src:"https://giscus.app/client.js","data-repo":"LTXWorld/LTXWorld.github.io","data-repo-id":"R_kgDONODUuA","data-category":"Announcements","data-category-id":"DIC_kwDONODUuM4CkMUw","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"zh-CN","data-loading":"lazy",crossorigin:"anonymous"},e=document.createElement("script");Object.entries(s).forEach(([t,n])=>e.setAttribute(t,n)),document.querySelector("#tw-comment").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme);const n=document.querySelector("#theme-toggle-float");n&&n.addEventListener("click",setGiscusTheme)})</script></article></main><footer class=footer><span><a href=https://LTXWorld.github.io/>©2025 LTX&rsquo;s Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><div class=ltx-music-player id=ltx-music-player role=group aria-label=背景音乐播放器><audio id=ltx-music-audio preload=metadata></audio><div class=ltx-drag-handle data-role=drag-handle title=上下拖动调整位置></div><div class=ltx-music-header><div class=ltx-music-visual><div class=ltx-disc data-role=disc aria-hidden=true><img data-role=cover alt loading=lazy decoding=async><div class=ltx-disc-center></div></div></div><div class=ltx-music-meta><span class=ltx-music-title data-role=title></span>
<span class=ltx-music-artist data-role=artist></span></div><button type=button class=ltx-music-hide data-action=collapse aria-label=隐藏播放器>&#215;</button></div><div class=ltx-music-progress data-role=progress aria-label=进度条 role=slider><div class=ltx-music-progress-fill data-role=progress-fill></div></div><div class=ltx-music-time><span data-role=current>0:00</span>
<span data-role=total>--:--</span></div><div class=ltx-music-controls><button type=button data-action=prev aria-label=上一首>⏮</button>
<button type=button data-action=toggle aria-label=播放或暂停>
<span data-icon=play>▶</span>
<span data-icon=pause>⏸</span>
</button>
<button type=button data-action=next aria-label=下一首>⏭</button>
<button type=button data-action=mute aria-label=静音或取消静音>
<span data-icon=unmuted>🔊</span>
<span data-icon=muted>🔇</span></button></div><div class=ltx-autoplay-tip data-role=tip aria-live=polite></div></div><button type=button class=ltx-music-fab id=ltx-music-fab aria-label=显示音乐播放器>&#9835;</button>
<script>window.LTX_MUSIC_CONFIG={autoplay:!0,defaultCover:"",loopPlaylist:!0,startVolume:.6,tracks:[{artist:"王力宏",file:"/audio/02 - 依然爱你.mp3",title:"依然爱你"},{artist:"王力宏",file:"/audio/05 - 改变自己.mp3",title:"改变自己"},{artist:"王力宏",file:"/audio/11 - 爱错.mp3",title:"爱错"}]},function(){const a=window.LTX_MUSIC_CONFIG||{};if(!a.tracks||!a.tracks.length)return;const e=document.getElementById("ltx-music-player"),t=e.querySelector("audio"),x=e.querySelector('[data-role="title"]'),O=e.querySelector('[data-role="artist"]'),b=e.querySelector('[data-role="progress"]'),A=e.querySelector('[data-role="progress-fill"]'),F=e.querySelector('[data-role="current"]'),M=e.querySelector('[data-role="total"]'),c=e.querySelector('[data-role="tip"]'),r=e.querySelector('[data-role="cover"]'),S=e.querySelector('[data-action="toggle"]'),y=e.querySelector('[data-action="prev"]'),k=e.querySelector('[data-action="next"]'),E=e.querySelector('[data-action="mute"]'),g=e.querySelector('[data-action="collapse"]'),i=e.querySelector('[data-role="drag-handle"]'),o=document.getElementById("ltx-music-fab"),f=(e,t,n)=>Math.min(Math.max(e,t),n),j=e=>{if(!Number.isFinite(e))return"--:--";const t=Math.floor(e/60),n=Math.floor(e%60);return`${String(t).padStart(1,"0")}:${String(n).padStart(2,"0")}`},C=-120,_=220,w=180,s={active:!1,startY:0,startOffset:0,pointerId:null},n={index:0,tracks:a.tracks,autoplay:a.autoplay!==!1,loopPlaylist:a.loopPlaylist!==!1,offset:0,collapsed:!1},h=t=>{n.offset=f(t,C,_),e.style.setProperty("--ltx-offset",`${n.offset}px`)},l=t=>{const s=Boolean(t);n.collapsed=s,e.classList.toggle("ltx-collapsed",s),s?(e.classList.remove("ltx-dragging"),n.offset=0,e.style.removeProperty("--ltx-offset"),o&&(o.classList.add("ltx-visible"),o.setAttribute("aria-hidden","false"),o.tabIndex=0)):(h(0),o&&(o.classList.remove("ltx-visible"),o.setAttribute("aria-hidden","true"),o.tabIndex=-1))},m=()=>{const n=t.muted||t.volume===0;e.classList.toggle("ltx-muted",n)};t.volume=f(a.startVolume??.6,0,1),m(),l(!1);const d=()=>{const e=t.duration||0,n=t.currentTime||0,s=e?n/e*100:0;A.style.width=`${s}%`,F.textContent=j(n),M.textContent=j(e)},u=(s,o={})=>{const l=n.tracks.length;n.index=(s%l+l)%l;const i=n.tracks[n.index];if(!i||!i.file){console.warn("LTX music player: 音频文件缺失",i),c.textContent="音频文件缺失，请检查配置";return}const u=i.cover||a.defaultCover||"";r&&(u?(r.src=u,r.alt=i.title?`${i.title} 封面`:"音乐封面",e.classList.add("ltx-has-cover")):(r.removeAttribute("src"),r.alt="",e.classList.remove("ltx-has-cover"))),x.textContent=i.title||`Track ${n.index+1}`,O.textContent=i.artist||"",t.src=i.file,e.dataset.trackIndex=n.index,c.textContent="",e.classList.remove("ltx-autoplay-blocked"),d(),o.play&&p()},p=()=>{t.play().then(()=>{e.classList.remove("ltx-autoplay-blocked"),c.textContent=""}).catch(()=>{e.classList.add("ltx-autoplay-blocked"),c.textContent="浏览器阻止了自动播放，请点击播放按钮"})},v=(e=!1)=>{const o=!t.paused||e,s=n.index+1;if(s>=n.tracks.length&&!n.loopPlaylist){t.currentTime=t.duration||0,t.pause();return}u(s,{play:o})},T=()=>{const e=!t.paused;u(n.index-1,{play:e})};if(g&&g.addEventListener("click",()=>l(!0)),o&&(o.addEventListener("click",()=>l(!1)),o.setAttribute("aria-hidden","true"),o.tabIndex=-1),i){i.style.touchAction="none",i.addEventListener("pointerdown",t=>{if(n.collapsed)return;if(s.active=!0,s.pointerId=t.pointerId,s.startY=t.clientY,s.startOffset=n.offset,i.setPointerCapture)try{i.setPointerCapture(t.pointerId)}catch{}e.classList.add("ltx-dragging")}),i.addEventListener("pointermove",e=>{if(!s.active)return;const t=e.clientY-s.startY;h(s.startOffset+t)});const t=()=>{if(!s.active)return;if(s.pointerId!==null&&i.releasePointerCapture)try{i.releasePointerCapture(s.pointerId)}catch{}s.active=!1,s.pointerId=null,e.classList.remove("ltx-dragging"),n.offset>w?l(!0):h(n.offset)};["pointerup","pointercancel"].forEach(e=>{i.addEventListener(e,t)}),i.addEventListener("pointerleave",()=>{if(!s.active)return;t()})}S.addEventListener("click",()=>{t.paused?p():t.pause()}),y.addEventListener("click",T),k.addEventListener("click",()=>v(!1)),E.addEventListener("click",()=>{t.muted=!t.muted,m()}),b.addEventListener("click",e=>{const n=b.getBoundingClientRect(),s=f((e.clientX-n.left)/n.width,0,1);Number.isFinite(t.duration)&&(t.currentTime=s*t.duration)}),t.addEventListener("timeupdate",d),t.addEventListener("loadedmetadata",d),t.addEventListener("play",()=>{e.classList.add("ltx-playing"),e.classList.remove("ltx-autoplay-blocked"),c.textContent=""}),t.addEventListener("pause",()=>{e.classList.remove("ltx-playing")}),t.addEventListener("ended",()=>{v(!0)}),t.addEventListener("volumechange",m),u(0,{play:n.autoplay})}()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>