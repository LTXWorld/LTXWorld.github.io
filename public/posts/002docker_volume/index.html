<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>玩转Docker系列——数据持久化 | LTX&#39;s Blog</title>
<meta name="keywords" content="容器, docker">
<meta name="description" content="Docker_Storage

大家好我是LTX，我猜在使用docker时你或多或少都会有疑问，我的数据被存到哪里去了？（什么?你不用docker?，滚出克😡）docker化之后为什么得到的镜像这么小，比我原始的程序要小这么多？特别是如果我将Mysql容器化，那它保存的记录都去哪里了？">
<meta name="author" content="LTX">
<link rel="canonical" href="https://LTXWorld.github.io/posts/002docker_volume/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.dddcf8236b9dfa07cf7fc41c31965e89e4a220be850d3a2a97c6101480c078a9.css" integrity="sha256-3dz4I2ud&#43;gfPf8QcMZZeieSiIL6FDToql8YQFIDAeKk=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://LTXWorld.github.io/favicon.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://LTXWorld.github.io/favicon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://LTXWorld.github.io/favicon.png">
<link rel="apple-touch-icon" href="https://LTXWorld.github.io/favicon.png">
<link rel="mask-icon" href="https://LTXWorld.github.io/favicon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://LTXWorld.github.io/posts/002docker_volume/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">
<script type="text/javascript"

        async

        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">

MathJax.Hub.Config({

  tex2jax: {

    inlineMath: [['$','$'], ['\\(','\\)']],

    displayMath: [['$$','$$'], ['\[\[','\]\]']],

    processEscapes: true,

    processEnvironments: true,

    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],

    TeX: { equationNumbers: { autoNumber: "AMS" },

         extensions: ["AMSmath.js", "AMSsymbols.js"] }

  }

});


MathJax.Hub.Queue(function() {

    

    

    

    var all = MathJax.Hub.getAllJax(), i;

    for(i = 0; i < all.length; i += 1) {

        all[i].SourceElement().parentNode.className += ' has-jax';

    }

});

</script>


<style>

code.has-jax {

    font: inherit;

    font-size: 100%;

    background: inherit;

    border: inherit;

    color: #515151;

}

</style><meta property="og:url" content="https://LTXWorld.github.io/posts/002docker_volume/">
  <meta property="og:site_name" content="LTX&#39;s Blog">
  <meta property="og:title" content="玩转Docker系列——数据持久化">
  <meta property="og:description" content="Docker_Storage 大家好我是LTX，我猜在使用docker时你或多或少都会有疑问，我的数据被存到哪里去了？（什么?你不用docker?，滚出克😡）docker化之后为什么得到的镜像这么小，比我原始的程序要小这么多？特别是如果我将Mysql容器化，那它保存的记录都去哪里了？">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-11-18T18:49:09+08:00">
    <meta property="article:modified_time" content="2024-11-18T18:49:09+08:00">
    <meta property="article:tag" content="容器">
    <meta property="article:tag" content="Docker">
      <meta property="og:image" content="https://LTXWorld.github.io/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://LTXWorld.github.io/images/papermod-cover.png">
<meta name="twitter:title" content="玩转Docker系列——数据持久化">
<meta name="twitter:description" content="Docker_Storage

大家好我是LTX，我猜在使用docker时你或多或少都会有疑问，我的数据被存到哪里去了？（什么?你不用docker?，滚出克😡）docker化之后为什么得到的镜像这么小，比我原始的程序要小这么多？特别是如果我将Mysql容器化，那它保存的记录都去哪里了？">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://LTXWorld.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "玩转Docker系列——数据持久化",
      "item": "https://LTXWorld.github.io/posts/002docker_volume/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "玩转Docker系列——数据持久化",
  "name": "玩转Docker系列——数据持久化",
  "description": "Docker_Storage 大家好我是LTX，我猜在使用docker时你或多或少都会有疑问，我的数据被存到哪里去了？（什么?你不用docker?，滚出克😡）docker化之后为什么得到的镜像这么小，比我原始的程序要小这么多？特别是如果我将Mysql容器化，那它保存的记录都去哪里了？\n",
  "keywords": [
    "容器", "docker"
  ],
  "articleBody": "Docker_Storage 大家好我是LTX，我猜在使用docker时你或多或少都会有疑问，我的数据被存到哪里去了？（什么?你不用docker?，滚出克😡）docker化之后为什么得到的镜像这么小，比我原始的程序要小这么多？特别是如果我将Mysql容器化，那它保存的记录都去哪里了？\n今天我将进入Docker_Volumes的世界，与大家聊聊Docker是如何处理数据持久化的。\n秉持着STFW\u0026RTFM的精神，我从官方的手册看起，并且辅助以测试实验来验证手册中的理论，设计实验部分使用了部分AI工具辅助。\n本机环境:macos15.1，Docker version 27.2.0, build 3ab4256\nStorage 手册中一开始就说明了默认情况下，容器内部创建的所有文件都存储在可写容器层上(详见docker基础原理)，这意味着，当该容器不存在时，数据不会持久化。\n那不会持久化可不行啊，我MYSQL关键点之一就是持久化啊，另一个容器要用我的数据结果你取不出来锁在容器里面了，这两个容器交互不就完犊子了吗？不行不行，得有个办法来实现数据的持久化，要不然我docker还怎么立足于容器生态江湖。\n并且更蛋疼的是容器的可写层与运行容器的主机紧密耦合，难以轻易地将数据移动到其他地方。这是因为可写层是容器运行时基于主机环境创建的一种临时存储结构，它的存在依赖于容器的运行状态，不像独立于容器的存储机制那样便于迁移数据。\n其实就是docker底层需要一个虚拟机运行嘛(见docker基础原理)，我们在主机上当然无法直接访问这个虚拟机，那我数据呢!?我想要让其他的人也用用啊！\ndocker设计者也当然为我想到了这种情况，于是他提供了两种解决方法：\n数据持久化到主机的磁盘上 数据持久化到主机的内存中 嘿，怎么有点Mysql的感觉了？扯远了，第一种解决方法又详细地分为了卷挂载和绑定挂载，至于这三者有何区别，且看手册中这张图片： 哈哈，你以为我要开始长篇大论了，别急，让我们先对这张图片有个印象就好，观察到三者的不同就行，我先得设计个实验来验证上面的默认不可持久化！\nlib01 首先，打开终端，(其实docker也提供了非常好用的GUI但我就想用Terminal)，运行一个简单的容器命名为test1,并进入到其中。\ndocker run -it --name test1 ubuntu:latest bash 在容器内部执行命令新建文件并写入测试内容作为测试数据。\necho \"Test data in container layer\" \u003e /test_file.txt 检查内容是否成功写入并退出容器。\ncat /test_file.txt exit 使用同一个镜像来新建另一个容器，重复上述步骤查看指定文件是否存在\ndocker run -it --name test2 ubuntu:latest bash ls | grep test_file.txt 发现并不存在这个文件，证明当容器不存在时，在可写容器层创建的文件数据不会持久保存。\n并且我们也无法从主机上直接访问这个文件，发现无法通过常规的主机文件系统路径找到该文件。\nVolumes 那么我们来看设计师们提供的第一种方法，也是最推荐的方法——Volumes。\n如果让我用三句话来总结Volumes:在docker host中开辟一片空间，将容器使用的数据挂载到这片空间中；整个过程以及后续的操作都由docker自动管理；便于在不同的容器之间共享数据。\n形象地解释就是容器将保存的数据从容器内部移到了docker host（即宿主机）中，每次需要的时候带上（挂载）就行。\n哇哦，这么牛逼?!一次就实现了持久化和共享操作？操作一下看看怎么个事！ lib02 持久性验证 # 创建名为my_volume的卷 docker volume create --name my_volume # 运行一个简单的容器并挂载这个卷 docker run -it -v my_volume:/app/data --name test3 ubuntu:latest bash # 使检查是否能够访问这个卷中的内容 ls /app/data cat /app/data/test.txt # 退出容器，从Docker角度检查卷内容 exit docker volume inspect my_volume 显示结果为\n# cat结果 Hello from container # inspect结果 [ { \"CreatedAt\": \"2024-11-18T09:59:02Z\", \"Driver\": \"local\", \"Labels\": null, \"Mountpoint\": \"/var/lib/docker/volumes/my_volume/_data\", \"Name\": \"my_volume\", \"Options\": null, \"Scope\": \"local\" } ] 重启启动一个新的容器，挂载my_volume卷并检查在不在，步骤除了容器命名不同以外都与上面一致。\n最终可以发现，这里的持久性指的就是这个my_volume永久地保存在了docker host中，想要用的时候挂载它就好了！\n多个容器共享卷验证 启动两个容器挂载同一个卷，保持着两个容器都处于运行状态，这里我就刚好拿上面两个容器做示范了。\n# 在第一个容器中修改test.txt中的内容，在第二个容器中观察内容是否发生变化 echo \"Updated from container 1\" \u003e\u003e /app/data/test.txt # 最终观察到内容为 Hello from container Updated from container 1 显然，这个卷中的内容的更改影响到了两个挂载到它的不同容器（诶，这里面是不是就会存在一些数据冲突并发问题？）\nBind mounts 哇哦，卷挂载这么厉害啊，那再看看设计者提供的第二种方案：绑定挂载。\n如果让我用三句话来总结绑定挂载：将数据文件挂载到宿主机文件系统中，使用宿主机的绝对路径并由我们自己全权管理整个过程。\n诶，这和卷挂载的区别不就很明显了嘛，卷挂载存储的文件路径是由Docker自动设置的而绑定挂载是由我们决定的。\nlib03 测试绑定挂载\n# 在本机上创建测试文件夹和测试文件 mkdir -p /host_test_dir \u0026\u0026 cd /host_test_dir echo \"Initial content from host\" \u003e host_file.txt # 挂载这个文件夹启动一个容器,注意，这里必须是在宿主机上的绝对路径 docker run -it -v /$HOME/host_test_dir/:/container_test_dir --name test5 ubuntu:latest bash # 检查文件 cat /container_test_dir/host_file.txt tmpfs 最后一种方法自然是将数据保存在宿主机的内存中，但众所周知保存在内存中只是一种临时的解决方案，毕竟宿主机关闭后数据就会消失。\n如何选择 那么，在卷挂载和绑定挂载之间该如何选择呢？其实从二者的特点就可以很明显看出docker的设计者想让我们用哪个，没错，一定是卷挂载——因为卷挂载的过程是由docker管理的，而绑定是由我们自己管理的，这会带来什么影响呢？\n卷挂载：\n其存储位置在 Docker 主机上是被抽象化的。这意味着数据的存储与主机的文件系统结构解耦，即使主机的文件系统布局发生变化，如系统升级或者目录结构调整，卷中的数据依然可以被容器正常访问，因为Docker会维护卷的内部结构和数据存储路径。（至于为什么，我们稍后会进行实验验证） 卷的生命周期独立于容器。当一个容器停止或被删除时，卷仍然存在，并且可以被挂载到其他容器中，数据不会丢失 总的来说就两字：隔离 绑定挂载：\n使得容器对文件的访问依赖于主机的文件系统结构。如果主机上的绑定目录被移动、重命名或者删除，容器内的文件访问就会出现问题。 反过来，容器可以直接访问主机的文件系统路径，一个被攻破的容器（例如，容器内的应用存在安全漏洞）可能会利用绑定挂载的权限对主机文件进行未经授权的修改，包括修改重要的系统文件或者其他容器可能依赖的文件 关于卷挂载中发现的问题 Hold on,Hold on,我知道看到现在你一定会存在一些小问题，没错我在看官方手册时以及配合AI进行实验验证的过程中也存在了许多问题，比如：\nmy_volume创建的路径在哪里？ 如果我不显式地设置卷挂载呢？会有什么效果？ 我们先来回答第二个问题。\n匿名卷 继续做一个模拟测试实验。\n# 使用-v 但没有指定容器外的挂载路径，只有容器内部的路径 docker run -it -v /app/data --name test6 ubuntu:lat est bash # 查看卷列表 docker volume ls 可以发现除了my_volume这个显示的卷挂载之外还有一个一长串字符组成的卷，这个卷就是匿名卷，是Docker host为我们自动设置的一个随机的、唯一的卷名称。 特别需要注意的点是:\n匿名卷是与容器的生命周期紧密绑定的 显示的卷与容器的生命周期是隔离的 所以我们可以做个实验，删除掉test6这个容器，再使用docker volume ls查看卷信息，发现刚才创建的匿名卷不见了。\n路径问题 还记得我们之前使用过的docker volume inspect my_volume命令得到的路径结果\"Mountpoint\": \"/var/lib/docker/volumes/my_volume/_data\"\n直接在宿主机上找到这个路径不就得了？这里就要引出一个困扰了我的问题——为什么默认Docker host就是宿主机？这不是与“Docker在Windows或者macos系统上运行需要一个轻量的虚拟机”这一理念冲突了吗？具体解释见下方的附录\n那么该如何找到这个路径呢？Docker在主机上实际上是基于一个小型的虚拟机来运行的，所以我们得找到这个虚拟机，经过google，我找到了一种在macos上寻找虚拟机的方法\ndocker run -it --privileged --pid=host debian nsenter -t 1 -m -u -n -i sh cd /var/lib/docker/volumes 之后就可以在里面查看docker host中的卷以及卷内容了。\n总结 好了，那么关于Docker_Engine中的Storage的相关知识与模拟实验验证就到此结束了。\n总的来说，Docker采用了两种手段来实现存储的持久化，一种是卷挂载一种是绑定挂载，其中卷挂载更能体现出Docker的隔离性，也是设计者推荐的方法，相信看完本篇内容你会对Docker的数据存储有更深的理解！\n当然其中也挖了一些以后需要填的坑，日后再见！感谢您抽出宝贵的时间浏览这篇内容。\n这里是LTX，感谢您阅读这篇博客，人生海海，和自己对话，像只蝴蝶纵横四海。\n附录 Docker host 首先我们要明确两个点:\n遇到文档中Docker host这个叫法，指的就是运行Docker daemon守护进程的宿主机；比如我的macbook Docker在Linux上直接利用Linux内核来运行，在Windows和macos上运行需要一个额外的底层轻量虚拟机Hypervisor.Framwork,实现了对用户的透明化。 所以，我们使用卷挂载挂载的Volume名义上在宿主机里面，实际上真实的路径/var/lib/docker/volumes是在这个轻量的虚拟机中的。\n即使我觉得这很别扭，但是他就是这样的。总之你要知道Docker并不是独自的来到你的电脑上的，他要依靠Linux内核特性！他需要一个虚拟机来运行！（扯远了，这些需要另开一篇博客哈哈）😇\n",
  "wordCount" : "3732",
  "inLanguage": "zh",
  "image": "https://LTXWorld.github.io/images/papermod-cover.png","datePublished": "2024-11-18T18:49:09+08:00",
  "dateModified": "2024-11-18T18:49:09+08:00",
  "author":{
    "@type": "Person",
    "name": "LTX"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://LTXWorld.github.io/posts/002docker_volume/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "LTX's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://LTXWorld.github.io/favicon.png"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://LTXWorld.github.io/" accesskey="h" title="LTX&#39;s Blog (Alt + H)">LTX&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://LTXWorld.github.io/" title="LTX&#39;s Blog">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="https://LTXWorld.github.io/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://LTXWorld.github.io/categories/" title="Categories">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="https://LTXWorld.github.io/tags/" title="Tags">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://LTXWorld.github.io/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="https://LTXWorld.github.io/about/" title="后花园">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      玩转Docker系列——数据持久化
    </h1>
    <div class="post-meta"><span title='2024-11-18 18:49:09 +0800 CST'>十一月 18, 2024</span>&nbsp;·&nbsp;8 分钟&nbsp;·&nbsp;LTX

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#docker_storage" aria-label="Docker_Storage">Docker_Storage</a><ul>
                        
                <li>
                    <a href="#storage" aria-label="Storage">Storage</a><ul>
                        
                <li>
                    <a href="#lib01" aria-label="lib01">lib01</a></li></ul>
                </li>
                <li>
                    <a href="#volumes" aria-label="Volumes">Volumes</a><ul>
                        
                <li>
                    <a href="#lib02" aria-label="lib02">lib02</a></li></ul>
                </li>
                <li>
                    <a href="#bind-mounts" aria-label="Bind mounts">Bind mounts</a><ul>
                        
                <li>
                    <a href="#lib03" aria-label="lib03">lib03</a></li></ul>
                </li>
                <li>
                    <a href="#tmpfs" aria-label="tmpfs">tmpfs</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e9%80%89%e6%8b%a9" aria-label="如何选择">如何选择</a></li>
                <li>
                    <a href="#%e5%85%b3%e4%ba%8e%e5%8d%b7%e6%8c%82%e8%bd%bd%e4%b8%ad%e5%8f%91%e7%8e%b0%e7%9a%84%e9%97%ae%e9%a2%98" aria-label="关于卷挂载中发现的问题">关于卷挂载中发现的问题</a><ul>
                        
                <li>
                    <a href="#%e5%8c%bf%e5%90%8d%e5%8d%b7" aria-label="匿名卷">匿名卷</a></li>
                <li>
                    <a href="#%e8%b7%af%e5%be%84%e9%97%ae%e9%a2%98" aria-label="路径问题">路径问题</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a></li>
                <li>
                    <a href="#%e9%99%84%e5%bd%95" aria-label="附录">附录</a><ul>
                        
                <li>
                    <a href="#docker-host" aria-label="Docker host">Docker host</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="docker_storage">Docker_Storage<a hidden class="anchor" aria-hidden="true" href="#docker_storage">#</a></h1>
<p><img loading="lazy" src="/img/ys/%E6%99%9A%E4%B8%8A%E5%A5%BD%E5%85%84%E5%BC%9F%E4%BB%AC.jpg"></p>
<p>大家好我是LTX，我猜在使用docker时你或多或少都会有疑问，我的数据被存到哪里去了？（什么?你不用docker?，滚出克😡）docker化之后为什么得到的镜像这么小，比我原始的程序要小这么多？特别是如果我将Mysql容器化，那它保存的记录都去哪里了？</p>
<p>今天我将进入Docker_Volumes的世界，与大家聊聊Docker是如何处理数据持久化的。</p>
<p>秉持着STFW&amp;RTFM的精神，我从<a href="https://docs.docker.com/engine/storage/">官方的手册</a>看起，并且辅助以测试实验来验证手册中的理论，设计实验部分使用了部分AI工具辅助。</p>
<p>本机环境:macos15.1，Docker version 27.2.0, build 3ab4256</p>
<h2 id="storage">Storage<a hidden class="anchor" aria-hidden="true" href="#storage">#</a></h2>
<p>手册中一开始就说明了默认情况下，容器内部创建的所有文件都存储在可写容器层上(详见docker基础原理)，这意味着，<strong>当该容器不存在时，数据不会持久化。</strong></p>
<p>那不会持久化可不行啊，我MYSQL关键点之一就是持久化啊，另一个容器要用我的数据结果你取不出来锁在容器里面了，这两个容器交互不就完犊子了吗？不行不行，得有个办法来实现数据的持久化，要不然我docker还怎么立足于容器生态江湖。</p>
<p>并且更蛋疼的是容器的可写层与运行容器的主机紧密耦合，难以轻易地将数据移动到其他地方。<em>这是因为可写层是容器运行时基于主机环境创建的一种临时存储结构，它的存在依赖于容器的运行状态，不像独立于容器的存储机制那样便于迁移数据。</em></p>
<p>其实就是docker底层需要一个虚拟机运行嘛(见docker基础原理)，我们在主机上当然无法直接访问这个虚拟机，那我数据呢!?我想要让其他的人也用用啊！</p>
<p><img loading="lazy" src="/img/ys/%E4%BD%A0%E8%AF%B4%E4%BB%80%E4%B9%88.webp"></p>
<p>docker设计者也当然为我想到了这种情况，于是他提供了两种解决方法：</p>
<ul>
<li>数据持久化到主机的磁盘上</li>
<li>数据持久化到主机的内存中</li>
</ul>
<p>嘿，怎么有点Mysql的感觉了？扯远了，第一种解决方法又详细地分为了卷挂载和绑定挂载，至于这三者有何区别，且看手册中这张图片：
<img loading="lazy" src="/img/docker/volume1.png"></p>
<p>哈哈，你以为我要开始长篇大论了，别急，让我们先对这张图片有个印象就好，观察到三者的不同就行，我先得设计个实验来验证上面的默认不可持久化！</p>
<h3 id="lib01">lib01<a hidden class="anchor" aria-hidden="true" href="#lib01">#</a></h3>
<p>首先，打开终端，(其实docker也提供了非常好用的GUI但我就想用Terminal)，运行一个简单的容器命名为test1,并进入到其中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker run -it --name test1 ubuntu:latest bash
</span></span></code></pre></div><p>在容器内部执行命令新建文件并写入测试内容作为测试数据。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;Test data in container layer&#34;</span> &gt; /test_file.txt
</span></span></code></pre></div><p>检查内容是否成功写入并退出容器。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">cat /test_file.txt
</span></span><span class="line"><span class="cl"><span class="nb">exit</span>
</span></span></code></pre></div><p>使用同一个镜像来新建另一个容器，重复上述步骤查看指定文件是否存在</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker run -it --name test2 ubuntu:latest bash
</span></span><span class="line"><span class="cl">ls <span class="p">|</span> grep test_file.txt
</span></span></code></pre></div><p>发现并不存在这个文件，证明当容器不存在时，在可写容器层创建的文件数据不会持久保存。</p>
<p>并且我们也无法从主机上直接访问这个文件，发现无法通过常规的主机文件系统路径找到该文件。</p>
<h2 id="volumes">Volumes<a hidden class="anchor" aria-hidden="true" href="#volumes">#</a></h2>
<p>那么我们来看设计师们提供的第一种方法，也是最推荐的方法——Volumes。</p>
<p>如果让我用三句话来总结Volumes:在<a href="/posts/002docker_volume/#docker-host">docker host</a>中开辟一片空间，将容器使用的数据挂载到这片空间中；整个过程以及后续的操作都由docker自动管理；便于在不同的容器之间共享数据。</p>
<p>形象地解释就是容器将保存的数据从容器内部移到了docker host（即宿主机）中，每次需要的时候带上（挂载）就行。</p>
<p>哇哦，这么牛逼?!一次就实现了持久化和共享操作？操作一下看看怎么个事！
<img loading="lazy" src="/img/ys/%E6%8D%82%E5%98%B4%E6%86%8B%E7%AC%91.webp"></p>
<h3 id="lib02">lib02<a hidden class="anchor" aria-hidden="true" href="#lib02">#</a></h3>
<ol>
<li>持久性验证</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 创建名为my_volume的卷</span>
</span></span><span class="line"><span class="cl">docker volume create --name my_volume
</span></span><span class="line"><span class="cl"><span class="c1"># 运行一个简单的容器并挂载这个卷</span>
</span></span><span class="line"><span class="cl">docker run -it -v my_volume:/app/data --name test3 ubuntu:latest bash
</span></span><span class="line"><span class="cl"><span class="c1"># 使检查是否能够访问这个卷中的内容</span>
</span></span><span class="line"><span class="cl">ls /app/data
</span></span><span class="line"><span class="cl">cat /app/data/test.txt
</span></span><span class="line"><span class="cl"><span class="c1"># 退出容器，从Docker角度检查卷内容</span>
</span></span><span class="line"><span class="cl"><span class="nb">exit</span>
</span></span><span class="line"><span class="cl">docker volume inspect my_volume
</span></span></code></pre></div><p>显示结果为</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># cat结果</span>
</span></span><span class="line"><span class="cl">Hello from container
</span></span><span class="line"><span class="cl"><span class="c1"># inspect结果</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>
</span></span><span class="line"><span class="cl">    <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;CreatedAt&#34;</span>: <span class="s2">&#34;2024-11-18T09:59:02Z&#34;</span>,
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;Driver&#34;</span>: <span class="s2">&#34;local&#34;</span>,
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;Labels&#34;</span>: null,
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;Mountpoint&#34;</span>: <span class="s2">&#34;/var/lib/docker/volumes/my_volume/_data&#34;</span>,
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;Name&#34;</span>: <span class="s2">&#34;my_volume&#34;</span>,
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;Options&#34;</span>: null,
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;Scope&#34;</span>: <span class="s2">&#34;local&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">]</span>
</span></span></code></pre></div><p>重启启动一个新的容器，挂载my_volume卷并检查在不在，步骤除了容器命名不同以外都与上面一致。</p>
<p>最终可以发现，这里的持久性指的就是这个my_volume永久地保存在了docker host中，想要用的时候挂载它就好了！</p>
<ol start="2">
<li>多个容器共享卷验证</li>
</ol>
<p>启动两个容器挂载同一个卷，保持着两个容器都处于运行状态，这里我就刚好拿上面两个容器做示范了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 在第一个容器中修改test.txt中的内容，在第二个容器中观察内容是否发生变化</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;Updated from container 1&#34;</span> &gt;&gt; /app/data/test.txt
</span></span><span class="line"><span class="cl"><span class="c1"># 最终观察到内容为</span>
</span></span><span class="line"><span class="cl">Hello from container
</span></span><span class="line"><span class="cl">Updated from container <span class="m">1</span>
</span></span></code></pre></div><p>显然，这个卷中的内容的更改影响到了两个挂载到它的不同容器（诶，这里面是不是就会存在一些数据冲突并发问题？）</p>
<h2 id="bind-mounts">Bind mounts<a hidden class="anchor" aria-hidden="true" href="#bind-mounts">#</a></h2>
<p>哇哦，卷挂载这么厉害啊，那再看看设计者提供的第二种方案：绑定挂载。</p>
<p>如果让我用三句话来总结绑定挂载：将数据文件挂载到宿主机文件系统中，使用宿主机的绝对路径并由我们自己全权管理整个过程。</p>
<p>诶，这和卷挂载的区别不就很明显了嘛，卷挂载存储的文件路径是由Docker自动设置的而绑定挂载是由我们决定的。</p>
<h3 id="lib03">lib03<a hidden class="anchor" aria-hidden="true" href="#lib03">#</a></h3>
<p>测试绑定挂载</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 在本机上创建测试文件夹和测试文件</span>
</span></span><span class="line"><span class="cl">mkdir -p /host_test_dir <span class="o">&amp;&amp;</span> <span class="nb">cd</span> /host_test_dir
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;Initial content from host&#34;</span> &gt; host_file.txt
</span></span><span class="line"><span class="cl"><span class="c1"># 挂载这个文件夹启动一个容器,注意，这里必须是在宿主机上的绝对路径</span>
</span></span><span class="line"><span class="cl">docker run -it -v /<span class="nv">$HOME</span>/host_test_dir/:/container_test_dir --name test5 ubuntu:latest bash
</span></span><span class="line"><span class="cl"><span class="c1"># 检查文件</span>
</span></span><span class="line"><span class="cl">cat /container_test_dir/host_file.txt
</span></span></code></pre></div><h2 id="tmpfs">tmpfs<a hidden class="anchor" aria-hidden="true" href="#tmpfs">#</a></h2>
<p>最后一种方法自然是将数据保存在宿主机的内存中，但众所周知保存在内存中只是一种临时的解决方案，毕竟宿主机关闭后数据就会消失。</p>
<p><img loading="lazy" src="/img/ys/%E8%8D%AF%E6%B0%B4%E6%8C%A5%E6%8B%B3.webp"></p>
<h2 id="如何选择">如何选择<a hidden class="anchor" aria-hidden="true" href="#如何选择">#</a></h2>
<p>那么，在卷挂载和绑定挂载之间该如何选择呢？其实从二者的特点就可以很明显看出docker的设计者想让我们用哪个，没错，一定是卷挂载——因为卷挂载的过程是由docker管理的，而绑定是由我们自己管理的，这会带来什么影响呢？</p>
<p>卷挂载：</p>
<ul>
<li>其存储位置在 Docker 主机上是被抽象化的。这意味着数据的存储与主机的文件系统结构解耦，即使主机的文件系统布局发生变化，如系统升级或者目录结构调整，卷中的数据依然可以被容器正常访问，因为Docker会维护卷的内部结构和数据存储路径。（至于为什么，我们稍后会进行实验验证）</li>
<li>卷的生命周期独立于容器。当一个容器停止或被删除时，卷仍然存在，并且可以被挂载到其他容器中，数据不会丢失</li>
<li>总的来说就两字：<strong>隔离</strong></li>
</ul>
<p>绑定挂载：</p>
<ul>
<li>使得容器对文件的访问依赖于主机的文件系统结构。如果主机上的绑定目录被移动、重命名或者删除，容器内的文件访问就会出现问题。</li>
<li>反过来，容器可以直接访问主机的文件系统路径，一个被攻破的容器（例如，容器内的应用存在安全漏洞）可能会利用绑定挂载的权限对主机文件进行未经授权的修改，包括修改重要的系统文件或者其他容器可能依赖的文件</li>
</ul>
<h2 id="关于卷挂载中发现的问题">关于卷挂载中发现的问题<a hidden class="anchor" aria-hidden="true" href="#关于卷挂载中发现的问题">#</a></h2>
<p>Hold on,Hold on,我知道看到现在你一定会存在一些小问题，没错我在看官方手册时以及配合AI进行实验验证的过程中也存在了许多问题，比如：</p>
<ul>
<li>my_volume创建的路径在哪里？</li>
<li>如果我不显式地设置卷挂载呢？会有什么效果？</li>
</ul>
<p>我们先来回答第二个问题。</p>
<h3 id="匿名卷">匿名卷<a hidden class="anchor" aria-hidden="true" href="#匿名卷">#</a></h3>
<p>继续做一个模拟测试实验。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 使用-v 但没有指定容器外的挂载路径，只有容器内部的路径</span>
</span></span><span class="line"><span class="cl">docker run -it -v /app/data --name test6 ubuntu:lat
</span></span><span class="line"><span class="cl">est bash
</span></span><span class="line"><span class="cl"><span class="c1"># 查看卷列表</span>
</span></span><span class="line"><span class="cl">docker volume ls
</span></span></code></pre></div><p><img loading="lazy" src="/img/docker/anonomous_volumes.png"></p>
<p>可以发现除了my_volume这个显示的卷挂载之外还有一个一长串字符组成的卷，这个卷就是匿名卷，是Docker host为我们自动设置的一个随机的、唯一的卷名称。
特别需要注意的点是:</p>
<ul>
<li>匿名卷是与容器的生命周期紧密绑定的</li>
<li>显示的卷与容器的生命周期是隔离的</li>
</ul>
<p>所以我们可以做个实验，删除掉test6这个容器，再使用<code>docker volume ls</code>查看卷信息，发现刚才创建的匿名卷不见了。</p>
<h3 id="路径问题">路径问题<a hidden class="anchor" aria-hidden="true" href="#路径问题">#</a></h3>
<p>还记得我们之前使用过的<code>docker volume inspect my_volume</code>命令得到的路径结果<code>&quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my_volume/_data&quot;</code></p>
<p>直接在宿主机上找到这个路径不就得了？这里就要引出一个困扰了我的问题——为什么默认Docker host就是宿主机？这不是与“Docker在Windows或者macos系统上运行需要一个轻量的虚拟机”这一理念冲突了吗？具体解释见下方的<a href="/posts/002docker_volume/#%e9%99%84%e5%bd%95">附录</a></p>
<p>那么该如何找到这个路径呢？Docker在主机上实际上是基于一个小型的虚拟机来运行的，所以我们得找到这个虚拟机，经过google，我找到了一种<a href="https://stackoverflow.com/questions/38532483/where-is-var-lib-docker-on-mac-os-x">在macos上寻找虚拟机的方法</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker run -it --privileged --pid<span class="o">=</span>host debian nsenter -t <span class="m">1</span> -m -u -n -i sh
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> /var/lib/docker/volumes
</span></span></code></pre></div><p>之后就可以在里面查看docker host中的卷以及卷内容了。</p>
<p><img loading="lazy" src="/img/docker/varlib.png"></p>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<p>好了，那么关于Docker_Engine中的Storage的相关知识与模拟实验验证就到此结束了。</p>
<p>总的来说，Docker采用了两种手段来实现存储的持久化，一种是卷挂载一种是绑定挂载，其中卷挂载更能体现出Docker的隔离性，也是设计者推荐的方法，相信看完本篇内容你会对Docker的数据存储有更深的理解！</p>
<p>当然其中也挖了一些以后需要填的坑，日后再见！感谢您抽出宝贵的时间浏览这篇内容。</p>
<p><strong>这里是LTX，感谢您阅读这篇博客，人生海海，和自己对话，像只蝴蝶纵横四海。</strong></p>
<p><img loading="lazy" src="/img/ys/ye.webp"></p>
<h2 id="附录">附录<a hidden class="anchor" aria-hidden="true" href="#附录">#</a></h2>
<h3 id="docker-host">Docker host<a hidden class="anchor" aria-hidden="true" href="#docker-host">#</a></h3>
<p>首先我们要明确两个点:</p>
<ul>
<li>遇到文档中Docker host这个叫法，指的就是运行Docker daemon守护进程的宿主机；比如我的macbook</li>
<li>Docker在Linux上直接利用Linux内核来运行，在Windows和macos上运行需要一个<strong>额外的底层轻量虚拟机Hypervisor.Framwork</strong>,实现了对用户的透明化。</li>
</ul>
<p>所以，我们使用卷挂载挂载的Volume名义上在宿主机里面，实际上真实的路径<code>/var/lib/docker/volumes</code>是在这个轻量的虚拟机中的。</p>
<p>即使我觉得这很别扭，但是他就是这样的。总之你要知道Docker并不是独自的来到你的电脑上的，他要依靠Linux内核特性！他需要一个虚拟机来运行！（扯远了，这些需要另开一篇博客哈哈）😇</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://LTXWorld.github.io/tags/%E5%AE%B9%E5%99%A8/">容器</a></li>
      <li><a href="https://LTXWorld.github.io/tags/docker/">Docker</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://LTXWorld.github.io/posts/003li_riscv01/">
    <span class="title">« 上一页</span>
    <br>
    <span>玩转RISCV开发板01-烧录OpenEuler国产镜像</span>
  </a>
  <a class="next" href="https://LTXWorld.github.io/posts/001aithought/">
    <span class="title">下一页 »</span>
    <br>
    <span>AIThought01——让我尝试不依靠AI</span>
  </a>
</nav>

  </footer><div id="tw-comment"></div>

<script>

    

    const getStoredTheme = () => localStorage.getItem("pref-theme") === "light" ? "light" : "dark";

    const setGiscusTheme = () => {

        const sendMessage = (message) => {

            const iframe = document.querySelector('iframe.giscus-frame');

            if (iframe) {

                iframe.contentWindow.postMessage({giscus: message}, 'https://giscus.app');

            }

        }

        sendMessage({setConfig: {theme: getStoredTheme()}})

    }


    document.addEventListener("DOMContentLoaded", () => {

        const giscusAttributes = {

            "src": "https://giscus.app/client.js",

            "data-repo": "LTXWorld\/LTXWorld.github.io",

            "data-repo-id": "R_kgDONODUuA",

            "data-category": "Announcements",

            "data-category-id": "DIC_kwDONODUuM4CkMUw",

            "data-mapping": "pathname",

            "data-strict": "0",

            "data-reactions-enabled": "1",

            "data-emit-metadata": "0",

            "data-input-position": "bottom",

            "data-theme": getStoredTheme(),

            "data-lang": "zh-CN",

            "data-loading": "lazy",

            "crossorigin": "anonymous",

        };


        

        const giscusScript = document.createElement("script");

        Object.entries(giscusAttributes).forEach(

                ([key, value]) => giscusScript.setAttribute(key, value));

        document.querySelector("#tw-comment").appendChild(giscusScript);


        

        const themeSwitcher = document.querySelector("#theme-toggle");

        if (themeSwitcher) {

            themeSwitcher.addEventListener("click", setGiscusTheme);

        }

        const themeFloatSwitcher = document.querySelector("#theme-toggle-float");

        if (themeFloatSwitcher) {

            themeFloatSwitcher.addEventListener("click", setGiscusTheme);

        }

    });

</script>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://LTXWorld.github.io/">©2025 LTX&rsquo;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a><div class="ltx-music-player" id="ltx-music-player" role="group" aria-label="背景音乐播放器">
  <audio id="ltx-music-audio" preload="metadata"></audio>
  <div class="ltx-drag-handle" data-role="drag-handle" title="上下拖动调整位置"></div>
  <div class="ltx-music-header">
    <div class="ltx-music-visual">
      <div class="ltx-disc" data-role="disc" aria-hidden="true">
        <img data-role="cover" alt="" loading="lazy" decoding="async">
        <div class="ltx-disc-center"></div>
      </div>
    </div>
    <div class="ltx-music-meta">
      <span class="ltx-music-title" data-role="title"></span>
      <span class="ltx-music-artist" data-role="artist"></span>
    </div>
    <button type="button" class="ltx-music-hide" data-action="collapse" aria-label="隐藏播放器">&#215;</button>
  </div>
  <div class="ltx-music-progress" data-role="progress" aria-label="进度条" role="slider">
    <div class="ltx-music-progress-fill" data-role="progress-fill"></div>
  </div>
  <div class="ltx-music-time">
    <span data-role="current">0:00</span>
    <span data-role="total">--:--</span>
  </div>
  <div class="ltx-music-controls">
    <button type="button" data-action="prev" aria-label="上一首">⏮</button>
    <button type="button" data-action="toggle" aria-label="播放或暂停">
      <span data-icon="play">▶</span>
      <span data-icon="pause">⏸</span>
    </button>
    <button type="button" data-action="next" aria-label="下一首">⏭</button>
    <button type="button" data-action="mute" aria-label="静音或取消静音">
      <span data-icon="unmuted">🔊</span>
      <span data-icon="muted">🔇</span>
    </button>
  </div>
  <div class="ltx-autoplay-tip" data-role="tip" aria-live="polite"></div>
</div>
<button type="button" class="ltx-music-fab" id="ltx-music-fab" aria-label="显示音乐播放器">&#9835;</button>
<script>
  window.LTX_MUSIC_CONFIG = {"autoplay":true,"defaultCover":"","loopPlaylist":true,"startVolume":0.6,"tracks":[{"artist":"王力宏","file":"/audio/02 - 依然爱你.mp3","title":"依然爱你"},{"artist":"王力宏","file":"/audio/05 - 改变自己.mp3","title":"改变自己"},{"artist":"王力宏","file":"/audio/11 - 爱错.mp3","title":"爱错"}]};
  (function () {
    const config = window.LTX_MUSIC_CONFIG || {};
    if (!config.tracks || !config.tracks.length) {
      return;
    }

    const player = document.getElementById('ltx-music-player');
    const audio = player.querySelector('audio');
    const titleEl = player.querySelector('[data-role="title"]');
    const artistEl = player.querySelector('[data-role="artist"]');
    const progressEl = player.querySelector('[data-role="progress"]');
    const progressFillEl = player.querySelector('[data-role="progress-fill"]');
    const currentTimeEl = player.querySelector('[data-role="current"]');
    const totalTimeEl = player.querySelector('[data-role="total"]');
    const tipEl = player.querySelector('[data-role="tip"]');
    const coverEl = player.querySelector('[data-role="cover"]');

    const toggleBtn = player.querySelector('[data-action="toggle"]');
    const prevBtn = player.querySelector('[data-action="prev"]');
    const nextBtn = player.querySelector('[data-action="next"]');
    const muteBtn = player.querySelector('[data-action="mute"]');
    const collapseBtn = player.querySelector('[data-action="collapse"]');
    const dragHandle = player.querySelector('[data-role="drag-handle"]');
    const fabButton = document.getElementById('ltx-music-fab');

    const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
    const formatTime = (seconds) => {
      if (!Number.isFinite(seconds)) {
        return '--:--';
      }
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${String(mins).padStart(1, '0')}:${String(secs).padStart(2, '0')}`;
    };

    const minOffset = -120;
    const maxOffset = 220;
    const hideThreshold = 180;
    const dragState = { active: false, startY: 0, startOffset: 0, pointerId: null };
    const storageKey = 'ltx-music-player-state';

    const safeStorage = (() => {
      try {
        const probeKey = '__ltx_music_probe__';
        window.localStorage.setItem(probeKey, probeKey);
        window.localStorage.removeItem(probeKey);
        return window.localStorage;
      } catch (err) {
        console.warn('LTX music player: localStorage 不可用', err);
        return null;
      }
    })();

    const loadPersistedState = () => {
      if (!safeStorage) {
        return null;
      }
      try {
        const raw = safeStorage.getItem(storageKey);
        return raw ? JSON.parse(raw) : null;
      } catch (err) {
        console.warn('LTX music player: 读取历史播放状态失败', err);
        return null;
      }
    };

    const normalizeIndex = (index, total) => {
      if (!Number.isInteger(index) || !total) {
        return 0;
      }
      return ((index % total) + total) % total;
    };

    const savedState = loadPersistedState();

    const state = {
      index: 0,
      tracks: config.tracks,
      autoplay: config.autoplay !== false,
      loopPlaylist: config.loopPlaylist !== false,
      offset: 0,
      collapsed: false,
    };

    if (savedState) {
      if (state.tracks.length && Number.isInteger(savedState.trackIndex)) {
        state.index = normalizeIndex(savedState.trackIndex, state.tracks.length);
      }
      if (Number.isFinite(savedState.offset)) {
        state.offset = clamp(savedState.offset, minOffset, maxOffset);
      }
      if (typeof savedState.collapsed === 'boolean') {
        state.collapsed = savedState.collapsed;
      }
    }

    let lastPersistAt = 0;
    const persistState = (overrides = {}, immediate = false) => {
      if (!safeStorage) {
        return;
      }
      const snapshot = {
        trackIndex: state.index,
        currentTime: audio.currentTime || 0,
        isPlaying: !audio.paused,
        volume: audio.volume,
        muted: audio.muted,
        collapsed: state.collapsed,
        offset: state.offset,
        ...overrides,
      };
      const now = Date.now();
      if (!immediate && now - lastPersistAt < 800) {
        return;
      }
      lastPersistAt = now;
      try {
        safeStorage.setItem(storageKey, JSON.stringify(snapshot));
      } catch (err) {
        console.warn('LTX music player: 保存播放状态失败', err);
      }
    };

    const flushState = (overrides = {}) => persistState(overrides, true);

    const setOffset = (value, options = {}) => {
      state.offset = clamp(value, minOffset, maxOffset);
      player.style.setProperty('--ltx-offset', `${state.offset}px`);
      if (!options.silent) {
        persistState({ offset: state.offset });
      }
    };

    const setCollapsed = (value, options = {}) => {
      const collapsed = Boolean(value);
      state.collapsed = collapsed;
      player.classList.toggle('ltx-collapsed', collapsed);
      if (collapsed) {
        player.classList.remove('ltx-dragging');
        state.offset = 0;
        player.style.removeProperty('--ltx-offset');
        if (fabButton) {
          fabButton.classList.add('ltx-visible');
          fabButton.setAttribute('aria-hidden', 'false');
          fabButton.tabIndex = 0;
        }
      } else {
        setOffset(0);
        if (fabButton) {
          fabButton.classList.remove('ltx-visible');
          fabButton.setAttribute('aria-hidden', 'true');
          fabButton.tabIndex = -1;
        }
      }
      if (!options.silent) {
        persistState({ collapsed }, true);
      }
    };

    const updateMuteClass = () => {
      const muted = audio.muted || audio.volume === 0;
      player.classList.toggle('ltx-muted', muted);
    };

    const hasSavedVolume = savedState && Number.isFinite(savedState.volume);
    const initialVolume = hasSavedVolume ? clamp(savedState.volume, 0, 1) : clamp(config.startVolume ?? 0.6, 0, 1);
    audio.volume = initialVolume;
    if (savedState && typeof savedState.muted === 'boolean') {
      audio.muted = savedState.muted;
    }
    updateMuteClass();

    const updateProgress = () => {
      const duration = audio.duration || 0;
      const current = audio.currentTime || 0;
      const percentage = duration ? (current / duration) * 100 : 0;
      progressFillEl.style.width = `${percentage}%`;
      currentTimeEl.textContent = formatTime(current);
      totalTimeEl.textContent = formatTime(duration);
    };

    const seekWhenReady = (time) => {
      const target = Number.isFinite(time) ? Math.max(0, time) : 0;
      if (!target) {
        audio.currentTime = 0;
        flushState({ currentTime: 0 });
        updateProgress();
        return;
      }
      const assign = () => {
        const duration = audio.duration;
        const upper = Number.isFinite(duration) && duration > 0 ? Math.min(target, duration) : target;
        try {
          audio.currentTime = upper;
          updateProgress();
          flushState({ currentTime: upper });
        } catch (err) {
           
        }
      };
      if (audio.readyState >= 1) {
        assign();
      } else {
        const handler = () => {
          assign();
          audio.removeEventListener('loadedmetadata', handler);
          audio.removeEventListener('canplay', handler);
        };
        audio.addEventListener('loadedmetadata', handler);
        audio.addEventListener('canplay', handler);
      }
    };

    const setTrack = (nextIndex, options = {}) => {
      const total = state.tracks.length;
      state.index = ((nextIndex % total) + total) % total;
      const track = state.tracks[state.index];
      if (!track || !track.file) {
        console.warn('LTX music player: 音频文件缺失', track);
        tipEl.textContent = '音频文件缺失，请检查配置';
        return;
      }
      const cover = track.cover || config.defaultCover || '';
      if (coverEl) {
        if (cover) {
          coverEl.src = cover;
          coverEl.alt = track.title ? `${track.title} 封面` : '音乐封面';
          player.classList.add('ltx-has-cover');
        } else {
          coverEl.removeAttribute('src');
          coverEl.alt = '';
          player.classList.remove('ltx-has-cover');
        }
      }
      titleEl.textContent = track.title || `Track ${state.index + 1}`;
      artistEl.textContent = track.artist || '';
      audio.src = track.file;
      player.dataset.trackIndex = state.index;
      tipEl.textContent = '';
      player.classList.remove('ltx-autoplay-blocked');
      seekWhenReady(options.resumeTime);
      flushState({
        trackIndex: state.index,
        currentTime: Number.isFinite(options.resumeTime) ? Math.max(0, options.resumeTime) : 0,
      });
      updateProgress();
      if (options.play) {
        attemptPlay();
      }
    };

    const attemptPlay = () => {
      audio.play().then(() => {
        player.classList.remove('ltx-autoplay-blocked');
        tipEl.textContent = '';
      }).catch(() => {
        player.classList.add('ltx-autoplay-blocked');
        tipEl.textContent = '浏览器阻止了自动播放，请点击播放按钮';
      });
    };

    const playNext = (autoTriggered = false) => {
      const shouldPlay = !audio.paused || autoTriggered;
      const nextIndex = state.index + 1;
      if (nextIndex >= state.tracks.length && !state.loopPlaylist) {
        audio.currentTime = audio.duration || 0;
        audio.pause();
        flushState();
        return;
      }
      setTrack(nextIndex, { play: shouldPlay });
    };

    const playPrev = () => {
      const shouldPlay = !audio.paused;
      setTrack(state.index - 1, { play: shouldPlay });
    };

    if (state.collapsed) {
      setCollapsed(true, { silent: true });
    } else {
      setOffset(state.offset, { silent: true });
    }

    if (collapseBtn) {
      collapseBtn.addEventListener('click', () => setCollapsed(true));
    }

    if (fabButton) {
      fabButton.addEventListener('click', () => setCollapsed(false));
      if (state.collapsed) {
        fabButton.classList.add('ltx-visible');
        fabButton.setAttribute('aria-hidden', 'false');
        fabButton.tabIndex = 0;
      } else {
        fabButton.setAttribute('aria-hidden', 'true');
        fabButton.tabIndex = -1;
      }
    }

    if (dragHandle) {
      dragHandle.style.touchAction = 'none';
      dragHandle.addEventListener('pointerdown', (event) => {
        if (state.collapsed) {
          return;
        }
        dragState.active = true;
        dragState.pointerId = event.pointerId;
        dragState.startY = event.clientY;
        dragState.startOffset = state.offset;
        if (dragHandle.setPointerCapture) {
          try {
            dragHandle.setPointerCapture(event.pointerId);
          } catch (err) {
             
          }
        }
        player.classList.add('ltx-dragging');
      });

      dragHandle.addEventListener('pointermove', (event) => {
        if (!dragState.active) {
          return;
        }
        const delta = event.clientY - dragState.startY;
        setOffset(dragState.startOffset + delta);
      });

      const finishDrag = () => {
        if (!dragState.active) {
          return;
        }
        if (dragState.pointerId !== null && dragHandle.releasePointerCapture) {
          try {
            dragHandle.releasePointerCapture(dragState.pointerId);
          } catch (err) {
             
          }
        }
        dragState.active = false;
        dragState.pointerId = null;
        player.classList.remove('ltx-dragging');
        if (state.offset > hideThreshold) {
          setCollapsed(true);
        } else {
          setOffset(state.offset);
        }
      };

      ['pointerup', 'pointercancel'].forEach((eventName) => {
        dragHandle.addEventListener(eventName, finishDrag);
      });

      dragHandle.addEventListener('pointerleave', () => {
        if (!dragState.active) {
          return;
        }
        finishDrag();
      });
    }

    toggleBtn.addEventListener('click', () => {
      if (audio.paused) {
        attemptPlay();
      } else {
        audio.pause();
      }
    });

    prevBtn.addEventListener('click', playPrev);
    nextBtn.addEventListener('click', () => playNext(false));

    muteBtn.addEventListener('click', () => {
      audio.muted = !audio.muted;
      updateMuteClass();
    });

    progressEl.addEventListener('click', (event) => {
      const rect = progressEl.getBoundingClientRect();
      const ratio = clamp((event.clientX - rect.left) / rect.width, 0, 1);
      if (Number.isFinite(audio.duration)) {
        audio.currentTime = ratio * audio.duration;
        flushState();
      }
    });

    audio.addEventListener('timeupdate', () => {
      updateProgress();
      persistState();
    });
    audio.addEventListener('loadedmetadata', () => {
      updateProgress();
      persistState();
    });

    audio.addEventListener('play', () => {
      player.classList.add('ltx-playing');
      player.classList.remove('ltx-autoplay-blocked');
      tipEl.textContent = '';
      flushState();
    });

    audio.addEventListener('pause', () => {
      player.classList.remove('ltx-playing');
      flushState();
    });

    audio.addEventListener('ended', () => {
      playNext(true);
    });

    audio.addEventListener('volumechange', () => {
      updateMuteClass();
      flushState();
    });
    audio.addEventListener('seeked', () => {
      flushState();
    });

    const handleVisibilityChange = () => {
      if (document.visibilityState === 'hidden') {
        flushState();
      }
    };

    window.addEventListener('pagehide', () => flushState());
    window.addEventListener('beforeunload', () => flushState());
    document.addEventListener('visibilitychange', handleVisibilityChange);

    const initialResumeTime = savedState && Number.isFinite(savedState.currentTime) ? Math.max(0, savedState.currentTime) : 0;
    const initialShouldPlay = savedState ? savedState.isPlaying === true : state.autoplay;
    setTrack(state.index, { play: initialShouldPlay, resumeTime: initialResumeTime });
  })();
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
