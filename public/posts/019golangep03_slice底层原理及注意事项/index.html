<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>GolangEP03_slice底层原理及注意事项 | LTX's Blog</title>
<meta name=keywords content="Golang,源码,Slice切片"><meta name=description content="引子
在做力扣的题目时，特别是遇到递归问题，需要传入参数，遇到切片的时候经常遇到需要克隆切片的情况，而遇到普通的int类型的时候却不需要。
显而易见，这是一个值传递还是引用传递的问题，所以今天我来总结一下 Golang 中切片的底层原理，为什么在递归中需要克隆它。"><meta name=author content="LTX"><link rel=canonical href=https://LTXWorld.github.io/posts/019golangep03_slice%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/><link crossorigin=anonymous href=/assets/css/stylesheet.725ec5b3e73dcbb0ff6543a8256cd49aa2c4c02c9e0586f006beb2e1f1dec7f2.css integrity="sha256-cl7Fs+c9y7D/ZUOoJWzUmqLEwCyeBYbwBr6y4fHex/I=" rel="preload stylesheet" as=style><link rel=icon href=https://LTXWorld.github.io/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://LTXWorld.github.io/favicon.png><link rel=icon type=image/png sizes=32x32 href=https://LTXWorld.github.io/favicon.png><link rel=apple-touch-icon href=https://LTXWorld.github.io/favicon.png><link rel=mask-icon href=https://LTXWorld.github.io/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://LTXWorld.github.io/posts/019golangep03_slice%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><meta property="og:url" content="https://LTXWorld.github.io/posts/019golangep03_slice%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"><meta property="og:site_name" content="LTX's Blog"><meta property="og:title" content="GolangEP03_slice底层原理及注意事项"><meta property="og:description" content="引子 在做力扣的题目时，特别是遇到递归问题，需要传入参数，遇到切片的时候经常遇到需要克隆切片的情况，而遇到普通的int类型的时候却不需要。
显而易见，这是一个值传递还是引用传递的问题，所以今天我来总结一下 Golang 中切片的底层原理，为什么在递归中需要克隆它。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-11T09:44:17+08:00"><meta property="article:modified_time" content="2025-04-11T09:44:17+08:00"><meta property="article:tag" content="Golang"><meta property="article:tag" content="源码"><meta property="article:tag" content="Slice切片"><meta property="og:image" content="https://LTXWorld.github.io/images/papermod-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://LTXWorld.github.io/images/papermod-cover.png"><meta name=twitter:title content="GolangEP03_slice底层原理及注意事项"><meta name=twitter:description content="引子
在做力扣的题目时，特别是遇到递归问题，需要传入参数，遇到切片的时候经常遇到需要克隆切片的情况，而遇到普通的int类型的时候却不需要。
显而易见，这是一个值传递还是引用传递的问题，所以今天我来总结一下 Golang 中切片的底层原理，为什么在递归中需要克隆它。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://LTXWorld.github.io/posts/"},{"@type":"ListItem","position":2,"name":"GolangEP03_slice底层原理及注意事项","item":"https://LTXWorld.github.io/posts/019golangep03_slice%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"GolangEP03_slice底层原理及注意事项","name":"GolangEP03_slice底层原理及注意事项","description":"引子 在做力扣的题目时，特别是遇到递归问题，需要传入参数，遇到切片的时候经常遇到需要克隆切片的情况，而遇到普通的int类型的时候却不需要。\n显而易见，这是一个值传递还是引用传递的问题，所以今天我来总结一下 Golang 中切片的底层原理，为什么在递归中需要克隆它。\n","keywords":["Golang","源码","Slice切片"],"articleBody":"引子 在做力扣的题目时，特别是遇到递归问题，需要传入参数，遇到切片的时候经常遇到需要克隆切片的情况，而遇到普通的int类型的时候却不需要。\n显而易见，这是一个值传递还是引用传递的问题，所以今天我来总结一下 Golang 中切片的底层原理，为什么在递归中需要克隆它。\n同时，在百度的一面中我也遇到了相关的切片题目，具体如下:\nfunc main() { original := []int{1, 2, 3} copied := original[:2] copied = append(copied, 4) original = append(original, 5) copied = append(copied, 6) original = append(original, 7) fmt. Printin(\"original===\",original) fmt.Printin(\"copied===\"copied) } 在这里你可以按下暂停键，考虑一下此时两个切片的输出会是怎样的。带着你的答案与疑惑，继续看下去吧。\n切片 这里先简单区分一下数组与切片。\nvar res [3]int var res []int 这里第一个指定长度的是数组，而第二个没有指定的是切片；前者是值类型，后者是引用类型可以使用append操作。\n简单一句话，为了摆脱数组固定长度带来的束缚，我们使用更为灵活的切片slice。\n切片底层 结构与扩容机制 首先总结一句话：切片 a 本身是一个结构体，a 代表底层数组地址（结构体里的 Data 字段），\u0026a 才是结构体变量 a 本身在内存中的地址。\ntype slice struct { array unsafe.Pointer // 指向底层数组的指针 len int // 切片的长度 cap int // 切片的容量 } 其扩容机制如下：\n当对切片进行 append 操作时，如果切片的长度小于其容量，Go 会直接在原底层数组的空间内添加元素，并更新切片的长度。 如果切片的长度等于或超过其容量，Go 会创建一个新的底层数组（通常是原来容量的 2 倍），将原数组的内容复制到新的数组中，并返回新的切片结构体。切片中的指针、长度和容量都会更新为新的数组和容量。 需要注意的是，为什么说切片是引用类型：切片本身是一个结构体（值类型），但它内部的指针指向底层数组。因为它内部包含了指针，所以切片被认为是引用类型。\n其在堆栈上的表现如下：栈中保存结构体，堆中保存底层数组。\na := []int{10, 20, 30} 栈区： +----------------------+ ← \u0026a = 0xc00000e030 | 切片结构体 a | | Data: 0xc0000140a0 | →→→→ 指向堆上的底层数组 | Len: 3 | | Cap: 3 | +----------------------+ 堆区： +----------------------+ | 10 | 20 | 30 | ← a.Data = \u0026a[0] = 0xc0000140a0 +----------------------+ append扩容的注意点 append是给原切片的当前长度的下一个位置添加元素，其扩容机制如上所述，但是需要注意的是\nnil切片在append时会被当作len=0, cap=0的切片处理，所以如果对nil切片进行append其会自动为你分配一个新的底层数组，即指向底层数组的指针会发生改变。 func main() { var res []int fmt.Printf(\"res结构体的地址是 %p, res指向底层数组的地址是 %p\", \u0026res, res) res = append(res, 1) fmt.Printf(\"res结构体的地址 %p, res指向底层数组的地址是 %p\", \u0026res, res) } append每次会生成一个新的结构体值，但是其变量本身在栈上的位置不变，但是指向底层数组的指针如果不扩容就不变。\npath = append(path, 1)可以验证\u0026path不会发生改变——放到递归中就是每一层的path都是同一个path，其\u0026path不变(即使底层数组变化\u0026path也不变) 这意味着每次append之后返回的新的结构体中三个变量：底层数组指针，长度，容量；只有长度是一定在变化的，其他两者要看是否发生了扩容。 值得注意的是，在递归回溯类问题中父递归会根据长度来判断当前切片中的值有哪些——即使底层数组不变，但是长度发生了变化。这一点在后面常见问题有所体现。 扩容机制带来的坑（必须len\u003e=cap去扩容）\ns1 := []int{1, 2, 3} s2 := s1[1:2] s3 := append(s2, 10) 可以思考这段代码三者的结果是什么，看似没有修改s1,其实其值已经被修改了；这也是后面回溯的题目我们为什么要克隆path的原因。\nappend(arr, arr …) 这里的省略号代表着什么？回到 append 的最初底层定义func append(slice []Type, elems ...Type)\n第二个参数是可变参数，但是类型需要与 slice 切片中元素的类型相同\narr := []int{1, 2, 3} newArr := append(arr, arr...) // 如果不写...则会报错，因为后面的arr是切片，而前面的Type是int fmt.Println(newArr) // 输出: [1 2 3 1 2 3] 这样写的含义是使用 … 展开切片 arr， 从而等效于append(arr, 1, 2, 3)。\n省略号仅适用于展开切片和表示可变参数。\nlen与cap 长度和容量作为Golang切片中的核心概念，通过尝试下面这段代码，我们可以略窥一二。\ns1 := make([]int, 3, 6) s2 = s1[1:3] s1[1] = 1 s2 = append(s2, 2) 如果此时打印s1与s2的内容，会是什么呢？请先思考。\n常犯的错误是:第三句执行完之后其底层数组是[0,1,0],然后append时没有发生扩容，所以二者的底层数组是相同的，打印出的二者应该都是[0,0,2]，但结果并不是，s1仍是[0,1,0],s2是[1,0,2]，所以为什么？\n请先记住这个概念:cap(slice) = 原始数组末尾 - slice 的起始位置\n起初s1长度为3，容量为6，底层数组前面3个值为0，后面3个未使用；当s2 = s1[1:3]时，s2切片的底层数组指针指向的是第二个位置，这就导致其长度为2,容量为5\n在修改s[1] = 1时，底层数组共享，二者都能看到这个修改（如果修改的是s[0]=1呢？可以想想，结果很明显s2看不到，因为其起始位置是第二个位置）\n最后append(s2, 2)时，并不会发生扩容，但是s2的长度要+1，二者也都能看到，第四个位置变为2.\n具体如图所示：\n接下来，如果我们继续向s2中append三个数，3，4，5，后果是什么呢？这里就涉及到append的扩容机制了，我们之前说过。\n当3，4添加之后，s2的长度已经来到了5，注意，此时其len=cap了！要发生扩容了！但是对于s1呢？仍然保持着cap=6\u003elen=5,所以不扩容。\n最后二者分道扬镳，不再共享底层数组了（指针指向两个不同的地址），s2的容量也会扩大两倍来到10.\n切片的初始化 看完上面的长度与容量后，我们借此来讨论一下切片的初始化。\nmake初始化 对于 make 一般有以下三种不同的初始化，分别是:声明长度为0；声明指定长度；声明指定容量（当然既声明长度又声明容量也是可行的）\na := make([]int, 0) b := make([]int, n) c := make([]int, 0, n) 看到b有些亲切，我们平时做题时有时声明path就这样来写的。这三种写法有什么区别呢？\n显而易见，a的底层数组并没有开辟（长度为0），假如我们每次只append一个值，当我们进行多次append操作时，a会发生多次的扩容，这么多次的扩容会导致什么问题呢——原来旧的底层数组没有人用了，会引起GC的垃圾回收，从而影响性能。（关于GC的事，我们挖个坑后续补充） 而bc的底层已经开辟好了空间，有一点不同是，添加元素时需要对b进行b[i]=x这样的添加，对于c需要进行c = append(c, x)——因为 append 会给切片的末尾去添加元素。 带来的区别就是，遇到向切片中添加元素的情况时，b和c基本不会发生扩容，a在不断地扩容，性能大打折扣。 b和c对比呢？大家可以猜猜更倾向于谁 在性能上，b要优于c一些，仅仅是a little,因为c要不断地去append；但是，考虑到代码的书写方便，我们还是更喜欢c的append，因为b[i] = x这个在某些复杂的情况下得计算，不是简单的顺序。\n但是话又说回来，a就一定不好吗？虽然其会发生许多次的扩容，但是如果我们事先并不清楚该设置多少的长度或者容量，反而a在扩容次数较少的情况下会更好。\n那么这又是一个CPU和memory的二选一问题了。\n但是我们仍然建议你再声明任何切片的时候如果可以预知长度或者容量，就提前声明，即使你要遍历一遍传来的字符串等，因为如果不提前声明，扩容带来的性能损耗远高于遍历等操作。\n例如二维动态规划dp数组的声明常见写法\nn := len(text1) m := len(text2) dp := make([][]int, n+1) // 0~n n+1 for i := range dp { dp[i] = make([]int, m+1) } 如果没有后面这段for循环，我们只是创建了 n+1 个 nil 的行，直接访问 dp[0][0] 会直接 panic 数组越界。\n字面量初始化 s1 := []int{1, 2, 3, 4, 5} s2 := []int{} var s3 []int s1 是一种直接给值的初始化，长度=容量 s2 没有初始化，长度为0，容量为0 s3 与 s2 的区别是其只声明但未初始化，所以这是一个空切片 nil 从现有数组获得切片 这就是我们常见的“切割”操作，a[1:3]，代表着取a[1],a[2]这样一个左闭右开区间。\n不会创建新的底层数组，而是创建一个新的切片结构体 新结构体的指针指向自己指定的起始位置，例如a[1] 区分nil slice和empty slice 先说结论，nil slice一定是empty slice,但是empty slice不是nil slice.\nA nil slice equals nil, whereas an empty slice has a length of zero. A nil slice is empty, but an empty slice isn’t necessarily nil\n回到上面的初始化，其实最基础的是不是这几种写法\nvar s1[]string s2 := []string(nil) s3 := []string{} s4 = make([]string, 0) 对于1来说，是空指针，没有底层数组（平时做题自己上来就var res []int） 对于2来说，是一个语法糖，本质也是1 对于3来说，是空，但有底层数组，但不是nil 对于4，与3相同 但是，无论是 empty 还是 nil,对其进行 fmt.Println(s) 打印输出时，都会显示 []，这是 golang 设计的格式化约定。\n那么 empty 和 nil 这两个概念有什么区别呢？如果此时对二者进行 JSON 序列化，结果立马就会有所不同。\nvar s1 []float32 // nil customer1 := customer{ ID: \"foo\", Operations: s1, } b, _ := json.Marshal(customer1) fmt.Println(string(b)) s2 := make([]float32, 0) // empty customer2 := customer{ ID: \"bar\", Operations: s2, } b, _ = json.Marshal(customer2) fmt.Println(string(b)) // 结果如下 {\"ID\":\"foo\",\"Operations\":null} {\"ID\":\"bar\",\"Operations\":[]} 值得注意的是，append对两类切片的操作相同。\n为什么我们要分这么清呢？上面的JSON序列化已经告诉你了——对前端或接口定义要求严格的系统（比如 [] 是必须字段）就很关键\n未赋值nil 空数组[] 检查空 由此引申出一个问题，如何判断一个切片为空？是用x == nil吗？很明显不是，对于[]我们无法判断，所以我们应该从长度出发if len(x) == 0，完美地覆盖了两种情况。\ncopy的坑 开门见山：当你想把某个切片拷贝给另一个切片时，copy函数会选择两个切片中长度的较小值进行逐值拷贝。\n所以，如果我们还是像上面那样声明切片的话，很容易发生拷贝失效的问题（长度最小值为0了）\nsrc := []int{0, 1, 2} var dst []int copy(dst, src) fmt.Println(dst) 输出结果为 []， copy 不像 append 那样会进行扩容，所以发生了拷贝失效。\n所以还是劝自己写成声明长度或者容量的方式。\n做题中的问题 明白了切片的底层原理之后我们再来看看常见的问题，以下面的递归代码举例,本示例代码出自于力扣78子集问题，一道经典的回溯问题。\n回溯Clone func subsets(nums []int) [][]int { var res [][]int var path []int var dfs func(int) dfs = func(index int) { if index == len(nums) { res = append(res, slices.Clone(path)) return } // 不选 dfs(index + 1) // 选 path = append(path, nums[index]) dfs(index + 1) // 最后进行回溯 path = path[:len(path)-1] } dfs(0) return res } 需要注意的点在于这句res = append(res, slices.Clone(path))，可以发现每次我们收集结果的时候都进行了克隆——克隆的作用在于创建一个新的切片，复制path当前的内容。\n为什么要克隆？如果改成res = append(res, path)会怎么样？\n由于 path 切片在代码中作为全局变量，被传入闭包函数中会被全局共享，即每一层递归其实使用的是同一个path结构体，如果不克隆，每次收集的时候都收集到的是当前的path状态。\n而后面的递归过程中进行回溯操作，path 值发生变化，导致之前收集到的 res 受到影响。（我们默认不发生扩容）\n所以我们需要对其进行克隆，每次都保存一份当前那一刻的path的快照。\n何时回溯\u0026为什么回溯 题外话，如果我们不使用闭包函数的写法，上面那段代码会是这样的。\nfunc subsets(nums []int) [][]int { var res [][]int dfs(nums, 0, []int{}, \u0026res) return res } func dfs(nums []int, index int, path []int, res *[][]int) { if index == len(nums) { clone := slices.Clone(path) *res = append(*res, clone) return } // 不选当前元素 dfs(nums, index+1, path, res) // 选当前元素 path = append(path, nums[index]) dfs(nums, index+1, path, res) // 不需要回溯 } 疑问1:这里为什么要Clone？\n其实在本题的条件下，不需要Clone——因为这种函数写法是值传递，导致决策树每层递归的path都是独立的，不再是上一段中的全局变量了，我们即使后面在append修改，但修改的不是当前层的path；且收集结果只在根节点收集 那么在力扣上尝试一下是这样的 其实仔细看两个答案是一样的，只是力扣要求我们必须以他的答案顺序，那么为什么呢？在平时写代码时如果我们在后面修改了前面的元素，例如如果后面修改了path[0] = 1那么就会影响到我们已经收集好的结果。（默认没有发生扩容，底层数组共享） 总结：递归中虽然每层的 path 不同，但是仍可能共享着底层数组，发生修改后可能会影响已经收集过的结果，故为了代码的健壮性我们必须Clone 疑问2:既然每层的 path 切片不同，但是其底层数组相同，那为什么不需要回溯？\n值得注意的是，我们的 path 刚开始是空的，所以一旦发生 append 就一定会发生扩容(这一点在上面的 append 注意点中提到过)，而扩容后底层数组就会不一样—nil 切片在 append 时会被当作 len=0, cap=0的切片处理的情况。 而不需要回溯的原因在于每次我们都是值传递，即使底层数组共享，但是从子递归回到父递归时，还是父递归那一层的path状态——回到上层递归时，path会从下层的状态恢复到上层的状态，例如从[2]恢复到[],故自然不需要回溯，这样的写法自动给我们回溯了。 拿一个示例代码举例:\npackage main import ( \"fmt\" \"slices\" ) func main() { fmt.Println(subsets([]int{1, 2})) } func subsets(nums []int) [][]int { var res [][]int path := make([]int, 0, 10) // 初始容量为 10，不让他扩容 dfs(nums, 0, path, \u0026res) return res } func dfs(nums []int, index int, path []int, res *[][]int) { fmt.Printf(\"path: %p, \u0026path: %p, len: %d, cap: %d\\n\", path, \u0026path, len(path), cap(path)) if index == len(nums) { clone := slices.Clone(path) *res = append(*res, clone) return } // 不选当前元素 dfs(nums, index+1, path, res) // 选当前元素 fmt.Printf(\"path: %p, \u0026path: %p, len: %d, cap: %d\\n\", path, \u0026path, len(path), cap(path)) path = append(path, nums[index]) fmt.Printf(\"path: %p, \u0026path: %p, len: %d, cap: %d\\n\", path, \u0026path, len(path), cap(path)) dfs(nums, index+1, path, res) fmt.Printf(\"path: %p, \u0026path: %p, len: %d, cap: %d\\n\", path, \u0026path, len(path), cap(path)) // 不需要回溯 } 关注第一次进入时的\u0026path和最后一次的，发现二者是一样的，并且path的长度也恢复了，意味着path内的值也恢复了。\n这里也留了一个隐藏坑，具体见补充问题中。\n疑问3:这里为什么 res *[][]int 呢？\n因为函数的值传递，每次传入的res如果不加这个*就会导致每次传的都是一个副本，一个拷贝，即函数里面的res和你外面传过来的res不是一个切片结构体，那么在返回的时候自然无法获得正确结果——需要加上*进行 补充问题：为什么底层数组是一样的，但是path中保存的值却不一样呢？\n其实这也是一个非常关键的问题，涉及到了Golang对切片的设计哲学——数据共享，但视图独立。 因为我们底层数组一样，Golang的切片使用len变量来保证不同层级的视图独立——回到父递归时，由于其len还是0，所以我们的父递归path就只能看得到这个len=0的切片了，而不再是子递归中的len=1的切片。 对比两种写法可以发现，闭包中使用的path是全局变量，需要回溯，需要克隆；而独立声明函数的写法中的path对于每层（决策树）递归都是一个独立的切片（值传递的缘故）即使底层数组可能发生共享，但是其依靠len变量进行层级之间的分隔，使其做到每层递归都是独立的。\n一句话总结：切片是结构体，传参传结构；结构中有指针，共享底层\n类比问题 上面两种写法一种使用全局变量+闭包的写法，很明显必须回溯必须Clone；一种采用独立声明函数的方式。如果我再来一种完全闭包函数的写法呢？\nfunc subsets(nums []int) [][]int { var res [][]int // var path []int var dfs func(int, []int) dfs = func(index int, path []int) { // 对于每个元素都会选或者不选，这会形成一颗决策二叉树，走到叶子节点收集结果即可。 if index == len(nums) { res = append(res, slices.Clone(path)) return } // 不选 dfs(index + 1, path) // 选 path = append(path, nums[index]) dfs(index + 1, path) // 最后进行回溯,其实不需要回溯，原因同上，递归过程中每一层path独立根据len进行分割视图。 // path = path[:len(path)-1] } dfs(0, []int{}) return res } 也不需要回溯，原因同上。\n还有一种写法，在append上做出了一个小修改dfs(index+1, append(path, nums[index]))——把两步结合在了一步。\n我们把append结果直接传到了dfs参数中，并没有多写path = append(path, nums[index])。有什么不同呢？\n后者直接传递了一个新的切片结构体进去，子递归发生的修改不会影响父递归的path(这是这种写法的优点，父path还是len=0) 前者先append后，父递归的path已经是修改过的了，通过dfs再传入的是修改过的path； 总结递归回溯写法 虽然Golang的切片特性以及值传递的特点可以帮组我们忽略回溯的编写，但是一旦使用全局变量就一定得回溯。\n而使用全局变量这一点就类似于Java中的List,所以为了统一起见，我们都显式地将回溯语句写出来。\n与Java简单比较 Java中通常使用ArrayList动态数组，可以做到随机访问，其底层也有一个数组，提供了add,remove,get,set等方法。\npublic class ArrayList\u003cE\u003e { private Object[] elementData; // 底层数组 private int size; // 当前元素数量 public boolean add(E e) { ensureCapacityInternal(size + 1); elementData[size++] = e; } } 也会发生扩容，使用Arrays.copyOf重新分配新数组。\n与切片不同的是，ArrayList是一个类，是一个引用类型，故传入参数是引用传递，不是Go中的值传递，所以对于上面那个*res,Java是不需要的，直接修改的原对象。\nList\u003cInteger\u003e arrayList = new ArrayList\u003c\u003e(); arrayList.add(1); // golang中得用append int val = arrayList.get(0); 补充Slices包的用法 Clone(slice)强制拷贝所有元素到新的底层数组，不共享内存 Equal(a, b) Compare(a, b) Index(slice, val) Delete(slice, i, j)删除下标范围[i,j)的元素，将前后两部分进行拼接 Sort(slice)对支持$\u003c$运算符的进行升序排序，底层调用了sort.Slice Max(slice) 总结 切片，本身是个结构体，包含着指向底层数组的指针，长度，容量这三个属性；在函数值传递的过程中，在函数内部操作的是切片的副本，与原来的切片结构体地址不同，但是只要不发生扩容，底层的数组是相同的，但是仍需注意可能指针指向在数组的不同位置导致看到的值并不相同；如果想要相同切片，需要传入其地址；\nappend操作不影响\u0026path即切片结构体自身的地址,在栈中（因为其长度总会发生变化），与上面相同，只要不发生扩容，底层数组指针就是相同的。\n我们强烈建议在预知切片的容量或者长度的情况下，对切片的初始化声明其容量或者长度，将大大地降低扩容带来的性能损耗。\n这里是LTX，感谢您阅读这篇博客，人生海海，和自己对话，像只蝴蝶纵横四海。\n引用 《100 Go Mistakes and How to Avoid Them (Teiva Harsanyi)》 ChatGPT Leetcode ","wordCount":"6958","inLanguage":"zh","image":"https://LTXWorld.github.io/images/papermod-cover.png","datePublished":"2025-04-11T09:44:17+08:00","dateModified":"2025-04-11T09:44:17+08:00","author":{"@type":"Person","name":"LTX"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://LTXWorld.github.io/posts/019golangep03_slice%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},"publisher":{"@type":"Organization","name":"LTX's Blog","logo":{"@type":"ImageObject","url":"https://LTXWorld.github.io/favicon.png"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://LTXWorld.github.io/ accesskey=h title="LTX's Blog (Alt + H)">LTX's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://LTXWorld.github.io/ title="LTX's Blog"><span>首页</span></a></li><li><a href=https://LTXWorld.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://LTXWorld.github.io/categories/ title=Categories><span>分类</span></a></li><li><a href=https://LTXWorld.github.io/tags/ title=Tags><span>标签</span></a></li><li><a href=https://LTXWorld.github.io/search/ title=搜索><span>搜索</span></a></li><li><a href=https://LTXWorld.github.io/about/ title=后花园><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">GolangEP03_slice底层原理及注意事项</h1><div class=post-meta><span title='2025-04-11 09:44:17 +0800 CST'>四月 11, 2025</span>&nbsp;·&nbsp;14 分钟&nbsp;·&nbsp;LTX</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%bc%95%e5%ad%90 aria-label=引子>引子</a></li><li><a href=#%e5%88%87%e7%89%87 aria-label=切片>切片</a><ul><li><a href=#%e5%88%87%e7%89%87%e5%ba%95%e5%b1%82 aria-label=切片底层>切片底层</a><ul><li><a href=#%e7%bb%93%e6%9e%84%e4%b8%8e%e6%89%a9%e5%ae%b9%e6%9c%ba%e5%88%b6 aria-label=结构与扩容机制>结构与扩容机制</a></li><li><a href=#append%e6%89%a9%e5%ae%b9%e7%9a%84%e6%b3%a8%e6%84%8f%e7%82%b9 aria-label=append扩容的注意点>append扩容的注意点</a></li><li><a href=#len%e4%b8%8ecap aria-label=len与cap>len与cap</a></li></ul></li><li><a href=#%e5%88%87%e7%89%87%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label=切片的初始化>切片的初始化</a><ul><li><a href=#make%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label=make初始化>make初始化</a></li><li><a href=#%e5%ad%97%e9%9d%a2%e9%87%8f%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label=字面量初始化>字面量初始化</a></li><li><a href=#%e4%bb%8e%e7%8e%b0%e6%9c%89%e6%95%b0%e7%bb%84%e8%8e%b7%e5%be%97%e5%88%87%e7%89%87 aria-label=从现有数组获得切片>从现有数组获得切片</a></li></ul></li><li><a href=#%e5%8c%ba%e5%88%86nil-slice%e5%92%8cempty-slice aria-label="区分nil slice和empty slice">区分nil slice和empty slice</a><ul><li><a href=#%e6%a3%80%e6%9f%a5%e7%a9%ba aria-label=检查空>检查空</a></li></ul></li><li><a href=#copy%e7%9a%84%e5%9d%91 aria-label=copy的坑>copy的坑</a></li><li><a href=#%e5%81%9a%e9%a2%98%e4%b8%ad%e7%9a%84%e9%97%ae%e9%a2%98 aria-label=做题中的问题>做题中的问题</a><ul><li><a href=#%e5%9b%9e%e6%ba%afclone aria-label=回溯Clone>回溯Clone</a></li><li><a href=#%e4%bd%95%e6%97%b6%e5%9b%9e%e6%ba%af%e4%b8%ba%e4%bb%80%e4%b9%88%e5%9b%9e%e6%ba%af aria-label=何时回溯&为什么回溯>何时回溯&为什么回溯</a></li><li><a href=#%e7%b1%bb%e6%af%94%e9%97%ae%e9%a2%98 aria-label=类比问题>类比问题</a></li><li><a href=#%e6%80%bb%e7%bb%93%e9%80%92%e5%bd%92%e5%9b%9e%e6%ba%af%e5%86%99%e6%b3%95 aria-label=总结递归回溯写法>总结递归回溯写法</a></li></ul></li><li><a href=#%e4%b8%8ejava%e7%ae%80%e5%8d%95%e6%af%94%e8%be%83 aria-label=与Java简单比较>与Java简单比较</a></li><li><a href=#%e8%a1%a5%e5%85%85slices%e5%8c%85%e7%9a%84%e7%94%a8%e6%b3%95 aria-label=补充Slices包的用法>补充Slices包的用法</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li><li><a href=#%e5%bc%95%e7%94%a8 aria-label=引用>引用</a></li></ul></div></details></div><div class=post-content><h2 id=引子>引子<a hidden class=anchor aria-hidden=true href=#引子>#</a></h2><p>在做力扣的题目时，特别是遇到递归问题，需要传入参数，遇到切片的时候经常遇到需要克隆切片的情况，而遇到普通的int类型的时候却不需要。</p><p>显而易见，这是一个值传递还是引用传递的问题，所以今天我来总结一下 Golang 中切片的底层原理，为什么在递归中需要克隆它。</p><p>同时，在百度的一面中我也遇到了相关的切片题目，具体如下:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>original</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span> 
</span></span><span class=line><span class=cl>    <span class=nx>copied</span> <span class=o>:=</span> <span class=nx>original</span><span class=p>[:</span><span class=mi>2</span><span class=p>]</span> 
</span></span><span class=line><span class=cl>    <span class=nx>copied</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>copied</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=nx>original</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>original</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=nx>copied</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>copied</span><span class=p>,</span> <span class=mi>6</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=nx>original</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>original</span><span class=p>,</span> <span class=mi>7</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span> <span class=nf>Printin</span><span class=p>(</span><span class=s>&#34;original===&#34;</span><span class=p>,</span><span class=nx>original</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printin</span><span class=p>(</span><span class=s>&#34;copied===&#34;</span><span class=nx>copied</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在这里你可以按下暂停键，考虑一下此时两个切片的输出会是怎样的。带着你的答案与疑惑，继续看下去吧。</p><h2 id=切片>切片<a hidden class=anchor aria-hidden=true href=#切片>#</a></h2><p>这里先简单区分一下数组与切片。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>var res <span class=o>[</span>3<span class=o>]</span>int
</span></span><span class=line><span class=cl>var res <span class=o>[]</span>int
</span></span></code></pre></div><p>这里第一个指定长度的是数组，而第二个没有指定的是切片；前者是值类型，后者是引用类型<strong>可以使用append操作</strong>。</p><p>简单一句话，为了摆脱数组固定长度带来的束缚，我们使用更为灵活的切片slice。</p><p><img alt=array loading=lazy src=/img/golangPic/array.png></p><h3 id=切片底层>切片底层<a hidden class=anchor aria-hidden=true href=#切片底层>#</a></h3><h4 id=结构与扩容机制>结构与扩容机制<a hidden class=anchor aria-hidden=true href=#结构与扩容机制>#</a></h4><p>首先总结一句话：<strong>切片 a 本身是一个结构体，a 代表底层数组地址（结构体里的 Data 字段），&amp;a 才是结构体变量 a 本身在内存中的地址。</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>slice</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>array</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=c1>// 指向底层数组的指针</span>
</span></span><span class=line><span class=cl>    <span class=nx>len</span>   <span class=kt>int</span>            <span class=c1>// 切片的长度</span>
</span></span><span class=line><span class=cl>    <span class=nx>cap</span>   <span class=kt>int</span>            <span class=c1>// 切片的容量</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>其扩容机制如下：</p><ul><li>当对切片进行 append 操作时，如果切片的长度小于其容量，Go 会直接在原底层数组的空间内添加元素，并更新切片的长度。</li><li><strong>如果切片的长度等于或超过其容量</strong>，Go 会创建一个新的底层数组（通常是原来容量的 2 倍），将原数组的内容复制到新的数组中，并返回新的切片结构体。切片中的指针、长度和容量都会更新为新的数组和容量。</li></ul><p>需要注意的是，为什么说切片是引用类型：切片本身是一个结构体（值类型），但它内部的指针指向底层数组。<strong>因为它内部包含了指针，所以切片被认为是引用类型。</strong></p><p>其在堆栈上的表现如下：栈中保存结构体，堆中保存底层数组。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>a</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>,</span> <span class=mi>30</span><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>栈区：
</span></span><span class=line><span class=cl>+----------------------+       ← &amp;a = 0xc00000e030
</span></span><span class=line><span class=cl>| 切片结构体 a         |
</span></span><span class=line><span class=cl>| Data: 0xc0000140a0   |  →→→→ 指向堆上的底层数组
</span></span><span class=line><span class=cl>| Len:  3              |
</span></span><span class=line><span class=cl>| Cap:  3              |
</span></span><span class=line><span class=cl>+----------------------+
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>堆区：
</span></span><span class=line><span class=cl>+----------------------+
</span></span><span class=line><span class=cl>| 10 | 20 | 30         | ← a.Data = &amp;a[0] = 0xc0000140a0
</span></span><span class=line><span class=cl>+----------------------+
</span></span></code></pre></div><h4 id=append扩容的注意点>append扩容的注意点<a hidden class=anchor aria-hidden=true href=#append扩容的注意点>#</a></h4><p>append是给原切片的<strong>当前长度的下一个位置</strong>添加元素，其扩容机制如上所述，但是需要注意的是</p><ol><li><strong>nil切片在append时会被当作len=0, cap=0的切片处理</strong>，所以如果对nil切片进行append其会自动为你分配一个新的底层数组，即指向底层数组的指针会发生改变。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>res</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;res结构体的地址是 %p, res指向底层数组的地址是 %p&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>res</span><span class=p>,</span> <span class=nx>res</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;res结构体的地址 %p, res指向底层数组的地址是 %p&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>res</span><span class=p>,</span> <span class=nx>res</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol start=2><li><p><strong>append每次会生成一个新的结构体值，但是其变量本身在栈上的位置不变，但是指向底层数组的指针如果不扩容就不变</strong>。</p><ol><li><code>path = append(path, 1)</code>可以验证<code>&amp;path</code>不会发生改变——放到递归中就是每一层的path都是同一个path，其&amp;path不变(即使底层数组变化<code>&amp;path</code>也不变)</li><li>这意味着每次append之后返回的新的结构体中三个变量：底层数组指针，长度，容量；只有长度是一定在变化的，其他两者要看是否发生了扩容。</li><li>值得注意的是，在递归回溯类问题中父递归会根据长度来判断当前切片中的值有哪些——即使底层数组不变，但是长度发生了变化。这一点在后面常见问题有所体现。</li></ol></li><li><p>扩容机制带来的坑（必须len>=cap去扩容）</p></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>s1</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>s2</span> <span class=o>:=</span> <span class=nx>s1</span><span class=p>[</span><span class=mi>1</span><span class=p>:</span><span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>s3</span> <span class=o>:=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>s2</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>
</span></span></code></pre></div><p>可以思考这段代码三者的结果是什么，看似没有修改s1,其实其值已经被修改了；这也是后面回溯的题目我们为什么要克隆path的原因。</p><ol start=4><li>append(arr, arr &mldr;)</li></ol><p>这里的省略号代表着什么？回到 append 的最初底层定义<code>func append(slice []Type, elems ...Type)</code></p><p>第二个参数是可变参数，但是类型需要与 slice 切片中<strong>元素的类型相同</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>arr</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>newArr</span> <span class=o>:=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>arr</span><span class=p>,</span> <span class=nx>arr</span><span class=o>...</span><span class=p>)</span> <span class=c1>// 如果不写...则会报错，因为后面的arr是切片，而前面的Type是int</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>newArr</span><span class=p>)</span>          <span class=c1>// 输出: [1 2 3 1 2 3]</span>
</span></span></code></pre></div><p>这样写的含义是使用 &mldr; <strong>展开切片</strong> arr， 从而等效于<code>append(arr, 1, 2, 3)</code>。</p><p>省略号仅适用于展开切片和表示可变参数。</p><h4 id=len与cap>len与cap<a hidden class=anchor aria-hidden=true href=#len与cap>#</a></h4><p>长度和容量作为Golang切片中的核心概念，通过尝试下面这段代码，我们可以略窥一二。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>s1</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>6</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>s2</span> <span class=p>=</span> <span class=nx>s1</span><span class=p>[</span><span class=mi>1</span><span class=p>:</span><span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>s1</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=nx>s2</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>s2</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span></code></pre></div><p>如果此时打印s1与s2的内容，会是什么呢？请先思考。</p><p>常犯的错误是:第三句执行完之后其底层数组是[0,1,0],然后append时没有发生扩容，所以二者的底层数组是相同的，打印出的二者应该都是[0,0,2]，但结果并不是，s1仍是[0,1,0],s2是[1,0,2]，所以为什么？</p><p>请先记住这个概念:<strong>cap(slice) = 原始数组末尾 - slice 的起始位置</strong></p><p>起初s1长度为3，容量为6，底层数组前面3个值为0，后面3个未使用；当<code>s2 = s1[1:3]</code>时，s2切片的底层数组<strong>指针指向的是第二个位置</strong>，这就导致其<strong>长度为2,容量为5</strong></p><p>在修改<code>s[1] = 1</code>时，底层数组共享，二者都能看到这个修改（如果修改的是<code>s[0]=1</code>呢？可以想想，结果很明显s2看不到，因为其起始位置是第二个位置）</p><p>最后<code>append(s2, 2)</code>时，并不会发生扩容，但是s2的长度要+1，二者也都能看到，第四个位置变为2.</p><p>具体如图所示：</p><p><img alt=len loading=lazy src=/img/golangPic/slen.png></p><p>接下来，如果我们继续向s2中append三个数，3，4，5，后果是什么呢？这里就涉及到append的扩容机制了，我们之前说过。</p><p>当3，4添加之后，s2的长度已经来到了5，注意，<strong>此时其len=cap</strong>了！要发生扩容了！但是对于s1呢？仍然保持着cap=6>len=5,所以不扩容。</p><p>最后二者分道扬镳，不再共享底层数组了（指针指向两个不同的地址），s2的容量也会扩大两倍来到10.</p><h3 id=切片的初始化>切片的初始化<a hidden class=anchor aria-hidden=true href=#切片的初始化>#</a></h3><p>看完上面的长度与容量后，我们借此来讨论一下切片的初始化。</p><h4 id=make初始化>make初始化<a hidden class=anchor aria-hidden=true href=#make初始化>#</a></h4><p>对于 make 一般有以下三种不同的初始化，分别是:<strong>声明长度为0；声明指定长度；声明指定容量（当然既声明长度又声明容量也是可行的）</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>a</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>b</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span> 
</span></span></code></pre></div><p>看到b有些亲切，我们平时做题时有时声明path就这样来写的。这三种写法有什么区别呢？</p><ul><li>显而易见，a的底层数组并没有开辟（长度为0），假如我们每次只append一个值，当我们进行多次append操作时，a会发生多次的扩容，这么多次的扩容会导致什么问题呢——原来旧的底层数组没有人用了，会引起GC的垃圾回收，从而影响性能。（关于GC的事，我们挖个坑后续补充）</li><li>而bc的底层已经开辟好了空间，有一点不同是，添加元素时需要对b进行<code>b[i]=x</code>这样的添加，对于c需要进行<code>c = append(c, x)</code>——因为 append 会给切片的末尾去添加元素。</li><li>带来的区别就是，遇到向切片中添加元素的情况时，b和c基本不会发生扩容，a在不断地扩容，性能大打折扣。</li><li>b和c对比呢？大家可以猜猜更倾向于谁</li></ul><p>在性能上，b要优于c一些，仅仅是a little,因为c要不断地去append；但是，考虑到代码的书写方便，我们还是<em>更喜欢c的append</em>，因为<code>b[i] = x</code>这个在某些复杂的情况下得计算，不是简单的顺序。</p><p>但是话又说回来，a就一定不好吗？虽然其会发生许多次的扩容，但是如果我们事先并不清楚该设置多少的长度或者容量，反而a在扩容次数较少的情况下会更好。</p><p>那么这又是一个CPU和memory的二选一问题了。</p><p>但是我们仍然建议你再声明任何切片的时候<strong>如果可以预知长度或者容量，就提前声明</strong>，即使你要遍历一遍传来的字符串等，因为如果不提前声明，扩容带来的性能损耗远高于遍历等操作。</p><p>例如二维动态规划dp数组的声明常见写法</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>text1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>m</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>text2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>dp</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([][]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span> <span class=c1>// 0~n n+1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>dp</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>dp</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>m</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>如果没有后面这段for循环，我们只是创建了 n+1 个 nil 的行，直接访问 <code>dp[0][0]</code> 会直接 panic 数组越界。</p><h4 id=字面量初始化>字面量初始化<a hidden class=anchor aria-hidden=true href=#字面量初始化>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>s1</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>s2</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>s3</span> <span class=p>[]</span><span class=kt>int</span>
</span></span></code></pre></div><ul><li>s1 是一种直接给值的初始化，长度=容量</li><li>s2 没有初始化，长度为0，容量为0</li><li>s3 与 s2 的区别是其只声明但未初始化，所以这是一个空切片 nil</li></ul><h4 id=从现有数组获得切片>从现有数组获得切片<a hidden class=anchor aria-hidden=true href=#从现有数组获得切片>#</a></h4><p>这就是我们常见的“切割”操作，<code>a[1:3]</code>，代表着取<code>a[1],a[2]</code>这样一个<strong>左闭右开</strong>区间。</p><ul><li>不会创建新的底层数组，而是创建一个新的切片结构体</li><li>新结构体的指针指向自己指定的起始位置，例如<code>a[1]</code></li></ul><h3 id=区分nil-slice和empty-slice>区分nil slice和empty slice<a hidden class=anchor aria-hidden=true href=#区分nil-slice和empty-slice>#</a></h3><p>先说结论，<strong>nil slice一定是empty slice,但是empty slice不是nil slice.</strong></p><blockquote><p>A nil slice equals nil, whereas an empty slice has a length of zero. A nil slice is empty, but an empty slice isn’t necessarily nil</p></blockquote><p>回到上面的初始化，其实最基础的是不是这几种写法</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>s1</span><span class=p>[]</span><span class=kt>string</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>s2</span> <span class=o>:=</span> <span class=p>[]</span><span class=nb>string</span><span class=p>(</span><span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>s3</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>s4</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>string</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span></code></pre></div><ul><li>对于1来说，是空指针，<strong>没有底层数组</strong>（平时做题自己上来就<code>var res []int</code>）</li><li>对于2来说，是一个语法糖，本质也是1</li><li>对于3来说，<strong>是空，但有底层数组</strong>，但不是nil</li><li>对于4，与3相同</li></ul><p>但是，无论是 empty 还是 nil,对其进行 <code>fmt.Println(s)</code> 打印输出时，都会显示 <code>[]</code>，这是 golang 设计的格式化约定。</p><p>那么 empty 和 nil 这两个概念有什么区别呢？如果此时对二者进行 JSON 序列化，结果立马就会有所不同。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>s1</span> <span class=p>[]</span><span class=kt>float32</span> <span class=c1>// nil</span>
</span></span><span class=line><span class=cl><span class=nx>customer1</span> <span class=o>:=</span> <span class=nx>customer</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ID</span><span class=p>:</span> <span class=s>&#34;foo&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>Operations</span><span class=p>:</span> <span class=nx>s1</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>b</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Marshal</span><span class=p>(</span><span class=nx>customer1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>b</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>s2</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>float32</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=c1>// empty</span>
</span></span><span class=line><span class=cl><span class=nx>customer2</span> <span class=o>:=</span> <span class=nx>customer</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ID</span><span class=p>:</span> <span class=s>&#34;bar&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>Operations</span><span class=p>:</span> <span class=nx>s2</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>b</span><span class=p>,</span> <span class=nx>_</span> <span class=p>=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Marshal</span><span class=p>(</span><span class=nx>customer2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>b</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 结果如下</span>
</span></span><span class=line><span class=cl><span class=p>{</span><span class=s>&#34;ID&#34;</span><span class=p>:</span><span class=s>&#34;foo&#34;</span><span class=p>,</span><span class=s>&#34;Operations&#34;</span><span class=p>:</span><span class=nx>null</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>{</span><span class=s>&#34;ID&#34;</span><span class=p>:</span><span class=s>&#34;bar&#34;</span><span class=p>,</span><span class=s>&#34;Operations&#34;</span><span class=p>:[]}</span>
</span></span></code></pre></div><p>值得注意的是，<em>append对两类切片的操作相同</em>。</p><p>为什么我们要分这么清呢？上面的JSON序列化已经告诉你了——对前端或接口定义要求严格的系统（比如 [] 是必须字段）就很关键</p><ul><li>未赋值<code>nil</code></li><li>空数组<code>[]</code></li></ul><h4 id=检查空>检查空<a hidden class=anchor aria-hidden=true href=#检查空>#</a></h4><p>由此引申出一个问题，如何判断一个切片为空？是用<code>x == nil</code>吗？很明显不是，对于<code>[]</code>我们无法判断，所以我们应该从长度出发<code>if len(x) == 0</code>，完美地覆盖了两种情况。</p><h3 id=copy的坑>copy的坑<a hidden class=anchor aria-hidden=true href=#copy的坑>#</a></h3><p>开门见山：当你想把某个切片拷贝给另一个切片时，<strong>copy函数会选择两个切片中长度的较小值进行逐值拷贝</strong>。</p><p>所以，如果我们还是像上面那样声明切片的话，很容易发生拷贝失效的问题（长度最小值为0了）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>src</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>dst</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nb>copy</span><span class=p>(</span><span class=nx>dst</span><span class=p>,</span> <span class=nx>src</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>dst</span><span class=p>)</span>
</span></span></code></pre></div><p>输出结果为 <code>[]</code>， copy 不像 append 那样会进行扩容，所以发生了拷贝失效。</p><p>所以还是劝自己写成<em>声明长度或者容量</em>的方式。</p><h3 id=做题中的问题>做题中的问题<a hidden class=anchor aria-hidden=true href=#做题中的问题>#</a></h3><p>明白了切片的底层原理之后我们再来看看常见的问题，以下面的递归代码举例,本示例代码出自于力扣78子集问题，一道经典的回溯问题。</p><h4 id=回溯clone>回溯Clone<a hidden class=anchor aria-hidden=true href=#回溯clone>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>subsets</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[][]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>res</span> <span class=p>[][]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>path</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>dfs</span> <span class=kd>func</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>dfs</span> <span class=p>=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>index</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>index</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>res</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=nx>slices</span><span class=p>.</span><span class=nf>Clone</span><span class=p>(</span><span class=nx>path</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> 
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 不选</span>
</span></span><span class=line><span class=cl>        <span class=nf>dfs</span><span class=p>(</span><span class=nx>index</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 选</span>
</span></span><span class=line><span class=cl>        <span class=nx>path</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>path</span><span class=p>,</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>index</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=nf>dfs</span><span class=p>(</span><span class=nx>index</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 最后进行回溯</span>
</span></span><span class=line><span class=cl>        <span class=nx>path</span> <span class=p>=</span> <span class=nx>path</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>path</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>dfs</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>需要注意的点在于这句<code>res = append(res, slices.Clone(path))</code>，可以发现每次我们收集结果的时候都进行了克隆——克隆的作用在于创建一个新的切片，复制path当前的内容。</p><p>为什么要克隆？如果改成<code>res = append(res, path)</code>会怎么样？</p><p>由于 path 切片在代码中作为<strong>全局变量</strong>，被传入闭包函数中会被全局共享，即每一层递归其实使用的是同一个path结构体，如果不克隆，每次收集的时候都收集到的是当前的path状态。</p><p>而后面的递归过程中进行回溯操作，path 值发生变化，导致之前收集到的 res 受到影响。（我们默认不发生扩容）</p><p>所以我们需要对其进行克隆，每次都保存一份<strong>当前那一刻的path的快照</strong>。</p><h4 id=何时回溯为什么回溯>何时回溯&为什么回溯<a hidden class=anchor aria-hidden=true href=#何时回溯为什么回溯>#</a></h4><p>题外话，如果我们不使用闭包函数的写法，上面那段代码会是这样的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>subsets</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[][]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>res</span> <span class=p>[][]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nf>dfs</span><span class=p>(</span><span class=nx>nums</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{},</span> <span class=o>&amp;</span><span class=nx>res</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>dfs</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>index</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>path</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>res</span> <span class=o>*</span><span class=p>[][]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>index</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>clone</span> <span class=o>:=</span> <span class=nx>slices</span><span class=p>.</span><span class=nf>Clone</span><span class=p>(</span><span class=nx>path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=nx>res</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=o>*</span><span class=nx>res</span><span class=p>,</span> <span class=nx>clone</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 不选当前元素</span>
</span></span><span class=line><span class=cl>    <span class=nf>dfs</span><span class=p>(</span><span class=nx>nums</span><span class=p>,</span> <span class=nx>index</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nx>path</span><span class=p>,</span> <span class=nx>res</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 选当前元素</span>
</span></span><span class=line><span class=cl>    <span class=nx>path</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>path</span><span class=p>,</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>index</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=nf>dfs</span><span class=p>(</span><span class=nx>nums</span><span class=p>,</span> <span class=nx>index</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nx>path</span><span class=p>,</span> <span class=nx>res</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 不需要回溯</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>疑问1:<strong>这里为什么要Clone？</strong></p><ul><li>其实在本题的条件下，不需要Clone——因为这种<strong>函数写法是值传递，导致决策树每层递归的path都是独立的</strong>，不再是上一段中的全局变量了，我们即使后面在append修改，但修改的不是当前层的path；且收集结果只在根节点收集</li></ul><p>那么在力扣上尝试一下是这样的
<img alt=1 loading=lazy src=/img/golangPic/lc78.png></p><ul><li>其实仔细看两个答案是一样的，只是力扣要求我们必须以他的答案顺序，那么为什么呢？在平时写代码时如果我们在后面修改了前面的元素，例如如果后面修改了<code>path[0] = 1</code>那么就会影响到我们已经收集好的结果。（默认没有发生扩容，底层数组共享）</li><li>总结：<em>递归中虽然每层的 path 不同，但是仍可能共享着底层数组</em>，发生修改后可能会影响已经收集过的结果，故为了代码的健壮性我们必须Clone</li></ul><p>疑问2:<em>既然每层的 path 切片不同，但是其底层数组相同，那为什么不需要回溯？</em></p><ul><li>值得注意的是，我们的 path 刚开始是空的，所以一旦发生 append 就一定会发生扩容(这一点在上面的 append 注意点中提到过)，而扩容后底层数组就会不一样—<strong>nil 切片在 append 时会被当作 len=0, cap=0的切片处理</strong>的情况。</li><li>而不需要回溯的原因在于每次我们都是值传递，即使底层数组共享，但是从子递归回到父递归时，<strong>还是父递归那一层的path状态</strong>——回到上层递归时，path会从下层的状态恢复到上层的状态，例如从<code>[2]</code>恢复到<code>[]</code>,故自然不需要回溯，这样的写法自动给我们回溯了。</li></ul><p>拿一个示例代码举例:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;slices&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>subsets</span><span class=p>([]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>}))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>subsets</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[][]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>res</span> <span class=p>[][]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>path</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span> <span class=c1>// 初始容量为 10，不让他扩容</span>
</span></span><span class=line><span class=cl>	<span class=nf>dfs</span><span class=p>(</span><span class=nx>nums</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>path</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>res</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>dfs</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>index</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>path</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>res</span> <span class=o>*</span><span class=p>[][]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;path: %p, &amp;path: %p, len: %d, cap: %d\n&#34;</span><span class=p>,</span> <span class=nx>path</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>path</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>path</span><span class=p>),</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>path</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>index</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>clone</span> <span class=o>:=</span> <span class=nx>slices</span><span class=p>.</span><span class=nf>Clone</span><span class=p>(</span><span class=nx>path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=o>*</span><span class=nx>res</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=o>*</span><span class=nx>res</span><span class=p>,</span> <span class=nx>clone</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 不选当前元素</span>
</span></span><span class=line><span class=cl>	<span class=nf>dfs</span><span class=p>(</span><span class=nx>nums</span><span class=p>,</span> <span class=nx>index</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nx>path</span><span class=p>,</span> <span class=nx>res</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 选当前元素</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;path: %p, &amp;path: %p, len: %d, cap: %d\n&#34;</span><span class=p>,</span> <span class=nx>path</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>path</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>path</span><span class=p>),</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>path</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>path</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>path</span><span class=p>,</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>index</span><span class=p>])</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;path: %p, &amp;path: %p, len: %d, cap: %d\n&#34;</span><span class=p>,</span> <span class=nx>path</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>path</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>path</span><span class=p>),</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>path</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nf>dfs</span><span class=p>(</span><span class=nx>nums</span><span class=p>,</span> <span class=nx>index</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nx>path</span><span class=p>,</span> <span class=nx>res</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;path: %p, &amp;path: %p, len: %d, cap: %d\n&#34;</span><span class=p>,</span> <span class=nx>path</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>path</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>path</span><span class=p>),</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>path</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 不需要回溯</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><img alt=2 loading=lazy src=/img/golangPic/lc78_2.png></p><p>关注第一次进入时的&amp;path和最后一次的，发现二者是一样的，并且path的长度也恢复了，意味着path内的值也恢复了。</p><p>这里也留了一个隐藏坑，具体见补充问题中。</p><p>疑问3:<strong>这里为什么 <code>res *[][]int</code> 呢？</strong></p><ul><li>因为函数的值传递，每次传入的res如果不加这个<code>*</code>就会导致每次传的都是一个副本，一个拷贝，即函数里面的res和你外面传过来的res不是一个切片结构体，那么在返回的时候自然无法获得正确结果——需要加上<code>*</code>进行</li></ul><p>补充问题：<strong>为什么底层数组是一样的，但是path中保存的值却不一样呢？</strong></p><ul><li>其实这也是一个非常关键的问题，涉及到了Golang对切片的设计哲学——<strong>数据共享，但视图独立</strong>。</li><li>因为我们底层数组一样，Golang的切片使用len变量来保证不同层级的视图独立——回到父递归时，由于其len还是0，所以我们的父递归path就只能看得到这个<code>len=0</code>的切片了，而不再是子递归中的<code>len=1</code>的切片。</li></ul><p>对比两种写法可以发现，闭包中使用的path是<strong>全局变量</strong>，需要回溯，需要克隆；而独立声明函数的写法中的path对于每层（决策树）递归都是一个<strong>独立的切片</strong>（值传递的缘故）即使底层数组可能发生共享，但是其<strong>依靠len变量进行层级之间的分隔，使其做到每层递归都是独立的</strong>。</p><p>一句话总结：<strong>切片是结构体，传参传结构；结构中有指针，共享底层</strong></p><h4 id=类比问题>类比问题<a hidden class=anchor aria-hidden=true href=#类比问题>#</a></h4><p>上面两种写法一种使用全局变量+闭包的写法，很明显必须回溯必须Clone；一种采用独立声明函数的方式。如果我再来一种完全闭包函数的写法呢？</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>subsets</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[][]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>res</span> <span class=p>[][]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=c1>// var path []int</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>dfs</span> <span class=kd>func</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>dfs</span> <span class=p>=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>index</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>path</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 对于每个元素都会选或者不选，这会形成一颗决策二叉树，走到叶子节点收集结果即可。</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>index</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>res</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=nx>slices</span><span class=p>.</span><span class=nf>Clone</span><span class=p>(</span><span class=nx>path</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> 
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 不选</span>
</span></span><span class=line><span class=cl>        <span class=nf>dfs</span><span class=p>(</span><span class=nx>index</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=nx>path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 选</span>
</span></span><span class=line><span class=cl>        <span class=nx>path</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>path</span><span class=p>,</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>index</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=nf>dfs</span><span class=p>(</span><span class=nx>index</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=nx>path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 最后进行回溯,其实不需要回溯，原因同上，递归过程中每一层path独立根据len进行分割视图。</span>
</span></span><span class=line><span class=cl>        <span class=c1>// path = path[:len(path)-1]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>dfs</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>也不需要回溯，原因同上。</p><p>还有一种写法，在append上做出了一个小修改<code>dfs(index+1, append(path, nums[index]))</code>——把两步结合在了一步。</p><p>我们把append结果直接传到了dfs参数中，并没有多写<code>path = append(path, nums[index])</code>。有什么不同呢？</p><ul><li>后者直接传递了一个新的切片结构体进去，子递归发生的修改不会影响父递归的path(这是这种写法的优点，父path还是len=0)</li><li>前者先append后，父递归的path已经是修改过的了，通过dfs再传入的是修改过的path；</li></ul><h4 id=总结递归回溯写法>总结递归回溯写法<a hidden class=anchor aria-hidden=true href=#总结递归回溯写法>#</a></h4><p>虽然Golang的切片特性以及值传递的特点可以帮组我们忽略回溯的编写，但是一旦使用全局变量就一定得回溯。</p><p>而使用全局变量这一点就类似于Java中的List,所以为了统一起见，我们<strong>都显式地将回溯语句写出来</strong>。</p><h3 id=与java简单比较>与Java简单比较<a hidden class=anchor aria-hidden=true href=#与java简单比较>#</a></h3><p>Java中通常使用<code>ArrayList&lt;T></code>动态数组，可以做到随机访问，其底层也有一个数组，提供了add,remove,get,set等方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>ArrayList</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Object</span><span class=o>[]</span><span class=w> </span><span class=n>elementData</span><span class=p>;</span><span class=w> </span><span class=c1>// 底层数组</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>size</span><span class=p>;</span><span class=w>             </span><span class=c1>// 当前元素数量</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>add</span><span class=p>(</span><span class=n>E</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ensureCapacityInternal</span><span class=p>(</span><span class=n>size</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>elementData</span><span class=o>[</span><span class=n>size</span><span class=o>++]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>也会发生扩容，使用<code>Arrays.copyOf</code>重新分配新数组。</p><p>与切片不同的是，ArrayList是一个类，是一个引用类型，故传入参数是引用传递，不是Go中的值传递，所以对于上面那个<code>*res</code>,Java是不需要的，直接修改的原对象。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>arrayList</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ArrayList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>arrayList</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>1</span><span class=p>);</span><span class=w> </span><span class=c1>// golang中得用append</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>int</span><span class=w> </span><span class=n>val</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arrayList</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>0</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><h3 id=补充slices包的用法>补充Slices包的用法<a hidden class=anchor aria-hidden=true href=#补充slices包的用法>#</a></h3><ol><li>Clone(slice)强制拷贝所有元素到新的底层数组，<strong>不共享内存</strong></li><li>Equal(a, b)</li><li>Compare(a, b)</li><li>Index(slice, val)</li><li>Delete(slice, i, j)删除下标范围[i,j)的元素，将前后两部分进行拼接</li><li>Sort(slice)对支持$&lt;$运算符的进行升序排序，底层调用了<code>sort.Slice</code></li><li>Max(slice)</li></ol><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>切片，本身是个结构体，包含着指向<strong>底层数组的指针，长度，容量这三个属性</strong>；在函数值传递的过程中，在函数内部操作的是切片的副本，与原来的切片结构体地址不同，但是只要不发生扩容，底层的数组是相同的，<strong>但是仍需注意可能指针指向在数组的不同位置导致看到的值并不相同</strong>；如果想要相同切片，需要传入其地址；</p><p><code>append</code>操作不影响<code>&amp;path</code>即切片结构体自身的地址,在栈中（因为其长度总会发生变化），与上面相同，<strong>只要不发生扩容</strong>，底层数组指针就是相同的。</p><p>我们强烈建议在预知切片的容量或者长度的情况下，对切片的初始化声明其容量或者长度，将大大地降低扩容带来的性能损耗。</p><p><strong>这里是LTX，感谢您阅读这篇博客，人生海海，和自己对话，像只蝴蝶纵横四海。</strong></p><h2 id=引用>引用<a hidden class=anchor aria-hidden=true href=#引用>#</a></h2><ul><li>《100 Go Mistakes and How to Avoid Them (Teiva Harsanyi)》</li><li>ChatGPT</li><li>Leetcode</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://LTXWorld.github.io/tags/golang/>Golang</a></li><li><a href=https://LTXWorld.github.io/tags/%E6%BA%90%E7%A0%81/>源码</a></li><li><a href=https://LTXWorld.github.io/tags/slice%E5%88%87%E7%89%87/>Slice切片</a></li></ul><nav class=paginav><a class=prev href=https://LTXWorld.github.io/posts/020k3sep05%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8Ak3s%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%9802/><span class=title>« 上一页</span><br><span>K3sEP05——开发板上k3s存在的问题02_local-path-provisioner</span>
</a><a class=next href=https://LTXWorld.github.io/posts/018k3sep04%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E7%9A%84k3s%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/><span class=title>下一页 »</span><br><span>K3sEP04——开发板上的k3s存在的问题01之CoreDNS镜像</span></a></nav></footer><div id=tw-comment></div><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="light"?"light":"dark",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const s={src:"https://giscus.app/client.js","data-repo":"LTXWorld/LTXWorld.github.io","data-repo-id":"R_kgDONODUuA","data-category":"Announcements","data-category-id":"DIC_kwDONODUuM4CkMUw","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"zh-CN","data-loading":"lazy",crossorigin:"anonymous"},e=document.createElement("script");Object.entries(s).forEach(([t,n])=>e.setAttribute(t,n)),document.querySelector("#tw-comment").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme);const n=document.querySelector("#theme-toggle-float");n&&n.addEventListener("click",setGiscusTheme)})</script></article></main><footer class=footer><span><a href=https://LTXWorld.github.io/>©2025 LTX&rsquo;s Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><div class=ltx-music-player id=ltx-music-player role=group aria-label=背景音乐播放器><audio id=ltx-music-audio preload=metadata></audio><div class=ltx-drag-handle data-role=drag-handle title=上下拖动调整位置></div><div class=ltx-music-header><div class=ltx-music-visual><div class=ltx-disc data-role=disc aria-hidden=true><img data-role=cover alt loading=lazy decoding=async><div class=ltx-disc-center></div></div></div><div class=ltx-music-meta><span class=ltx-music-title data-role=title></span>
<span class=ltx-music-artist data-role=artist></span></div><button type=button class=ltx-music-hide data-action=collapse aria-label=隐藏播放器>&#215;</button></div><div class=ltx-music-progress data-role=progress aria-label=进度条 role=slider><div class=ltx-music-progress-fill data-role=progress-fill></div></div><div class=ltx-music-time><span data-role=current>0:00</span>
<span data-role=total>--:--</span></div><div class=ltx-music-controls><button type=button data-action=prev aria-label=上一首>⏮</button>
<button type=button data-action=toggle aria-label=播放或暂停>
<span data-icon=play>▶</span>
<span data-icon=pause>⏸</span>
</button>
<button type=button data-action=next aria-label=下一首>⏭</button>
<button type=button data-action=mute aria-label=静音或取消静音>
<span data-icon=unmuted>🔊</span>
<span data-icon=muted>🔇</span></button></div><div class=ltx-autoplay-tip data-role=tip aria-live=polite></div></div><button type=button class=ltx-music-fab id=ltx-music-fab aria-label=显示音乐播放器>&#9835;</button>
<script>window.LTX_MUSIC_CONFIG={autoplay:!0,defaultCover:"",loopPlaylist:!0,startVolume:.6,tracks:[{artist:"王力宏",file:"/audio/02 - 依然爱你.mp3",title:"依然爱你"},{artist:"王力宏",file:"/audio/05 - 改变自己.mp3",title:"改变自己"},{artist:"王力宏",file:"/audio/11 - 爱错.mp3",title:"爱错"}]},function(){const a=window.LTX_MUSIC_CONFIG||{};if(!a.tracks||!a.tracks.length)return;const e=document.getElementById("ltx-music-player"),t=e.querySelector("audio"),x=e.querySelector('[data-role="title"]'),O=e.querySelector('[data-role="artist"]'),b=e.querySelector('[data-role="progress"]'),A=e.querySelector('[data-role="progress-fill"]'),F=e.querySelector('[data-role="current"]'),M=e.querySelector('[data-role="total"]'),c=e.querySelector('[data-role="tip"]'),r=e.querySelector('[data-role="cover"]'),S=e.querySelector('[data-action="toggle"]'),y=e.querySelector('[data-action="prev"]'),k=e.querySelector('[data-action="next"]'),E=e.querySelector('[data-action="mute"]'),g=e.querySelector('[data-action="collapse"]'),i=e.querySelector('[data-role="drag-handle"]'),o=document.getElementById("ltx-music-fab"),f=(e,t,n)=>Math.min(Math.max(e,t),n),j=e=>{if(!Number.isFinite(e))return"--:--";const t=Math.floor(e/60),n=Math.floor(e%60);return`${String(t).padStart(1,"0")}:${String(n).padStart(2,"0")}`},C=-120,_=220,w=180,s={active:!1,startY:0,startOffset:0,pointerId:null},n={index:0,tracks:a.tracks,autoplay:a.autoplay!==!1,loopPlaylist:a.loopPlaylist!==!1,offset:0,collapsed:!1},h=t=>{n.offset=f(t,C,_),e.style.setProperty("--ltx-offset",`${n.offset}px`)},l=t=>{const s=Boolean(t);n.collapsed=s,e.classList.toggle("ltx-collapsed",s),s?(e.classList.remove("ltx-dragging"),n.offset=0,e.style.removeProperty("--ltx-offset"),o&&(o.classList.add("ltx-visible"),o.setAttribute("aria-hidden","false"),o.tabIndex=0)):(h(0),o&&(o.classList.remove("ltx-visible"),o.setAttribute("aria-hidden","true"),o.tabIndex=-1))},m=()=>{const n=t.muted||t.volume===0;e.classList.toggle("ltx-muted",n)};t.volume=f(a.startVolume??.6,0,1),m(),l(!1);const d=()=>{const e=t.duration||0,n=t.currentTime||0,s=e?n/e*100:0;A.style.width=`${s}%`,F.textContent=j(n),M.textContent=j(e)},u=(s,o={})=>{const l=n.tracks.length;n.index=(s%l+l)%l;const i=n.tracks[n.index];if(!i||!i.file){console.warn("LTX music player: 音频文件缺失",i),c.textContent="音频文件缺失，请检查配置";return}const u=i.cover||a.defaultCover||"";r&&(u?(r.src=u,r.alt=i.title?`${i.title} 封面`:"音乐封面",e.classList.add("ltx-has-cover")):(r.removeAttribute("src"),r.alt="",e.classList.remove("ltx-has-cover"))),x.textContent=i.title||`Track ${n.index+1}`,O.textContent=i.artist||"",t.src=i.file,e.dataset.trackIndex=n.index,c.textContent="",e.classList.remove("ltx-autoplay-blocked"),d(),o.play&&p()},p=()=>{t.play().then(()=>{e.classList.remove("ltx-autoplay-blocked"),c.textContent=""}).catch(()=>{e.classList.add("ltx-autoplay-blocked"),c.textContent="浏览器阻止了自动播放，请点击播放按钮"})},v=(e=!1)=>{const o=!t.paused||e,s=n.index+1;if(s>=n.tracks.length&&!n.loopPlaylist){t.currentTime=t.duration||0,t.pause();return}u(s,{play:o})},T=()=>{const e=!t.paused;u(n.index-1,{play:e})};if(g&&g.addEventListener("click",()=>l(!0)),o&&(o.addEventListener("click",()=>l(!1)),o.setAttribute("aria-hidden","true"),o.tabIndex=-1),i){i.style.touchAction="none",i.addEventListener("pointerdown",t=>{if(n.collapsed)return;if(s.active=!0,s.pointerId=t.pointerId,s.startY=t.clientY,s.startOffset=n.offset,i.setPointerCapture)try{i.setPointerCapture(t.pointerId)}catch{}e.classList.add("ltx-dragging")}),i.addEventListener("pointermove",e=>{if(!s.active)return;const t=e.clientY-s.startY;h(s.startOffset+t)});const t=()=>{if(!s.active)return;if(s.pointerId!==null&&i.releasePointerCapture)try{i.releasePointerCapture(s.pointerId)}catch{}s.active=!1,s.pointerId=null,e.classList.remove("ltx-dragging"),n.offset>w?l(!0):h(n.offset)};["pointerup","pointercancel"].forEach(e=>{i.addEventListener(e,t)}),i.addEventListener("pointerleave",()=>{if(!s.active)return;t()})}S.addEventListener("click",()=>{t.paused?p():t.pause()}),y.addEventListener("click",T),k.addEventListener("click",()=>v(!1)),E.addEventListener("click",()=>{t.muted=!t.muted,m()}),b.addEventListener("click",e=>{const n=b.getBoundingClientRect(),s=f((e.clientX-n.left)/n.width,0,1);Number.isFinite(t.duration)&&(t.currentTime=s*t.duration)}),t.addEventListener("timeupdate",d),t.addEventListener("loadedmetadata",d),t.addEventListener("play",()=>{e.classList.add("ltx-playing"),e.classList.remove("ltx-autoplay-blocked"),c.textContent=""}),t.addEventListener("pause",()=>{e.classList.remove("ltx-playing")}),t.addEventListener("ended",()=>{v(!0)}),t.addEventListener("volumechange",m),u(0,{play:n.autoplay})}()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>