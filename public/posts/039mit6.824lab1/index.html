<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Mit6.824Lab1流程梳理 | LTX's Blog</title>
<meta name=keywords content="Mit,lab,分布式"><meta name=description content="引子
本文记录完成 Lab01 的过程,跟着 AI 照猫画虎.
MapReduce
首先我们需要简单了解一下 MapReduce 这篇论文,其提出了分布式的思想,具体如下:

Map:将一个大的问题分解为小问题,应用用户定义的 Map 函数,生成中间键值对——文本分割为单词,输出 {world, 1} 这样的键值对
Reduce: 将中间键值对按 key 分组,应用用户定义的 Reduce 函数,生成最终输出——Reduce 对同一 key 进行计数求和 {word, count}
系统可以自动做到并行,任务调度,负载均衡,容错,让用户只需要开发 Map 和 Reduce 这两个函数

这样的一个系统由三部分组成"><meta name=author content="LTX"><link rel=canonical href=https://LTXWorld.github.io/posts/039mit6.824lab1/><link crossorigin=anonymous href=/assets/css/stylesheet.725ec5b3e73dcbb0ff6543a8256cd49aa2c4c02c9e0586f006beb2e1f1dec7f2.css integrity="sha256-cl7Fs+c9y7D/ZUOoJWzUmqLEwCyeBYbwBr6y4fHex/I=" rel="preload stylesheet" as=style><link rel=icon href=https://LTXWorld.github.io/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://LTXWorld.github.io/favicon.png><link rel=icon type=image/png sizes=32x32 href=https://LTXWorld.github.io/favicon.png><link rel=apple-touch-icon href=https://LTXWorld.github.io/favicon.png><link rel=mask-icon href=https://LTXWorld.github.io/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://LTXWorld.github.io/posts/039mit6.824lab1/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><meta property="og:url" content="https://LTXWorld.github.io/posts/039mit6.824lab1/"><meta property="og:site_name" content="LTX's Blog"><meta property="og:title" content="Mit6.824Lab1流程梳理"><meta property="og:description" content="引子 本文记录完成 Lab01 的过程,跟着 AI 照猫画虎.
MapReduce 首先我们需要简单了解一下 MapReduce 这篇论文,其提出了分布式的思想,具体如下:
Map:将一个大的问题分解为小问题,应用用户定义的 Map 函数,生成中间键值对——文本分割为单词,输出 {world, 1} 这样的键值对 Reduce: 将中间键值对按 key 分组,应用用户定义的 Reduce 函数,生成最终输出——Reduce 对同一 key 进行计数求和 {word, count} 系统可以自动做到并行,任务调度,负载均衡,容错,让用户只需要开发 Map 和 Reduce 这两个函数 这样的一个系统由三部分组成"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-19T17:22:07+08:00"><meta property="article:modified_time" content="2025-05-19T17:22:07+08:00"><meta property="article:tag" content="Mit"><meta property="article:tag" content="Lab"><meta property="article:tag" content="分布式"><meta property="og:image" content="https://LTXWorld.github.io/images/papermod-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://LTXWorld.github.io/images/papermod-cover.png"><meta name=twitter:title content="Mit6.824Lab1流程梳理"><meta name=twitter:description content="引子
本文记录完成 Lab01 的过程,跟着 AI 照猫画虎.
MapReduce
首先我们需要简单了解一下 MapReduce 这篇论文,其提出了分布式的思想,具体如下:

Map:将一个大的问题分解为小问题,应用用户定义的 Map 函数,生成中间键值对——文本分割为单词,输出 {world, 1} 这样的键值对
Reduce: 将中间键值对按 key 分组,应用用户定义的 Reduce 函数,生成最终输出——Reduce 对同一 key 进行计数求和 {word, count}
系统可以自动做到并行,任务调度,负载均衡,容错,让用户只需要开发 Map 和 Reduce 这两个函数

这样的一个系统由三部分组成"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://LTXWorld.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Mit6.824Lab1流程梳理","item":"https://LTXWorld.github.io/posts/039mit6.824lab1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Mit6.824Lab1流程梳理","name":"Mit6.824Lab1流程梳理","description":"引子 本文记录完成 Lab01 的过程,跟着 AI 照猫画虎.\nMapReduce 首先我们需要简单了解一下 MapReduce 这篇论文,其提出了分布式的思想,具体如下:\nMap:将一个大的问题分解为小问题,应用用户定义的 Map 函数,生成中间键值对——文本分割为单词,输出 {world, 1} 这样的键值对 Reduce: 将中间键值对按 key 分组,应用用户定义的 Reduce 函数,生成最终输出——Reduce 对同一 key 进行计数求和 {word, count} 系统可以自动做到并行,任务调度,负载均衡,容错,让用户只需要开发 Map 和 Reduce 这两个函数 这样的一个系统由三部分组成\n","keywords":["Mit","lab","分布式"],"articleBody":"引子 本文记录完成 Lab01 的过程,跟着 AI 照猫画虎.\nMapReduce 首先我们需要简单了解一下 MapReduce 这篇论文,其提出了分布式的思想,具体如下:\nMap:将一个大的问题分解为小问题,应用用户定义的 Map 函数,生成中间键值对——文本分割为单词,输出 {world, 1} 这样的键值对 Reduce: 将中间键值对按 key 分组,应用用户定义的 Reduce 函数,生成最终输出——Reduce 对同一 key 进行计数求和 {word, count} 系统可以自动做到并行,任务调度,负载均衡,容错,让用户只需要开发 Map 和 Reduce 这两个函数 这样的一个系统由三部分组成\nMaster: 主节点,类似于 K3s 中的 server 节点 Worker: 类似于 K3s 中的 agent 节点 分布式文件系统,例如 GFS: 存储输入数据,中间结果和最终输出 工作流程如下:\n输入数据被分割成固定大小的分片 Master 将 Map 任务分配给 Worker，Worker 读取分片，执行 Map 函数，生成中间键值对，写入本地磁盘。 中间键值对按键分区（partitioned），传输到 Reduce Worker Reduce Worker 对键值对排序、分组，执行 Reduce 函数，生成最终输出，写入分布式文件系统 而本 lab 的目标就是实现一个简化的 MapReduce 系统,模拟 Master 和 Worker. 处理任务分配、并行执行和故障容错.\nLab 实现 在本 Lab 中,我们只需要编写 src/main/mr 下的三个代码即可.\nCoordinator.go 对于 Master 节点,我们需要让他来进行调度,如何确保 Worker 们按照我们想要的方式来执行任务.\nCoordinator 首先,我们先要定义 Coordiantor 本身\ntype Coordinator struct { // Your definitions here. mu sync.Mutex // 互斥锁 files []string // 输入文件列表 nReduce int // Reduce任务数 mapTasks []Task // Map任务列表,以taskID作为下标 reduceTasks []Task // Reduce任务列表 completedMaps int // 已完成的Map任务数量 completedReds int // 已完成的Reduce任务数量 } 我们作为控制者,要获取输入的文件集合,保存 Map 和 Reduce 两种不同任务,并统计二者的初始数量与已完成的数量——用来看某类任务是否已经全部完成.\n对于这些变量,为了防止数据冲突,自然要处理并发;在这里我们使用了 mutex 直接上锁,具体操作见后文.\nTask 其次,我们需要定义有关 Task 的信息,分别是 Type 结构体和任务类型 TaskType\ntype TaskType string type Task struct { TaskID int // 任务ID TaskType TaskType // 是Map还是Reduce InputFile string // 对Map来说输入文件 OutputFile string // 对Reduce来说最终的输出文件 NReduce int // Reduce任务数 NMap int StartTime time.Time // 用于计时,看是否超时 Completed bool // } const ( Map TaskType = \"Map\" Reduce TaskType = \"Reduce\" Wait TaskType = \"Wait\" Exit TaskType = \"Exit\" ) 同时,我们还定义了一些常量表示不同任务类型.\nMakeCoordinator 这是一个初始化方法,入参已经给定,我们来初始化 Coordinator,Task切片.\nfunc MakeCoordinator(files []string, nReduce int) *Coordinator { c := Coordinator{ files: files, nReduce: nReduce, mapTasks: make([]Task, len(files)), reduceTasks: make([]Task, nReduce), completedMaps: 0, completedReds: 0, } // 初始化Map任务 for i, file := range files { c.mapTasks[i] = Task{ TaskID: i, TaskType: Map, InputFile: file, NReduce: nReduce, NMap: len(files), } } // 初始化Reduce任务 for i := 0; i \u003c nReduce; i++ { c.reduceTasks[i] = Task{ TaskID: i, TaskType: Reduce, OutputFile: fmt.Sprintf(\"mr-out-%d\", i), NReduce: nReduce, NMap: len(files), } } c.server() return \u0026c } 最终启动了 server,server 是已经写好的代码,它用来作为 Coordinator 监听相关 RPC 请求的服务端.\nRPC方法 在调度框架中, Worker 会通过发送 RPC 请求向 Master 请求资源,例如请求任务,所以我们在 Master 端需要写相对应的请求任务的逻辑.\nRequestTask 优先分配未完成或者超时的 Map 任务,所有 Map 任务完成后分配 Reduce 任务(实现了 Reduce 对 Map 的依赖关系) 由于存在并发,所以我们一开始就用 mutex 保护共享状态.\nfunc (c *Coordinator) RequestTask(args *TaskArgs, reply *TaskReply) error { c.mu.Lock() defer c.mu.Unlock() // 优先分配Map for i := range c.mapTasks { // 如果任务未完成 if !c.mapTasks[i].Completed { // 检查任务是否超时 if !c.mapTasks[i].StartTime.IsZero() \u0026\u0026 time.Since(c.mapTasks[i].StartTime) \u003e 10*time.Second { // 若超时则重新分配 c.mapTasks[i].StartTime = time.Now() reply.Task = c.mapTasks[i] return nil } else if c.mapTasks[i].StartTime.IsZero() { // 任务未分配 c.mapTasks[i].StartTime = time.Now() reply.Task = c.mapTasks[i] return nil } } } // 如果所有Map任务都完成 if c.completedMaps == len(c.mapTasks) { // 分配Reduce 任务 for i := range c.reduceTasks { if !c.reduceTasks[i].Completed { if !c.reduceTasks[i].StartTime.IsZero() \u0026\u0026 time.Since(c.reduceTasks[i].StartTime) \u003e 10*time.Second { // 若超时则重新分配 c.reduceTasks[i].StartTime = time.Now() reply.Task = c.reduceTasks[i] return nil } else if c.reduceTasks[i].StartTime.IsZero() { // 任务未分配 c.reduceTasks[i].StartTime = time.Now() reply.Task = c.reduceTasks[i] return nil } } } // 所有 reduce 完成 if c.completedReds == len(c.reduceTasks) { reply.Task.TaskType = Exit reply.Finished = true return nil } } // 无可用任务, Wo 等待 reply.Task.TaskType = Wait return nil } TaskCompleted 同时, Worker 也要向 Master 发送对应的任务处理情况通知,为了让 Master 去管理全局状态,例如已经完成的任务数的更新.\nfunc (c *Coordinator) TaskCompleted(args *TaskCompletionArgs, reply *TaskCompletionArgs) error { c.mu.Lock() defer c.mu.Unlock() switch args.TaskType { case Map: if args.TaskID \u003c len(c.mapTasks) \u0026\u0026 !c.mapTasks[args.TaskID].Completed { c.mapTasks[args.TaskID].Completed = true // 在范围内且传回来未完成? c.completedMaps++ log.Printf(\"Map任务 %d 已完成\", args.TaskID) } case Reduce: if args.TaskID \u003c len(c.reduceTasks) \u0026\u0026 !c.reduceTasks[args.TaskID].Completed { c.reduceTasks[args.TaskID].Completed = true c.completedReds++ log.Printf(\"Reduce任务 %d 已完成\", args.TaskID) } } return nil } 如果报告的的是 Map 任务且状态为未完成,我们才会去更新任务状态为已完成.\n为了保证任务状态的幂等性——重复通知不改变任务状态,所以我们只有未完成才去更新(通知了一定是完成了) 之后的通知此任务状态为已完成,不会再更新 Done 最后,主函数需要调用 Done 来判断整个系统是否运行结束,我们根据已完成的任务数与预期的任务数对比来判断.\nfunc (c *Coordinator) Done() bool { //ret := false // Your code here. c.mu.Lock() defer c.mu.Unlock() return c.completedMaps == len(c.mapTasks) \u0026\u0026 c.completedReds == len(c.reduceTasks) } rpc.go 在 lab 中, Master 和 Worker 是通过套接字 socket 来通信的,在 rpc.go 中我们需要定义 RPC 通信的请求和响应结构,可以携带一些状态或信息.\n通常以请求和响应参数成对出现,从 Worker 请求到 Master,从 Master 响应到 Worker\n与任务的请求有关的:\ntype TaskArgs struct{} type TaskReply struct { Task Task Finished bool } 与任务完成情况有关的:\ntype TaskCompletionArgs struct { TaskID int TaskType TaskType } type TaskCompletionReply struct{} Worker 需要向 Master 传递 TaskID 等信息供后者使用. Master 无需向 Worker 传递什么信息. 值得注意的是,在 RPC 调用中,我们要保证 RPC 的参数类型在调用双方是匹配的,这里我们都用了之前声明的结构体,没有此问题.\n后续更新,其实有关 Task 的定义也该放在这里.\nworker.go 在 worker 中,我们就要实际进行 Map 和 Reduce 的相关操作了. 为了本文的连续性,我们先写有关于 RPC 的相关代码.\nRPC相关 我们需要一个 call 方法来调用 Master 中的方法,具体就是靠 rpc.DialHTTP 打开一个连接,Worker 作为客户端去调用 Call 方法\nfunc call(rpcname string, args interface{}, reply interface{}) bool { // c, err := rpc.DialHTTP(\"tcp\", \"127.0.0.1\"+\":1234\") sockname := coordinatorSock() c, err := rpc.DialHTTP(\"unix\", sockname) if err != nil { log.Fatal(\"dialing:\", err) } defer c.Close() err = c.Call(rpcname, args, reply) if err == nil { return true } fmt.Println(err) return false } 同时我们也要写与服务端,也就是 Master 中对应的 RPC 方法,本质上是通过上面的 call 方法调用服务端上的方法.\nrequestTask,请求任务.\nfunc requestTask() (Task, error) { // declare an argument structure. args := \u0026TaskArgs{} reply := \u0026TaskReply{} ok := call(\"Coordinator.RequestTask\", args, reply) if !ok { return Task{}, fmt.Errorf(\"RPC调用失败\") } // declare a reply structure. //reply := ExampleReply{} return reply.Task, nil } reportTaskCompletion,报告任务完成情况.\nfunc reportTaskCompletion(taskID int, taskType TaskType) { args := \u0026TaskCompletionArgs{ TaskID: taskID, TaskType: taskType, } var reply struct{} ok := call(\"Coordinator.TaskCompleted\", args, \u0026reply) if !ok { log.Printf(\"报告任务完成失败: TaskID=%d, Type=%s\", taskID, taskType) } } Worker本身 Worker 的主要的逻辑是请求任务,执行任务(如果没有任务则等待),所有任务执行完后退出.\nfunc Worker(mapf func(string, string) []KeyValue, reducef func(string, []string) string) { // Your worker implementation here. // 注册RPC客户端,连接Coordinator,持续请求任务直到收到退出信号 for { // 请求任务 task, err := requestTask() if err != nil { log.Printf(\"获取任务失败: %v\", err) time.Sleep(2 * time.Second) continue } // 执行任务 switch task.TaskType { case Map: log.Printf(\"开始处理Map任务: %d, 文件: %s\", task.TaskID, task.InputFile) executeMapTask(task, mapf) reportTaskCompletion(task.TaskID, task.TaskType) case Reduce: log.Printf(\"开始处理Reduce任务: %d\", task.TaskID) executeReduceTask(task, reducef) reportTaskCompletion(task.TaskID, task.TaskType) case Wait: log.Printf(\"没有可用任务,等待中...\") time.Sleep(2 * time.Second) case Exit: log.Println(\"所有任务已完成,Worker退出\") return } } } 请求任务失败的话暂停2秒继续请求 根据请求到的任务类型来进行指定的操作,具体的操作见下文. executeMapTask 用于处理 Map 任务\n读取输入文件,将其内容保存在 content 中 调用 mapf 方法处理内容,得到中间结果 kv pairs 将这些对根据 reduceID(即相同的 key 组成一个集合)保存在一个二维切片中 将这些 pairs 编码为 JSON 格式并存储在临时文件中 要注意对文件的命名符合实验要求 将上述操作放在一个 goroutine 中执行,并且保证不发生冲突 func executeMapTask(task Task, mapf func(string, string) []KeyValue) { // 读取输入文件 file, err := os.Open(task.InputFile) if err != nil { log.Fatalf(\"Cannot open %v\", task.InputFile) } defer file.Close() content, _ := io.ReadAll(file) // 调用Map kvs := mapf(task.InputFile, string(content)) // 按 Reduce 任务分区存储中间结果 nReduce := task.NReduce intermediate := make([][]KeyValue, nReduce) // reduceID -\u003e kv ? for _, kv := range kvs { reduceID := ihash(kv.Key) % nReduce intermediate[reduceID] = append(intermediate[reduceID], kv) } // 写入临时文件并原子重命名 var wg sync.WaitGroup for i := 0; i \u003c nReduce; i++ { wg.Add(1) go func(reduceID int, data []KeyValue) { defer wg.Done() tempFile, err := os.CreateTemp(\"\", fmt.Sprintf(\"mr-%d-%d.tmp\", task.TaskID, reduceID)) if err != nil { log.Fatalf(\"Can't create tempFile: %v\", err) } defer tempFile.Close() encoder := json.NewEncoder(tempFile) for _, kv := range data { if err := encoder.Encode(\u0026kv); err != nil { log.Fatalf(\"编码 JSON 失败: %v\", err) } } // 原子重命名为最终文件名 finalName := fmt.Sprintf(\"mr-%d-%d\", task.TaskID, reduceID) if err := os.Rename(tempFile.Name(), finalName); err != nil { log.Fatalf(\"重命名文件失败: %v\", err) } }(i, intermediate[i]) } wg.Wait() } executeReduceTask 几乎同理,我们处理刚才的 Map 过程产生的文件,读取其中信息并进行解码,最终保存在一个一维切片中.\n相同key作为一组调用 reducef 方法进行处理,处理完后的结果写入到输出文件中.\nfunc executeReduceTask(task Task, reducef func(string, []string) string) { // 收集所有Map任务的中间文件 var kvs []KeyValue for mapID := 0; mapID \u003c task.NMap; mapID++ { fileName := fmt.Sprintf(\"mr-%d-%d\", mapID, task.TaskID) file, err := os.Open(fileName) if err != nil { continue // 忽略未完成的 Map 任务文件 } decoder := json.NewDecoder(file) for { var kv KeyValue if err := decoder.Decode(\u0026kv); err != nil { break // 读完所有记录 } kvs = append(kvs, kv) } file.Close() } // 按 Key 排序 sort.Slice(kvs, func(i, j int) bool { return kvs[i].Key \u003c kvs[j].Key }) // 分组调用Reduce,找key相同的集合放到values中 var results []string i := 0 for i \u003c len(kvs) { j := i for j \u003c len(kvs) \u0026\u0026 kvs[j].Key == kvs[i].Key { j++ } keys := kvs[i].Key values := []string{} for k := i; k \u003c j; k++ { values = append(values, kvs[k].Value) } result := reducef(keys, values) results = append(results, fmt.Sprintf(\"%v %v\\n\", keys, result)) i = j } // 写入 Reduce 输出文件 tempFile, err := os.CreateTemp(\"\", fmt.Sprintf(\"mr-out-%d.tmp\", task.TaskID)) if err != nil { log.Fatalf(\"创建临时文件失败: %v\", err) } defer tempFile.Close() _, err = tempFile.WriteString(strings.Join(results, \"\")) if err != nil { log.Fatalf(\"写入文件失败: %v\", err) } finalName := fmt.Sprintf(\"mr-out-%d\", task.TaskID) if err := os.Rename(tempFile.Name(), finalName); err != nil { log.Fatalf(\"文件重命名失败: %v\", err) } } 至此, Worker.go 结束. 最后执行实验命令可以通过实验.\n总结 至此,就是我对于 lab1 的做法流程梳理,实现了一个小型的 MapReduce 分布式框架结构,这对于我自己目前在做的毕业设计项目也有很好的启发.\n特别是在 Task 如何定义,在 lab 中我们定义为了 go 中的 struct,在未来要写的分布式框架中我们对于不同的 Task 的定义是通过 json 文件进行定义,来确定其所占据的资源信息.\n这里是LTX，感谢您阅读这篇博客，人生海海，和自己对话，像只蝴蝶纵横四海。\n引用 https://pdos.csail.mit.edu/6.824/labs/lab-mr.html ","wordCount":"3706","inLanguage":"zh","image":"https://LTXWorld.github.io/images/papermod-cover.png","datePublished":"2025-05-19T17:22:07+08:00","dateModified":"2025-05-19T17:22:07+08:00","author":{"@type":"Person","name":"LTX"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://LTXWorld.github.io/posts/039mit6.824lab1/"},"publisher":{"@type":"Organization","name":"LTX's Blog","logo":{"@type":"ImageObject","url":"https://LTXWorld.github.io/favicon.png"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://LTXWorld.github.io/ accesskey=h title="LTX's Blog (Alt + H)">LTX's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://LTXWorld.github.io/ title="LTX's Blog"><span>首页</span></a></li><li><a href=https://LTXWorld.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://LTXWorld.github.io/categories/ title=Categories><span>分类</span></a></li><li><a href=https://LTXWorld.github.io/tags/ title=Tags><span>标签</span></a></li><li><a href=https://LTXWorld.github.io/search/ title=搜索><span>搜索</span></a></li><li><a href=https://LTXWorld.github.io/about/ title=后花园><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Mit6.824Lab1流程梳理</h1><div class=post-meta><span title='2025-05-19 17:22:07 +0800 CST'>五月 19, 2025</span>&nbsp;·&nbsp;8 分钟&nbsp;·&nbsp;LTX</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%bc%95%e5%ad%90 aria-label=引子>引子</a></li><li><a href=#mapreduce aria-label=MapReduce>MapReduce</a></li><li><a href=#lab-%e5%ae%9e%e7%8e%b0 aria-label="Lab 实现">Lab 实现</a><ul><li><a href=#coordinatorgo aria-label=Coordinator.go>Coordinator.go</a><ul><li><a href=#coordinator aria-label=Coordinator>Coordinator</a></li><li><a href=#task aria-label=Task>Task</a></li><li><a href=#makecoordinator aria-label=MakeCoordinator>MakeCoordinator</a></li><li><a href=#rpc%e6%96%b9%e6%b3%95 aria-label=RPC方法>RPC方法</a><ul><li><a href=#requesttask aria-label=RequestTask>RequestTask</a></li><li><a href=#taskcompleted aria-label=TaskCompleted>TaskCompleted</a></li></ul></li><li><a href=#done aria-label=Done>Done</a></li></ul></li><li><a href=#rpcgo aria-label=rpc.go>rpc.go</a></li><li><a href=#workergo aria-label=worker.go>worker.go</a><ul><li><a href=#rpc%e7%9b%b8%e5%85%b3 aria-label=RPC相关>RPC相关</a></li><li><a href=#worker%e6%9c%ac%e8%ba%ab aria-label=Worker本身>Worker本身</a></li><li><a href=#executemaptask aria-label=executeMapTask>executeMapTask</a></li><li><a href=#executereducetask aria-label=executeReduceTask>executeReduceTask</a></li></ul></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li><li><a href=#%e5%bc%95%e7%94%a8 aria-label=引用>引用</a></li></ul></div></details></div><div class=post-content><h2 id=引子>引子<a hidden class=anchor aria-hidden=true href=#引子>#</a></h2><p>本文记录完成 <a href=https://pdos.csail.mit.edu/6.824/labs/lab-mr.html>Lab01 </a>的过程,跟着 AI 照猫画虎.</p><h2 id=mapreduce>MapReduce<a hidden class=anchor aria-hidden=true href=#mapreduce>#</a></h2><p>首先我们需要简单了解一下 MapReduce 这篇论文,其提出了分布式的思想,具体如下:</p><ul><li>Map:将一个大的问题分解为小问题,应用用户定义的 Map 函数,生成中间键值对——文本分割为单词,输出 <code>{world, 1}</code> 这样的键值对</li><li>Reduce: 将中间键值对按 key 分组,应用用户定义的 Reduce 函数,生成最终输出——Reduce 对同一 key 进行计数求和 <code>{word, count}</code></li><li>系统可以自动做到<strong>并行,任务调度,负载均衡,容错</strong>,让用户只需要开发 Map 和 Reduce 这两个函数</li></ul><p>这样的一个系统由三部分组成</p><ul><li>Master: 主节点,类似于 K3s 中的 server 节点</li><li>Worker: 类似于 K3s 中的 agent 节点</li><li>分布式文件系统,例如 GFS: 存储输入数据,中间结果和最终输出</li></ul><p>工作流程如下:</p><ol><li>输入数据被分割成固定大小的分片</li><li>Master 将 Map 任务分配给 Worker，Worker 读取分片，执行 Map 函数，生成中间键值对，写入本地磁盘。</li><li>中间键值对按键分区（partitioned），传输到 Reduce Worker</li><li>Reduce Worker 对键值对排序、分组，执行 Reduce 函数，生成最终输出，写入分布式文件系统</li></ol><p>而本 lab 的目标就是实现一个简化的 MapReduce 系统,模拟 Master 和 Worker.
处理任务分配、并行执行和故障容错.</p><h2 id=lab-实现>Lab 实现<a hidden class=anchor aria-hidden=true href=#lab-实现>#</a></h2><p>在本 Lab 中,我们只需要编写 <code>src/main/mr</code> 下的三个代码即可.</p><h3 id=coordinatorgo>Coordinator.go<a hidden class=anchor aria-hidden=true href=#coordinatorgo>#</a></h3><p>对于 Master 节点,我们需要让他来进行调度,如何确保 Worker 们按照我们想要的方式来执行任务.</p><h4 id=coordinator>Coordinator<a hidden class=anchor aria-hidden=true href=#coordinator>#</a></h4><p>首先,我们先要定义 Coordiantor 本身</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Coordinator</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Your definitions here.</span>
</span></span><span class=line><span class=cl>	<span class=nx>mu</span>            <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span> <span class=c1>// 互斥锁</span>
</span></span><span class=line><span class=cl>	<span class=nx>files</span>         <span class=p>[]</span><span class=kt>string</span>   <span class=c1>// 输入文件列表</span>
</span></span><span class=line><span class=cl>	<span class=nx>nReduce</span>       <span class=kt>int</span>        <span class=c1>// Reduce任务数</span>
</span></span><span class=line><span class=cl>	<span class=nx>mapTasks</span>      <span class=p>[]</span><span class=nx>Task</span>     <span class=c1>// Map任务列表,以taskID作为下标</span>
</span></span><span class=line><span class=cl>	<span class=nx>reduceTasks</span>   <span class=p>[]</span><span class=nx>Task</span>     <span class=c1>// Reduce任务列表</span>
</span></span><span class=line><span class=cl>	<span class=nx>completedMaps</span> <span class=kt>int</span>        <span class=c1>// 已完成的Map任务数量</span>
</span></span><span class=line><span class=cl>	<span class=nx>completedReds</span> <span class=kt>int</span>        <span class=c1>// 已完成的Reduce任务数量</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>我们作为控制者,要获取输入的文件集合,保存 Map 和 Reduce 两种不同任务,并统计二者的初始数量与已完成的数量——用来看某类任务是否已经全部完成.</p><p>对于这些变量,为了防止数据冲突,自然要处理并发;在这里我们使用了 mutex 直接上锁,具体操作见后文.</p><h4 id=task>Task<a hidden class=anchor aria-hidden=true href=#task>#</a></h4><p>其次,我们需要定义有关 Task 的信息,分别是 Type 结构体和任务类型 TaskType</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>TaskType</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Task</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>TaskID</span>     <span class=kt>int</span>      <span class=c1>// 任务ID</span>
</span></span><span class=line><span class=cl>	<span class=nx>TaskType</span>   <span class=nx>TaskType</span> <span class=c1>// 是Map还是Reduce</span>
</span></span><span class=line><span class=cl>	<span class=nx>InputFile</span>  <span class=kt>string</span> <span class=c1>// 对Map来说输入文件</span>
</span></span><span class=line><span class=cl>	<span class=nx>OutputFile</span> <span class=kt>string</span> <span class=c1>// 对Reduce来说最终的输出文件</span>
</span></span><span class=line><span class=cl>	<span class=nx>NReduce</span>    <span class=kt>int</span> <span class=c1>// Reduce任务数</span>
</span></span><span class=line><span class=cl>	<span class=nx>NMap</span>       <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>StartTime</span>  <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span> <span class=c1>// 用于计时,看是否超时</span>
</span></span><span class=line><span class=cl>	<span class=nx>Completed</span>  <span class=kt>bool</span>
</span></span><span class=line><span class=cl>	<span class=c1>//</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=nx>Map</span>    <span class=nx>TaskType</span> <span class=p>=</span> <span class=s>&#34;Map&#34;</span>
</span></span><span class=line><span class=cl>	<span class=nx>Reduce</span> <span class=nx>TaskType</span> <span class=p>=</span> <span class=s>&#34;Reduce&#34;</span>
</span></span><span class=line><span class=cl>	<span class=nx>Wait</span>   <span class=nx>TaskType</span> <span class=p>=</span> <span class=s>&#34;Wait&#34;</span>
</span></span><span class=line><span class=cl>	<span class=nx>Exit</span>   <span class=nx>TaskType</span> <span class=p>=</span> <span class=s>&#34;Exit&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span> 
</span></span></code></pre></div><p>同时,我们还定义了一些常量表示不同任务类型.</p><h4 id=makecoordinator>MakeCoordinator<a hidden class=anchor aria-hidden=true href=#makecoordinator>#</a></h4><p>这是一个初始化方法,入参已经给定,我们来初始化 Coordinator,Task切片.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>MakeCoordinator</span><span class=p>(</span><span class=nx>files</span> <span class=p>[]</span><span class=kt>string</span><span class=p>,</span> <span class=nx>nReduce</span> <span class=kt>int</span><span class=p>)</span> <span class=o>*</span><span class=nx>Coordinator</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span> <span class=o>:=</span> <span class=nx>Coordinator</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>files</span><span class=p>:</span>         <span class=nx>files</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>nReduce</span><span class=p>:</span>       <span class=nx>nReduce</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>mapTasks</span><span class=p>:</span>      <span class=nb>make</span><span class=p>([]</span><span class=nx>Task</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>files</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>		<span class=nx>reduceTasks</span><span class=p>:</span>   <span class=nb>make</span><span class=p>([]</span><span class=nx>Task</span><span class=p>,</span> <span class=nx>nReduce</span><span class=p>),</span>
</span></span><span class=line><span class=cl>		<span class=nx>completedMaps</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>completedReds</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 初始化Map任务</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>file</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>files</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>mapTasks</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>Task</span><span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>TaskID</span><span class=p>:</span>    <span class=nx>i</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=nx>TaskType</span><span class=p>:</span>  <span class=nx>Map</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=nx>InputFile</span><span class=p>:</span> <span class=nx>file</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=nx>NReduce</span><span class=p>:</span>   <span class=nx>nReduce</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=nx>NMap</span><span class=p>:</span>      <span class=nb>len</span><span class=p>(</span><span class=nx>files</span><span class=p>),</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 初始化Reduce任务</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>nReduce</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>reduceTasks</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>Task</span><span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>TaskID</span><span class=p>:</span>     <span class=nx>i</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=nx>TaskType</span><span class=p>:</span>   <span class=nx>Reduce</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=nx>OutputFile</span><span class=p>:</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;mr-out-%d&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>),</span>
</span></span><span class=line><span class=cl>			<span class=nx>NReduce</span><span class=p>:</span>    <span class=nx>nReduce</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=nx>NMap</span><span class=p>:</span>       <span class=nb>len</span><span class=p>(</span><span class=nx>files</span><span class=p>),</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>server</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>c</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>最终启动了 server,server 是已经写好的代码,它用来作为 Coordinator 监听相关 RPC 请求的服务端.</p><h4 id=rpc方法>RPC方法<a hidden class=anchor aria-hidden=true href=#rpc方法>#</a></h4><p>在调度框架中, Worker 会通过发送 RPC 请求向 Master 请求资源,例如请求任务,所以我们在 Master 端需要写相对应的请求任务的逻辑.</p><h5 id=requesttask>RequestTask<a hidden class=anchor aria-hidden=true href=#requesttask>#</a></h5><p>优先分配未完成或者超时的 Map 任务,所有 Map 任务完成后分配 Reduce 任务(实现了 Reduce 对 Map 的依赖关系)
由于存在并发,所以我们一开始就用 mutex 保护共享状态.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>Coordinator</span><span class=p>)</span> <span class=nf>RequestTask</span><span class=p>(</span><span class=nx>args</span> <span class=o>*</span><span class=nx>TaskArgs</span><span class=p>,</span> <span class=nx>reply</span> <span class=o>*</span><span class=nx>TaskReply</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 优先分配Map</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>c</span><span class=p>.</span><span class=nx>mapTasks</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 如果任务未完成</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>!</span><span class=nx>c</span><span class=p>.</span><span class=nx>mapTasks</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>Completed</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 检查任务是否超时</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>!</span><span class=nx>c</span><span class=p>.</span><span class=nx>mapTasks</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>StartTime</span><span class=p>.</span><span class=nf>IsZero</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Since</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>mapTasks</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>StartTime</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>10</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=c1>// 若超时则重新分配</span>
</span></span><span class=line><span class=cl>				<span class=nx>c</span><span class=p>.</span><span class=nx>mapTasks</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>StartTime</span> <span class=p>=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span>
</span></span><span class=line><span class=cl>				<span class=nx>reply</span><span class=p>.</span><span class=nx>Task</span> <span class=p>=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>mapTasks</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>mapTasks</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>StartTime</span><span class=p>.</span><span class=nf>IsZero</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=c1>// 任务未分配</span>
</span></span><span class=line><span class=cl>				<span class=nx>c</span><span class=p>.</span><span class=nx>mapTasks</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>StartTime</span> <span class=p>=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span>
</span></span><span class=line><span class=cl>				<span class=nx>reply</span><span class=p>.</span><span class=nx>Task</span> <span class=p>=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>mapTasks</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 如果所有Map任务都完成</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>completedMaps</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>mapTasks</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 分配Reduce 任务</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>c</span><span class=p>.</span><span class=nx>reduceTasks</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>!</span><span class=nx>c</span><span class=p>.</span><span class=nx>reduceTasks</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>Completed</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=p>!</span><span class=nx>c</span><span class=p>.</span><span class=nx>reduceTasks</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>StartTime</span><span class=p>.</span><span class=nf>IsZero</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Since</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>reduceTasks</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>StartTime</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>10</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=c1>// 若超时则重新分配</span>
</span></span><span class=line><span class=cl>					<span class=nx>c</span><span class=p>.</span><span class=nx>reduceTasks</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>StartTime</span> <span class=p>=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span>
</span></span><span class=line><span class=cl>					<span class=nx>reply</span><span class=p>.</span><span class=nx>Task</span> <span class=p>=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>reduceTasks</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>					<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>reduceTasks</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>StartTime</span><span class=p>.</span><span class=nf>IsZero</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=c1>// 任务未分配</span>
</span></span><span class=line><span class=cl>					<span class=nx>c</span><span class=p>.</span><span class=nx>reduceTasks</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>StartTime</span> <span class=p>=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span>
</span></span><span class=line><span class=cl>					<span class=nx>reply</span><span class=p>.</span><span class=nx>Task</span> <span class=p>=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>reduceTasks</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>					<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 所有 reduce 完成</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>completedReds</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>reduceTasks</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>reply</span><span class=p>.</span><span class=nx>Task</span><span class=p>.</span><span class=nx>TaskType</span> <span class=p>=</span> <span class=nx>Exit</span>
</span></span><span class=line><span class=cl>			<span class=nx>reply</span><span class=p>.</span><span class=nx>Finished</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 无可用任务, Wo 等待</span>
</span></span><span class=line><span class=cl>	<span class=nx>reply</span><span class=p>.</span><span class=nx>Task</span><span class=p>.</span><span class=nx>TaskType</span> <span class=p>=</span> <span class=nx>Wait</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h5 id=taskcompleted>TaskCompleted<a hidden class=anchor aria-hidden=true href=#taskcompleted>#</a></h5><p>同时, Worker 也要向 Master 发送对应的任务处理情况通知,为了让 Master 去管理全局状态,例如已经完成的任务数的更新.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>Coordinator</span><span class=p>)</span> <span class=nf>TaskCompleted</span><span class=p>(</span><span class=nx>args</span> <span class=o>*</span><span class=nx>TaskCompletionArgs</span><span class=p>,</span> <span class=nx>reply</span> <span class=o>*</span><span class=nx>TaskCompletionArgs</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>switch</span> <span class=nx>args</span><span class=p>.</span><span class=nx>TaskType</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>Map</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>args</span><span class=p>.</span><span class=nx>TaskID</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>mapTasks</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>c</span><span class=p>.</span><span class=nx>mapTasks</span><span class=p>[</span><span class=nx>args</span><span class=p>.</span><span class=nx>TaskID</span><span class=p>].</span><span class=nx>Completed</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>c</span><span class=p>.</span><span class=nx>mapTasks</span><span class=p>[</span><span class=nx>args</span><span class=p>.</span><span class=nx>TaskID</span><span class=p>].</span><span class=nx>Completed</span> <span class=p>=</span> <span class=kc>true</span> <span class=c1>// 在范围内且传回来未完成?</span>
</span></span><span class=line><span class=cl>			<span class=nx>c</span><span class=p>.</span><span class=nx>completedMaps</span><span class=o>++</span>
</span></span><span class=line><span class=cl>			<span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Map任务 %d 已完成&#34;</span><span class=p>,</span> <span class=nx>args</span><span class=p>.</span><span class=nx>TaskID</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>Reduce</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>args</span><span class=p>.</span><span class=nx>TaskID</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>reduceTasks</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>c</span><span class=p>.</span><span class=nx>reduceTasks</span><span class=p>[</span><span class=nx>args</span><span class=p>.</span><span class=nx>TaskID</span><span class=p>].</span><span class=nx>Completed</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>c</span><span class=p>.</span><span class=nx>reduceTasks</span><span class=p>[</span><span class=nx>args</span><span class=p>.</span><span class=nx>TaskID</span><span class=p>].</span><span class=nx>Completed</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>			<span class=nx>c</span><span class=p>.</span><span class=nx>completedReds</span><span class=o>++</span>
</span></span><span class=line><span class=cl>			<span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Reduce任务 %d 已完成&#34;</span><span class=p>,</span> <span class=nx>args</span><span class=p>.</span><span class=nx>TaskID</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>如果报告的的是 Map 任务且状态为未完成,我们才会去更新任务状态为已完成.</p><ul><li>为了保证任务状态的幂等性——重复通知不改变任务状态,所以我们只有未完成才去更新(通知了一定是完成了)</li><li>之后的通知此任务状态为已完成,不会再更新</li></ul><h4 id=done>Done<a hidden class=anchor aria-hidden=true href=#done>#</a></h4><p>最后,主函数需要调用 Done 来判断整个系统是否运行结束,我们根据已完成的任务数与预期的任务数对比来判断.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>Coordinator</span><span class=p>)</span> <span class=nf>Done</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>//ret := false</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Your code here.</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>c</span><span class=p>.</span><span class=nx>completedMaps</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>mapTasks</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=nx>c</span><span class=p>.</span><span class=nx>completedReds</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>reduceTasks</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=rpcgo>rpc.go<a hidden class=anchor aria-hidden=true href=#rpcgo>#</a></h3><p>在 lab 中, Master 和 Worker 是通过套接字 socket 来通信的,在 rpc.go 中我们需要定义 RPC 通信的请求和响应结构,可以携带一些状态或信息.</p><p>通常以请求和响应参数成对出现,从 Worker 请求到 Master,从 Master 响应到 Worker</p><p>与任务的请求有关的:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>TaskArgs</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>TaskReply</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Task</span>     <span class=nx>Task</span>
</span></span><span class=line><span class=cl>	<span class=nx>Finished</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>与任务完成情况有关的:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>TaskCompletionArgs</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>TaskID</span>   <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>TaskType</span> <span class=nx>TaskType</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>TaskCompletionReply</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span></code></pre></div><ul><li>Worker 需要向 Master 传递 TaskID 等信息供后者使用.</li><li>Master 无需向 Worker 传递什么信息.</li></ul><p>值得注意的是,在 RPC 调用中,我们要保证 RPC 的参数类型在调用双方是匹配的,这里我们都用了之前声明的结构体,没有此问题.</p><p>后续更新,其实有关 Task 的定义也该放在这里.</p><h3 id=workergo>worker.go<a hidden class=anchor aria-hidden=true href=#workergo>#</a></h3><p>在 worker 中,我们就要实际进行 Map 和 Reduce 的相关操作了.
为了本文的连续性,我们先写有关于 RPC 的相关代码.</p><h4 id=rpc相关>RPC相关<a hidden class=anchor aria-hidden=true href=#rpc相关>#</a></h4><p>我们需要一个 call 方法来调用 Master 中的方法,具体就是靠 <code>rpc.DialHTTP</code> 打开一个连接,Worker 作为客户端去调用 <strong>Call</strong> 方法</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>call</span><span class=p>(</span><span class=nx>rpcname</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>args</span> <span class=kd>interface</span><span class=p>{},</span> <span class=nx>reply</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// c, err := rpc.DialHTTP(&#34;tcp&#34;, &#34;127.0.0.1&#34;+&#34;:1234&#34;)</span>
</span></span><span class=line><span class=cl>	<span class=nx>sockname</span> <span class=o>:=</span> <span class=nf>coordinatorSock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rpc</span><span class=p>.</span><span class=nf>DialHTTP</span><span class=p>(</span><span class=s>&#34;unix&#34;</span><span class=p>,</span> <span class=nx>sockname</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=s>&#34;dialing:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>err</span> <span class=p>=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Call</span><span class=p>(</span><span class=nx>rpcname</span><span class=p>,</span> <span class=nx>args</span><span class=p>,</span> <span class=nx>reply</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>同时我们也要写与服务端,也就是 Master 中对应的 RPC 方法,<strong>本质上是通过上面的 call 方法调用服务端上的方法.</strong></p><p>requestTask,请求任务.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>requestTask</span><span class=p>()</span> <span class=p>(</span><span class=nx>Task</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// declare an argument structure.</span>
</span></span><span class=line><span class=cl>	<span class=nx>args</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>TaskArgs</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>reply</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>TaskReply</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>ok</span> <span class=o>:=</span> <span class=nf>call</span><span class=p>(</span><span class=s>&#34;Coordinator.RequestTask&#34;</span><span class=p>,</span> <span class=nx>args</span><span class=p>,</span> <span class=nx>reply</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>Task</span><span class=p>{},</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;RPC调用失败&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// declare a reply structure.</span>
</span></span><span class=line><span class=cl>	<span class=c1>//reply := ExampleReply{}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>reply</span><span class=p>.</span><span class=nx>Task</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>reportTaskCompletion,报告任务完成情况.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>reportTaskCompletion</span><span class=p>(</span><span class=nx>taskID</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>taskType</span> <span class=nx>TaskType</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>args</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>TaskCompletionArgs</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>TaskID</span><span class=p>:</span>   <span class=nx>taskID</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>TaskType</span><span class=p>:</span> <span class=nx>taskType</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>reply</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>ok</span> <span class=o>:=</span> <span class=nf>call</span><span class=p>(</span><span class=s>&#34;Coordinator.TaskCompleted&#34;</span><span class=p>,</span> <span class=nx>args</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>reply</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;报告任务完成失败: TaskID=%d, Type=%s&#34;</span><span class=p>,</span> <span class=nx>taskID</span><span class=p>,</span> <span class=nx>taskType</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=worker本身>Worker本身<a hidden class=anchor aria-hidden=true href=#worker本身>#</a></h4><p>Worker 的主要的逻辑是请求任务,执行任务(如果没有任务则等待),所有任务执行完后退出.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Worker</span><span class=p>(</span><span class=nx>mapf</span> <span class=kd>func</span><span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>string</span><span class=p>)</span> <span class=p>[]</span><span class=nx>KeyValue</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=nx>reducef</span> <span class=kd>func</span><span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=p>[]</span><span class=kt>string</span><span class=p>)</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Your worker implementation here.</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 注册RPC客户端,连接Coordinator,持续请求任务直到收到退出信号</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 请求任务</span>
</span></span><span class=line><span class=cl>		<span class=nx>task</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>requestTask</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;获取任务失败: %v&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// 执行任务</span>
</span></span><span class=line><span class=cl>		<span class=k>switch</span> <span class=nx>task</span><span class=p>.</span><span class=nx>TaskType</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>Map</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;开始处理Map任务: %d, 文件: %s&#34;</span><span class=p>,</span> <span class=nx>task</span><span class=p>.</span><span class=nx>TaskID</span><span class=p>,</span> <span class=nx>task</span><span class=p>.</span><span class=nx>InputFile</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nf>executeMapTask</span><span class=p>(</span><span class=nx>task</span><span class=p>,</span> <span class=nx>mapf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nf>reportTaskCompletion</span><span class=p>(</span><span class=nx>task</span><span class=p>.</span><span class=nx>TaskID</span><span class=p>,</span> <span class=nx>task</span><span class=p>.</span><span class=nx>TaskType</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>Reduce</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;开始处理Reduce任务: %d&#34;</span><span class=p>,</span> <span class=nx>task</span><span class=p>.</span><span class=nx>TaskID</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nf>executeReduceTask</span><span class=p>(</span><span class=nx>task</span><span class=p>,</span> <span class=nx>reducef</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nf>reportTaskCompletion</span><span class=p>(</span><span class=nx>task</span><span class=p>.</span><span class=nx>TaskID</span><span class=p>,</span> <span class=nx>task</span><span class=p>.</span><span class=nx>TaskType</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>Wait</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;没有可用任务,等待中...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>Exit</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;所有任务已完成,Worker退出&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>请求任务失败的话暂停2秒继续请求</li><li>根据请求到的任务类型来进行指定的操作,具体的操作见下文.</li></ul><h4 id=executemaptask>executeMapTask<a hidden class=anchor aria-hidden=true href=#executemaptask>#</a></h4><p>用于处理 Map 任务</p><ul><li>读取输入文件,将其内容保存在 content 中</li><li>调用 mapf 方法处理内容,得到中间结果 kv pairs</li><li>将这些对根据 reduceID(即相同的 key 组成一个集合)保存在一个二维切片中</li><li>将这些 pairs 编码为 JSON 格式并存储在临时文件中</li><li>要注意对文件的命名符合实验要求</li><li>将上述操作放在一个 goroutine 中执行,并且保证不发生冲突</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>executeMapTask</span><span class=p>(</span><span class=nx>task</span> <span class=nx>Task</span><span class=p>,</span> <span class=nx>mapf</span> <span class=kd>func</span><span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>string</span><span class=p>)</span> <span class=p>[]</span><span class=nx>KeyValue</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 读取输入文件</span>
</span></span><span class=line><span class=cl>	<span class=nx>file</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Open</span><span class=p>(</span><span class=nx>task</span><span class=p>.</span><span class=nx>InputFile</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;Cannot open %v&#34;</span><span class=p>,</span> <span class=nx>task</span><span class=p>.</span><span class=nx>InputFile</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>file</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>content</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>io</span><span class=p>.</span><span class=nf>ReadAll</span><span class=p>(</span><span class=nx>file</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 调用Map</span>
</span></span><span class=line><span class=cl>	<span class=nx>kvs</span> <span class=o>:=</span> <span class=nf>mapf</span><span class=p>(</span><span class=nx>task</span><span class=p>.</span><span class=nx>InputFile</span><span class=p>,</span> <span class=nb>string</span><span class=p>(</span><span class=nx>content</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 按 Reduce 任务分区存储中间结果</span>
</span></span><span class=line><span class=cl>	<span class=nx>nReduce</span> <span class=o>:=</span> <span class=nx>task</span><span class=p>.</span><span class=nx>NReduce</span>
</span></span><span class=line><span class=cl>	<span class=nx>intermediate</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([][]</span><span class=nx>KeyValue</span><span class=p>,</span> <span class=nx>nReduce</span><span class=p>)</span> <span class=c1>// reduceID -&gt; kv ?</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>kv</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>kvs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>reduceID</span> <span class=o>:=</span> <span class=nf>ihash</span><span class=p>(</span><span class=nx>kv</span><span class=p>.</span><span class=nx>Key</span><span class=p>)</span> <span class=o>%</span> <span class=nx>nReduce</span>
</span></span><span class=line><span class=cl>		<span class=nx>intermediate</span><span class=p>[</span><span class=nx>reduceID</span><span class=p>]</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>intermediate</span><span class=p>[</span><span class=nx>reduceID</span><span class=p>],</span> <span class=nx>kv</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 写入临时文件并原子重命名</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>nReduce</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>reduceID</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>data</span> <span class=p>[]</span><span class=nx>KeyValue</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=nx>tempFile</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>CreateTemp</span><span class=p>(</span><span class=s>&#34;&#34;</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;mr-%d-%d.tmp&#34;</span><span class=p>,</span> <span class=nx>task</span><span class=p>.</span><span class=nx>TaskID</span><span class=p>,</span> <span class=nx>reduceID</span><span class=p>))</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;Can&#39;t create tempFile: %v&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>defer</span> <span class=nx>tempFile</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=nx>encoder</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>NewEncoder</span><span class=p>(</span><span class=nx>tempFile</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>kv</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>data</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>encoder</span><span class=p>.</span><span class=nf>Encode</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>kv</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;编码 JSON 失败: %v&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 原子重命名为最终文件名</span>
</span></span><span class=line><span class=cl>			<span class=nx>finalName</span> <span class=o>:=</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;mr-%d-%d&#34;</span><span class=p>,</span> <span class=nx>task</span><span class=p>.</span><span class=nx>TaskID</span><span class=p>,</span> <span class=nx>reduceID</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Rename</span><span class=p>(</span><span class=nx>tempFile</span><span class=p>.</span><span class=nf>Name</span><span class=p>(),</span> <span class=nx>finalName</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;重命名文件失败: %v&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>intermediate</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=executereducetask>executeReduceTask<a hidden class=anchor aria-hidden=true href=#executereducetask>#</a></h4><p>几乎同理,我们处理刚才的 Map 过程产生的文件,读取其中信息并进行解码,最终保存在一个一维切片中.</p><p>相同key作为一组调用 reducef 方法进行处理,处理完后的结果写入到输出文件中.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>executeReduceTask</span><span class=p>(</span><span class=nx>task</span> <span class=nx>Task</span><span class=p>,</span> <span class=nx>reducef</span> <span class=kd>func</span><span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=p>[]</span><span class=kt>string</span><span class=p>)</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 收集所有Map任务的中间文件</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>kvs</span> <span class=p>[]</span><span class=nx>KeyValue</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>mapID</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>mapID</span> <span class=p>&lt;</span> <span class=nx>task</span><span class=p>.</span><span class=nx>NMap</span><span class=p>;</span> <span class=nx>mapID</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fileName</span> <span class=o>:=</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;mr-%d-%d&#34;</span><span class=p>,</span> <span class=nx>mapID</span><span class=p>,</span> <span class=nx>task</span><span class=p>.</span><span class=nx>TaskID</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>file</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Open</span><span class=p>(</span><span class=nx>fileName</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span> <span class=c1>// 忽略未完成的 Map 任务文件</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>decoder</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>NewDecoder</span><span class=p>(</span><span class=nx>file</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=kd>var</span> <span class=nx>kv</span> <span class=nx>KeyValue</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>decoder</span><span class=p>.</span><span class=nf>Decode</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>kv</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>break</span> <span class=c1>// 读完所有记录</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>kvs</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>kvs</span><span class=p>,</span> <span class=nx>kv</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>file</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 按 Key 排序</span>
</span></span><span class=line><span class=cl>	<span class=nx>sort</span><span class=p>.</span><span class=nf>Slice</span><span class=p>(</span><span class=nx>kvs</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span> <span class=k>return</span> <span class=nx>kvs</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>Key</span> <span class=p>&lt;</span> <span class=nx>kvs</span><span class=p>[</span><span class=nx>j</span><span class=p>].</span><span class=nx>Key</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 分组调用Reduce,找key相同的集合放到values中</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>results</span> <span class=p>[]</span><span class=kt>string</span>
</span></span><span class=line><span class=cl>	<span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>kvs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>j</span> <span class=o>:=</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>kvs</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=nx>kvs</span><span class=p>[</span><span class=nx>j</span><span class=p>].</span><span class=nx>Key</span> <span class=o>==</span> <span class=nx>kvs</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>Key</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>j</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>keys</span> <span class=o>:=</span> <span class=nx>kvs</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>Key</span>
</span></span><span class=line><span class=cl>		<span class=nx>values</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>k</span> <span class=o>:=</span> <span class=nx>i</span><span class=p>;</span> <span class=nx>k</span> <span class=p>&lt;</span> <span class=nx>j</span><span class=p>;</span> <span class=nx>k</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>values</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>values</span><span class=p>,</span> <span class=nx>kvs</span><span class=p>[</span><span class=nx>k</span><span class=p>].</span><span class=nx>Value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>result</span> <span class=o>:=</span> <span class=nf>reducef</span><span class=p>(</span><span class=nx>keys</span><span class=p>,</span> <span class=nx>values</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>results</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>results</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;%v %v\n&#34;</span><span class=p>,</span> <span class=nx>keys</span><span class=p>,</span> <span class=nx>result</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=nx>i</span> <span class=p>=</span> <span class=nx>j</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 写入 Reduce 输出文件</span>
</span></span><span class=line><span class=cl>	<span class=nx>tempFile</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>CreateTemp</span><span class=p>(</span><span class=s>&#34;&#34;</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;mr-out-%d.tmp&#34;</span><span class=p>,</span> <span class=nx>task</span><span class=p>.</span><span class=nx>TaskID</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;创建临时文件失败: %v&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>tempFile</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>tempFile</span><span class=p>.</span><span class=nf>WriteString</span><span class=p>(</span><span class=nx>strings</span><span class=p>.</span><span class=nf>Join</span><span class=p>(</span><span class=nx>results</span><span class=p>,</span> <span class=s>&#34;&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;写入文件失败: %v&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>finalName</span> <span class=o>:=</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;mr-out-%d&#34;</span><span class=p>,</span> <span class=nx>task</span><span class=p>.</span><span class=nx>TaskID</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Rename</span><span class=p>(</span><span class=nx>tempFile</span><span class=p>.</span><span class=nf>Name</span><span class=p>(),</span> <span class=nx>finalName</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;文件重命名失败: %v&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>至此, Worker.go 结束.
最后执行实验命令可以通过实验.</p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>至此,就是我对于 lab1 的做法流程梳理,实现了一个小型的 MapReduce 分布式框架结构,这对于我自己目前在做的毕业设计项目也有很好的启发.</p><p>特别是在 Task 如何定义,在 lab 中我们定义为了 go 中的 struct,在未来要写的分布式框架中我们对于不同的 Task 的定义是通过 json 文件进行定义,来确定其所占据的资源信息.</p><p><strong>这里是LTX，感谢您阅读这篇博客，人生海海，和自己对话，像只蝴蝶纵横四海。</strong></p><h2 id=引用>引用<a hidden class=anchor aria-hidden=true href=#引用>#</a></h2><ul><li><a href=https://pdos.csail.mit.edu/6.824/labs/lab-mr.html>https://pdos.csail.mit.edu/6.824/labs/lab-mr.html</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://LTXWorld.github.io/tags/mit/>Mit</a></li><li><a href=https://LTXWorld.github.io/tags/lab/>Lab</a></li><li><a href=https://LTXWorld.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/>分布式</a></li></ul><nav class=paginav><a class=prev href=https://LTXWorld.github.io/posts/041traefik/><span class=title>« 上一页</span><br><span>K3sEP13——遇到的Traedfik问题</span>
</a><a class=next href=https://LTXWorld.github.io/posts/038k3sep12%E7%9B%91%E6%8E%A7%E9%9B%86%E7%BE%A4/><span class=title>下一页 »</span><br><span>K3sEP12——监控集群的两种方式</span></a></nav></footer><div id=tw-comment></div><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="light"?"light":"dark",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const s={src:"https://giscus.app/client.js","data-repo":"LTXWorld/LTXWorld.github.io","data-repo-id":"R_kgDONODUuA","data-category":"Announcements","data-category-id":"DIC_kwDONODUuM4CkMUw","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"zh-CN","data-loading":"lazy",crossorigin:"anonymous"},e=document.createElement("script");Object.entries(s).forEach(([t,n])=>e.setAttribute(t,n)),document.querySelector("#tw-comment").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme);const n=document.querySelector("#theme-toggle-float");n&&n.addEventListener("click",setGiscusTheme)})</script></article></main><footer class=footer><span><a href=https://LTXWorld.github.io/>©2025 LTX&rsquo;s Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><div class=ltx-music-player id=ltx-music-player role=group aria-label=背景音乐播放器><audio id=ltx-music-audio preload=metadata></audio><div class=ltx-drag-handle data-role=drag-handle title=上下拖动调整位置></div><div class=ltx-music-header><div class=ltx-music-visual><div class=ltx-disc data-role=disc aria-hidden=true><img data-role=cover alt loading=lazy decoding=async><div class=ltx-disc-center></div></div></div><div class=ltx-music-meta><span class=ltx-music-title data-role=title></span>
<span class=ltx-music-artist data-role=artist></span></div><button type=button class=ltx-music-hide data-action=collapse aria-label=隐藏播放器>&#215;</button></div><div class=ltx-music-progress data-role=progress aria-label=进度条 role=slider><div class=ltx-music-progress-fill data-role=progress-fill></div></div><div class=ltx-music-time><span data-role=current>0:00</span>
<span data-role=total>--:--</span></div><div class=ltx-music-controls><button type=button data-action=prev aria-label=上一首>⏮</button>
<button type=button data-action=toggle aria-label=播放或暂停>
<span data-icon=play>▶</span>
<span data-icon=pause>⏸</span>
</button>
<button type=button data-action=next aria-label=下一首>⏭</button>
<button type=button data-action=mute aria-label=静音或取消静音>
<span data-icon=unmuted>🔊</span>
<span data-icon=muted>🔇</span></button></div><div class=ltx-autoplay-tip data-role=tip aria-live=polite></div></div><button type=button class=ltx-music-fab id=ltx-music-fab aria-label=显示音乐播放器>&#9835;</button>
<script>window.LTX_MUSIC_CONFIG={autoplay:!0,defaultCover:"",loopPlaylist:!0,startVolume:.6,tracks:[{artist:"王力宏",file:"/audio/02 - 依然爱你.mp3",title:"依然爱你"},{artist:"王力宏",file:"/audio/05 - 改变自己.mp3",title:"改变自己"},{artist:"王力宏",file:"/audio/11 - 爱错.mp3",title:"爱错"}]},function(){const a=window.LTX_MUSIC_CONFIG||{};if(!a.tracks||!a.tracks.length)return;const e=document.getElementById("ltx-music-player"),t=e.querySelector("audio"),x=e.querySelector('[data-role="title"]'),O=e.querySelector('[data-role="artist"]'),b=e.querySelector('[data-role="progress"]'),A=e.querySelector('[data-role="progress-fill"]'),F=e.querySelector('[data-role="current"]'),M=e.querySelector('[data-role="total"]'),c=e.querySelector('[data-role="tip"]'),r=e.querySelector('[data-role="cover"]'),S=e.querySelector('[data-action="toggle"]'),y=e.querySelector('[data-action="prev"]'),k=e.querySelector('[data-action="next"]'),E=e.querySelector('[data-action="mute"]'),g=e.querySelector('[data-action="collapse"]'),i=e.querySelector('[data-role="drag-handle"]'),o=document.getElementById("ltx-music-fab"),f=(e,t,n)=>Math.min(Math.max(e,t),n),j=e=>{if(!Number.isFinite(e))return"--:--";const t=Math.floor(e/60),n=Math.floor(e%60);return`${String(t).padStart(1,"0")}:${String(n).padStart(2,"0")}`},C=-120,_=220,w=180,s={active:!1,startY:0,startOffset:0,pointerId:null},n={index:0,tracks:a.tracks,autoplay:a.autoplay!==!1,loopPlaylist:a.loopPlaylist!==!1,offset:0,collapsed:!1},h=t=>{n.offset=f(t,C,_),e.style.setProperty("--ltx-offset",`${n.offset}px`)},l=t=>{const s=Boolean(t);n.collapsed=s,e.classList.toggle("ltx-collapsed",s),s?(e.classList.remove("ltx-dragging"),n.offset=0,e.style.removeProperty("--ltx-offset"),o&&(o.classList.add("ltx-visible"),o.setAttribute("aria-hidden","false"),o.tabIndex=0)):(h(0),o&&(o.classList.remove("ltx-visible"),o.setAttribute("aria-hidden","true"),o.tabIndex=-1))},m=()=>{const n=t.muted||t.volume===0;e.classList.toggle("ltx-muted",n)};t.volume=f(a.startVolume??.6,0,1),m(),l(!1);const d=()=>{const e=t.duration||0,n=t.currentTime||0,s=e?n/e*100:0;A.style.width=`${s}%`,F.textContent=j(n),M.textContent=j(e)},u=(s,o={})=>{const l=n.tracks.length;n.index=(s%l+l)%l;const i=n.tracks[n.index];if(!i||!i.file){console.warn("LTX music player: 音频文件缺失",i),c.textContent="音频文件缺失，请检查配置";return}const u=i.cover||a.defaultCover||"";r&&(u?(r.src=u,r.alt=i.title?`${i.title} 封面`:"音乐封面",e.classList.add("ltx-has-cover")):(r.removeAttribute("src"),r.alt="",e.classList.remove("ltx-has-cover"))),x.textContent=i.title||`Track ${n.index+1}`,O.textContent=i.artist||"",t.src=i.file,e.dataset.trackIndex=n.index,c.textContent="",e.classList.remove("ltx-autoplay-blocked"),d(),o.play&&p()},p=()=>{t.play().then(()=>{e.classList.remove("ltx-autoplay-blocked"),c.textContent=""}).catch(()=>{e.classList.add("ltx-autoplay-blocked"),c.textContent="浏览器阻止了自动播放，请点击播放按钮"})},v=(e=!1)=>{const o=!t.paused||e,s=n.index+1;if(s>=n.tracks.length&&!n.loopPlaylist){t.currentTime=t.duration||0,t.pause();return}u(s,{play:o})},T=()=>{const e=!t.paused;u(n.index-1,{play:e})};if(g&&g.addEventListener("click",()=>l(!0)),o&&(o.addEventListener("click",()=>l(!1)),o.setAttribute("aria-hidden","true"),o.tabIndex=-1),i){i.style.touchAction="none",i.addEventListener("pointerdown",t=>{if(n.collapsed)return;if(s.active=!0,s.pointerId=t.pointerId,s.startY=t.clientY,s.startOffset=n.offset,i.setPointerCapture)try{i.setPointerCapture(t.pointerId)}catch{}e.classList.add("ltx-dragging")}),i.addEventListener("pointermove",e=>{if(!s.active)return;const t=e.clientY-s.startY;h(s.startOffset+t)});const t=()=>{if(!s.active)return;if(s.pointerId!==null&&i.releasePointerCapture)try{i.releasePointerCapture(s.pointerId)}catch{}s.active=!1,s.pointerId=null,e.classList.remove("ltx-dragging"),n.offset>w?l(!0):h(n.offset)};["pointerup","pointercancel"].forEach(e=>{i.addEventListener(e,t)}),i.addEventListener("pointerleave",()=>{if(!s.active)return;t()})}S.addEventListener("click",()=>{t.paused?p():t.pause()}),y.addEventListener("click",T),k.addEventListener("click",()=>v(!1)),E.addEventListener("click",()=>{t.muted=!t.muted,m()}),b.addEventListener("click",e=>{const n=b.getBoundingClientRect(),s=f((e.clientX-n.left)/n.width,0,1);Number.isFinite(t.duration)&&(t.currentTime=s*t.duration)}),t.addEventListener("timeupdate",d),t.addEventListener("loadedmetadata",d),t.addEventListener("play",()=>{e.classList.add("ltx-playing"),e.classList.remove("ltx-autoplay-blocked"),c.textContent=""}),t.addEventListener("pause",()=>{e.classList.remove("ltx-playing")}),t.addEventListener("ended",()=>{v(!0)}),t.addEventListener("volumechange",m),u(0,{play:n.autoplay})}()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>